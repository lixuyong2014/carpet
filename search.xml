<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring初学</title>
      <link href="/2022/02/28/spring/Spring%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/28/spring/Spring%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202202272253698.png" alt="202202272253698"></p><p><strong>IOC（Inversion Of Control）：</strong>控制反转，Spring反向控制应用程序所需使用的外部资源</p><p>**DI（Dependency Injection）:**依赖注入，应用程序运行依赖的资源由Spring为其提供，资源进入应用程序的方式称为注入</p><h3 id="XML配置文件"><a href="#XML配置文件" class="headerlink" title="XML配置文件"></a>XML配置文件</h3><p>文件头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class="line"> xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context     </span><br><span class="line">https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!--context是为了导入properties文件而开启的命名空间--&gt;</span><br></pre></td></tr></table></figure><p>导入外部资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath:filename.properties&quot;&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;&gt;</span><br><span class="line">表示导入所有properties文件</span><br></pre></td></tr></table></figure><p>这样就可以在其他位置通过${key}使用properties里面的键值对了</p><ul><li><p><strong>标签</strong></p><ul><li><strong>bean</strong><ul><li><strong>属性：</strong><ul><li>id：指定唯一标识</li><li>name：不满id取的标识时，可以同时起其他多个名字</li><li>class：bean的类型</li><li>scope：两种取值：singleton（默认）和prototype<ul><li>singleton：单例模式，创建多个对象时，这多个对象相等，占用内存相同<ul><li>spring容器中有且仅有一个对象，init方法在创建容器时仅执行一次</li><li>关闭容器会导致bean实例的销毁，调用destroy方法一次</li></ul></li><li>prototype：非单例模式，创建多个对象时，这多个对象不相等，占用内存不相同<ul><li>spring容器要创建同一类型的多个对象，init方法在每个对象创建时均执行一次</li><li>对象的销毁由垃圾回收机制gc()控制，destroy方法将不会被执行</li></ul></li></ul></li><li>init-method：表示对象创建时调用的对象中的方法</li><li>destroy-method：表示对象销毁时调用的对象中的方法</li></ul></li><li><strong>子标签：</strong><ul><li>property：用来set注入属性<ul><li>name：对应bean中的属性名，要求该属性必须提供可访问的set方法（严格规范为此名称是set方法对应名称）</li><li>value：设定非引用类型属性对应的值，不能与ref同时使用</li><li>ref：设定引用类型属性对应bean的id ，不能与value同时使用</li><li>注意：<ul><li>一个bean可以有多个property标签</li></ul></li><li>子标签<ul><li>list：集合类型注入<ul><li>子标签<ul><li>value：可以有多个，代表集合中的值</li></ul></li></ul></li><li>props：集合类型注入<ul><li>子标签<ul><li>prop：属性为key，标签中包含内容为值。例如：<ul><li>&lt;prop key&#x3D;”name”&gt;itdog&lt;&#x2F;prop&gt;</li></ul></li></ul></li></ul></li><li>array ：同list，子标签为value</li><li>set：同list，子标签为value</li><li>map：映射类型注入<ul><li>子标签<ul><li>entry：两个属性key和value。例如：<ul><li>&lt;entry  key&#x3D;”name”  value&#x3D;”itdog”&#x2F;&gt;</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>constructor-arg：构造器注入属性<ul><li>name：对应bean中的构造方法所携带的参数名</li><li>value：设定非引用类型构造方法参数对应的值，不能与ref同时使用</li><li>ref：设定引用类型构造方法参数对应bean的id ，不能与value同时使用</li><li>type ：设定构造方法<strong>参数的类型</strong>，用于按类型匹配参数或进行类型校验</li><li>index ：设定构造方法参数的位置，用于按位置匹配参数，参数index值从0开始计数</li></ul></li></ul></li></ul></li><li>import：在当前配置文件中导入其他配置文件中的项<ul><li><strong>属性：</strong><ul><li>resource：加载的配置文件名</li></ul></li><li><strong>注意：</strong><ul><li>导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置</li><li>同id的bean，后定义的覆盖先定义的</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202202272301930.png" alt="1591021082290"></p></li><li><p>跟ClassPathXmlApplicationContext同级的还有FileSystemXmlApplicationContext</p><ul><li>FileSystemXmlApplicationContext可以加载文件系统中任意位置的配置文件，而ClassPathXmlApplicationContext只能加载类路径下的配置文件</li></ul></li><li><p>ApplicationContext的顶层接口是BeanFactory</p></li><li><p>BeanFactory定义了bean相关的最基本操作</p></li><li><p>ApplicationContext在BeanFactory基础上追加了若干新功能</p></li><li><p>BeanFactory创建的bean采用延迟加载形式，使用才创建</p></li><li><p>ApplicationContext创建的bean默认采用立即加载形式</p></li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><table><thead><tr><th align="center">类注解</th><th></th><th align="center">方法注解</th><th>属性注解</th></tr></thead><tbody><tr><td align="center">@Component</td><td></td><td align="center">@DependsOn</td><td>@Autowired</td></tr><tr><td align="center">@Controller</td><td></td><td align="center">@Lazy</td><td>@Qualifier</td></tr><tr><td align="center">@Service</td><td></td><td align="center">@Bean</td><td>@Value</td></tr><tr><td align="center">@Repository</td><td></td><td align="center">@Autowired</td><td></td></tr><tr><td align="center">@Scope</td><td></td><td align="center">@Qualifier</td><td></td></tr><tr><td align="center">@Order</td><td></td><td align="center">@Value</td><td></td></tr><tr><td align="center">@Configuration</td><td></td><td align="center">@PostConstruct</td><td></td></tr><tr><td align="center">@ComponentScan</td><td></td><td align="center">@PreDestroy</td><td></td></tr><tr><td align="center">@PropertySource</td><td></td><td align="center"></td><td></td></tr><tr><td align="center">@DependsOn</td><td></td><td align="center"></td><td></td></tr><tr><td align="center">@Import</td><td></td><td align="center"></td><td></td></tr><tr><td align="center">@Lazy</td><td></td><td align="center"></td><td></td></tr><tr><td align="center">@Primary</td><td></td><td align="center"></td><td></td></tr><tr><td align="center"></td><td></td><td align="center"></td><td></td></tr><tr><td align="center"></td><td></td><td align="center"></td><td></td></tr><tr><td align="center"></td><td></td><td align="center"></td><td></td></tr><tr><td align="center"></td><td></td><td align="center"></td><td></td></tr><tr><td align="center"></td><td></td><td align="center"></td><td></td></tr><tr><td align="center"></td><td></td><td align="center"></td><td></td></tr></tbody></table><ol><li><p>启动注解功能</p><ul><li><p>首先，启动注解扫描，加载类中配置的注解项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;packageName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li><p>在进行包所扫描时，会对配置的包及其子包中所有文件进行扫描</p></li><li><p>扫描过程是以文件夹递归迭代的形式进行的</p></li><li><p>扫描过程仅读取合法的java文件</p></li><li><p>扫描时仅读取spring可识别的注解</p></li><li><p>扫描结束后会将可识别的有效注解转化为spring对应的资源加入IoC容器</p></li></ul></li><li><p>注意：</p><ul><li>无论是注解格式还是XML配置格式，最终都是将资源加载到IoC容器中，差别仅仅是数据读取方式不同</li><li>从加载效率上来说注解优于XML配置文件</li></ul></li></ul></li><li><p>bean的定义</p><ul><li>bean的定义变成了注解的模式，加上以下四种标签表明该类是一个bean，需要加到spring容器中</li><li>类注解，在类的上方加注解</li><li>@Component：通用，剩下三种功能跟这个完全相同</li><li>@Controller：用于表示层的bean</li><li>@Service：用于服务层的bean</li><li>@Repository：用于数据层的bean</li><li>以上四种注解有一个属性value（默认）：定义bean的访问id</li></ul></li><li><p>bean的作用域</p><ul><li>类注解，在类的上方加注解</li><li>@Scope</li><li>有一个属性value（默认）：定义bean的作用域，默认为singleton</li></ul></li><li><p>bean的生命周期</p><ul><li>@PostConstruct、@PreDestroy</li><li>方法注解，在方法的上方加注解</li><li>相当于init-method和destroy-method</li></ul></li><li><p>加载第三方资源</p><ul><li><p>@Bean</p></li><li><p>方法注解，在方法的上方加注解</p></li><li><p>设置该方法的返回值作为spring管理的bean</p></li><li><p>例如：</p><ul><li>&#96;&#96;&#96;java<br>@Bean(“dataSource”)<br>public DruidDataSource createDataSource() {    return ……;    }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. bean的非引用类型属性注入</span><br><span class="line"></span><br><span class="line">   - 属性或方法注解，在属性定义上方或方法定义上方加注解</span><br><span class="line"></span><br><span class="line">   - 设置对应属性的值或对方法进行传参</span><br><span class="line"></span><br><span class="line">   - 范例：</span><br><span class="line"></span><br><span class="line">     ```java</span><br><span class="line">     @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">     private String username;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>说明：</p><ul><li><p>value值仅支持非引用类型数据，赋值时对方法的所有参数全部赋值</p></li><li><p>value值支持读取properties文件中的属性值，通过类属性将properties中数据传入类中</p></li><li><p>value值支持SpEL</p></li><li><p>@value注解如果添加在属性上方，可以省略set方法（set方法的目的是为属性赋值）</p></li></ul></li><li><p>相关属性</p><ul><li>value（默认）：定义对应的属性值或参数值</li></ul></li></ul></li><li><p>bean的引用类型属性注入</p><ul><li><p>@Autowired、@Qualifier</p></li><li><p>属性或方法注解，在属性定义上方或方法定义上方加注解</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li><li><p>相关属性</p><ul><li>required：定义该属性是否允许为null</li></ul></li><li><p>@Primary</p><ul><li>类注解，在类的上方加注解</li><li>设置类对应的bean按类型装配时优先装配</li></ul></li><li><p>说明：</p><ul><li>@Autowired默认按类型装配，指定@Qualifier后可以指定自动装配的bean的id</li><li>@Autowired默认按类型装配，当出现相同类型的bean，使用@Primary提高按类型自动装配的优先级，多个@Primary会导致优先级设置无效</li></ul></li></ul></li><li><p>加载properties文件</p><ul><li><p>@PropertySource</p></li><li><p>类注解，在类的上方加注解</p></li><li><p>加载properties文件中的属性值</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:filename.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;propertiesAttributeName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String attributeName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>不支持*通配格式，一旦加载，所有spring控制的bean中均可使用对应属性值</li></ul></li><li><p>相关属性</p><ul><li>value（默认）：设置加载的properties文件名</li><li>ignoreResourceNotFound：如果资源未找到，是否忽略，默认为false</li></ul></li></ul></li><li><p>纯注解格式</p><ul><li><p>@Configuration、@ComponentScan</p></li><li><p>类注解，在类的上方加注解</p></li><li><p>设置当前类为spring核心配置加载类，类似于applicationContext.xml文件</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;scanPackageName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigClassName</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li><p>核心配置类用于替换spring核心配置文件，此类可以设置空的，不设置变量与属性</p></li><li><p>bean扫描工作使用注解@ComponentScan替代</p></li></ul></li></ul><p><strong>AnnotationConfigApplicationContext代替ClassPathXmlApplicationContext</strong></p><ul><li><p>加载纯注解格式上下文对象，需要使用AnnotationConfigApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第三方bean配置与管理</p><ul><li><p>@Import</p></li><li><p>类注解，在类的上方加注解</p></li><li><p>作用：导入第三方bean作为spring控制的资源</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(OtherClassName.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>@Import注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式{one.class,two.class,…}进行设定</li><li>在被导入的类中可以继续使用@Import导入其他资源（了解）</li><li>@Bean所在的类可以使用导入的形式进入spring容器，无需声明为bean</li></ul></li></ul></li><li><p>依赖加载</p><ul><li><p>@DependsOn</p></li><li><p>类注解、方法注解</p></li><li><p>bean定义的位置（类上或方法上）</p></li><li><p>控制bean的加载顺序，使其在指定bean加载完毕后再加载</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DependsOn(&quot;beanId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li><p>配置在方法上，使@DependsOn指定的bean优先于@Bean配置的bean进行加载</p></li><li><p>配置在类上，使@DependsOn指定的bean优先于当前类中所有@Bean配置的bean进行加载</p></li><li><p>配置在类上，使@DependsOn指定的bean优先于@Component等配置的bean进行加载</p></li></ul></li><li><p>相关属性</p><ul><li>value（默认）：设置当前bean所依赖的bean的id</li></ul></li><li><p>@Order</p></li><li><p><strong>配置类注解</strong></p></li><li><p>位置：配置类定义的位置（类上）</p></li><li><p>作用：控制配置类的加载顺序</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Lazy</p></li><li><p><strong>类注解、方法注解</strong></p></li><li><p>位置：bean定义的位置（类上或方法上）</p></li><li><p>作用：控制bean的加载时机，使其延迟加载</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设定组件扫描加载过滤器</p><ul><li><p>@ComponentScan</p></li><li><p>类型：<strong>类注解</strong></p></li><li><p>位置：类定义上方</p></li><li><p>作用：设置spring配置加载类扫描规则</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    value=&quot;com.itheima&quot;,           //设置基础扫描路径</span></span><br><span class="line"><span class="meta">    excludeFilters =                   //设置过滤规则，当前为排除过滤</span></span><br><span class="line"><span class="meta">@ComponentScan.Filter(            //设置过滤器</span></span><br><span class="line"><span class="meta">    type= FilterType.ANNOTATION,  //设置过滤方式为按照注解进行过滤</span></span><br><span class="line"><span class="meta">    classes=Repository.class)     //设置具体的过滤项，过滤所有@Repository修饰的bean</span></span><br><span class="line"><span class="meta">    )</span></span><br></pre></td></tr></table></figure></li></ul><p>​    includeFilters：设置包含性过滤器</p><p>​    excludeFilters：设置排除性过滤器</p><p>​    type：设置过滤器类型</p></li><li><p>自定义导入器</p><ul><li><p>bean只有通过配置才可以进入spring容器，被spring加载并控制</p></li><li><p>配置bean的方式如下：</p><ul><li><p>XML文件中使用&lt;bean&#x2F;&gt;标签配置</p></li><li><p>使用@Component及衍生注解配置</p></li></ul></li><li><p>企业开发过程中，通常需要配置大量的bean，需要一种快速高效配置大量bean的方式</p></li></ul><p><strong>ImportSelector</strong></p><ul><li><p>名称： ImportSelector</p></li><li><p>类型：<strong>接口</strong></p></li><li><p>作用：自定义bean导入器</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata icm) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.itheima.dao.impl.AccountDaoImpl&quot;</span>&#125;;<span class="comment">//往这里加要导入的bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自定义注册器</p><ul><li><p>名称：ImportBeanDefinitionRegistrar</p></li><li><p>类型：<strong>接口</strong></p></li><li><p>作用：自定义bean定义注册器</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata icm, BeanDefinitionRegistry r)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(r, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">TypeFilter</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeFilter</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader mr, MetadataReaderFactory mrf)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        scanner.addIncludeFilter(tf);</span><br><span class="line">        <span class="comment">//scanner.addExcludeFilter(tf);</span></span><br><span class="line">        scanner.scan(<span class="string">&quot;com.itheima&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>bean初始化过程解析</p><ul><li><p>BeanFactoryPostProcessor</p><ul><li><p>作用：定义了在bean工厂对象创建后，bean对象创建前执行的动作，用于对工厂进行创建后业务处理</p></li><li><p>运行时机：当前操作用于对工厂进行处理，仅运行一次</p></li></ul></li><li><p>BeanPostProcessor</p><ul><li><p>作用：定义了所有bean初始化前后进行的统一动作，用于对bean进行创建前业务处理与创建后业务处理</p></li><li><p>运行时机：当前操作伴随着每个bean的创建过程，每次创建bean均运行该操作</p></li></ul></li><li><p>InitializingBean</p><ul><li><p>作用：定义了每个bean的初始化前进行的动作，属于非统一性动作，用于对bean进行创建前业务处理</p></li><li><p>运行时机：当前操作伴随着任意一个bean的创建过程，保障其个性化业务处理</p></li></ul></li><li><p>注意：上述操作均需要被spring容器加载放可运行</p></li></ul></li><li><p>繁琐的bean初始化过程处理</p><ul><li>FactoryBean<ul><li>对单一的bean的初始化过程进行封装，达到简化配置的目的</li></ul></li><li><strong>FactoryBean与BeanFactory区别</strong><ul><li><p>FactoryBean：封装单个bean的创建过程</p></li><li><p>BeanFactory：Spring容器顶层接口，定义了bean相关的获取操作</p></li></ul></li></ul></li></ol><p>Spring整合Junit测试用例注解格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IoC核心接口"><a href="#IoC核心接口" class="headerlink" title="IoC核心接口"></a>IoC核心接口</h3><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202202272301931.png" alt="1591024936518"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件结构</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a><strong>PE文件</strong></h1><p><strong>PE（Portable Executable可移植的执行体）</strong>，它是Win32自身所带的执行体文件格式。在Windows操作系统下，所有的可执行文件都是PE文件格式。包括：EXE文件、DLL文件、SYS文件、OCX文件等。</p><p>所有的PE文件都按照PE文件结构的方式组织存在的。PE文件结构不是一个单纯的结构。一个PE文件由若干个结构集合而成，不同的结构有不同的用处。</p><p>PE文件格式是对Windows下可执行文件的一种管理方式。</p><p>即使windows运行在非Intel的CPU上，任何win32平台的PE装载器都能识别和使用该文件格式。</p><p><strong>windows下每个进程都有独立的4G地址空间，低两G（0x00000000<del>0x7fffffff）给应用程序使用，高两G（0x80000000</del>0xFFFFFFFF）给系统内核使用。</strong></p><p>PE文件中经常用到三种地址：</p><ul><li>相对虚拟地址（Relative Virual Address，RVA，也可以说成偏移量）:是PE文件中的数据、模块等运行在内存中的实际地址相对PE文件装载到内存的基址之间的距离。</li><li>虚拟地址（Virtual Address，VA）</li><li>文件偏移地址（File Offset Address，FOA）<img src="https://img2018.cnblogs.com/blog/1130413/201908/1130413-20190805224219733-511382197.png" alt="img"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041337387.png" alt="image-20211031132258093"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041337678.png" alt="image-20211031155540926"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041338808.png" alt="image-20211030215246744"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041345469.png" alt="image-20211031132258093"></p><p>DOS头部在winnt.h头文件中的定义如下：（该文件头的大小为64个字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class="line">    WORD e_magic;                           <span class="comment">//0000h EXE标志 MZ              下图中的4D 5A</span></span><br><span class="line">    WORD e_cblp;                            <span class="comment">//0002h 最后（部分）页中的字节数    下图中的90 00</span></span><br><span class="line">    WORD e_cp;                              <span class="comment">//0004h 文件中的全部和部分页数      03 00</span></span><br><span class="line">    WORD e_crlc;                            <span class="comment">//0006h 重定位表中的指针数         00 00</span></span><br><span class="line">    WORD e_cparhdr;                         <span class="comment">//0008h 头部尺寸，以段位为单位      04 00</span></span><br><span class="line">    WORD e_minalloc;                        <span class="comment">//000Ah 所需的最小附加段           00 00</span></span><br><span class="line">    WORD e_maxalloc;                        <span class="comment">//000Ch 所需的最大附加段           FF FF</span></span><br><span class="line">    WORD e_ss;                              <span class="comment">//000Eh 初始的SS值（相对偏移量）    00 00</span></span><br><span class="line">    WORD e_sp;                              <span class="comment">//0010h 初始的SP值                B8 00</span></span><br><span class="line">    WORD e_csum;                            <span class="comment">//0012h 校验和                   00 00</span></span><br><span class="line">    WORD e_ip;                              <span class="comment">//0014h 初始的IP值                00 00</span></span><br><span class="line">    WORD e_cs;                              <span class="comment">//0016h 初始的CS值                00 00</span></span><br><span class="line">    WORD e_lfarlc;                          <span class="comment">//0018h 重定位表的字节偏移量        40 00</span></span><br><span class="line">    WORD e_ovno;                            <span class="comment">//001Ah 覆盖号                    00 00</span></span><br><span class="line">    WORD e_res[<span class="number">4</span>];                          <span class="comment">//001Ch 保留字                     00 00 00 00 00 00 00 00</span></span><br><span class="line">    WORD e_oemid;                           <span class="comment">//0024h OEM标识符（相对e_oeminfo）  00 00</span></span><br><span class="line">    WORD e_oeminfo;                         <span class="comment">//0026h OEM信息                   00 00</span></span><br><span class="line">    WORD e_res2[<span class="number">10</span>];                        <span class="comment">//0028h 保留字                    00 00 00 00 ... 00</span></span><br><span class="line">    LONG e_lfanew;                          <span class="comment">//003Ch PE头相对于文件的偏移地址，也就是结构体IMAGE_NT_HEADERS的开头  08 01 00 00 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DOS_SIGNATURE       0X4D5A    <span class="comment">//MZ</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041339933.png" alt="image-20211030224820067"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span>&#123;</span></span><br><span class="line">    DWORD Signature; <span class="comment">//PE标识符 50 45 00 00</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader; <span class="comment">//文件头</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">//可选头</span></span><br><span class="line">&#125;IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span>&#123;</span> <span class="comment">//该结构体可判断文件是EXE文件还是DLL文件。占用20个字节</span></span><br><span class="line">    WORD Machine;                  <span class="comment">//0004h 运行平台  0x014c指的是Intel 386 ，而0x0200指的是Intel 64</span></span><br><span class="line">    WORD NumberOfSections;         <span class="comment">//0006h PE中节的数量 最大96个节</span></span><br><span class="line">    DWORD TimeDateStamp;           <span class="comment">//0008h 文件创建日期和时间，编译器创建此文件时的时间戳</span></span><br><span class="line">    DWORD PointerToSymbolTable;    <span class="comment">//000Ch 指向符号表（用于调试）</span></span><br><span class="line">    DWORD NumberOfSymbols;         <span class="comment">//0010h 符号表中的符号数量（用于调试）</span></span><br><span class="line">    WORD SizeOfOptionalHeader;     <span class="comment">//0014h 可选头结构体的长度 32位版本是E0 64位版本的是F0</span></span><br><span class="line">    WORD Characteristics;          <span class="comment">//0016h 文件的属性 exe文件是010f dll文件是210e</span></span><br><span class="line">&#125;IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_FILE_HEADER 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_l386   0x014c <span class="comment">// Intel 386 指的是32位系统</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_lA64   0x0200 <span class="comment">// Intel 64</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_FILE_HEADER.Characteristics的常用属性</span><br><span class="line">#define IMAGE_FILE_RELOCS_STRIPPED  0x0001 //没有重定位</span><br><span class="line">#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 //文件是可执行的</span><br><span class="line">#define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 //没有行号</span><br><span class="line">#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0X0008 //没有符号</span><br><span class="line">#define IMAGE_FILE_32BIT_MACHINE 0x0100 //32位机器</span><br><span class="line">#define IMAGE_FILE_SYSTEM   0x1000     //系统文件</span><br><span class="line">#define IMAGE_FILE_DLL      0x2000     //DLL文件</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span>&#123;</span> <span class="comment">//占用224个字节</span></span><br><span class="line">    WORD Magic;                        <span class="comment">//0018h  取值为10B或20B</span></span><br><span class="line">    BYTE MajorLinkerVersion;           <span class="comment">//001Ah  链接器版本号（对执行没有任何影响）</span></span><br><span class="line">    BYTE MinorLinkerVersion;           <span class="comment">//001Bh</span></span><br><span class="line">    DWORD SizeOfCode;                  <span class="comment">//001Ch  所有含代码的节的大小（按照文件对齐，判断某节是否含代码，使用节属性IMAGE_SCN_CNT_CODE属性判断，而不是通过IMAGE_SCN_CNT_EXECUTE）</span></span><br><span class="line">    DWORD SizeOfInitializedData;       <span class="comment">//0020h  所有含初始化数据的节的大小</span></span><br><span class="line">    DWORD SizeOfUninitializedData;     <span class="comment">//0024h  所有含未初始化数据的节的大小（被定义为未初始化，不占用文件空间，加载入内存后为其分配空间）</span></span><br><span class="line">    DWORD AddressOfEntryPoint;         <span class="comment">//0028h  程序执行入口RVA(距离PE加载后地址的距离，对于病毒和加密程序，都会修改该值，从而获得程序的控制权，对于DLL，如果没有入口函数，那么是0，对于驱动，该值是初始化的函数的地址)</span></span><br><span class="line">    DWORD BaseOfCode;                  <span class="comment">//002Ch  代码的节的起始RVA（一般情况跟在PE头部的后面） </span></span><br><span class="line">    DWORD BaseOfData;                  <span class="comment">//0030h  数据的节的起始RVA</span></span><br><span class="line">    <span class="comment">//以上是standard，以下是additional</span></span><br><span class="line">    DWORD ImageBase;                   <span class="comment">//0034h  程序的建议装载地址</span></span><br><span class="line">    DWORD SectionAlignment;            <span class="comment">//0038h  内存中的节的对齐值  32位0x1000  64位0x2000</span></span><br><span class="line">    DWORD FileAlignment;               <span class="comment">//003Ch  文件中的节的对齐值  现在都是0x1000 早期都是0x200</span></span><br><span class="line">    WORD  MajorOperatingSystemVersion; <span class="comment">//0040h  操作系统版本号</span></span><br><span class="line">    WORD  MinorOperatingSystemVersion; <span class="comment">//0042h</span></span><br><span class="line">    WORD  MajorImageVersion;           <span class="comment">//0044h  该PE的版本号</span></span><br><span class="line">    WORD  MinorImageVersion;           <span class="comment">//0046h</span></span><br><span class="line">    WORD  MajorSubsystemVersion;       <span class="comment">//0048h  所需子系统的版本号</span></span><br><span class="line">    WORD  MinorSubsystemVersion;       <span class="comment">//004Ah</span></span><br><span class="line">    DWORD Win32VersionValue;           <span class="comment">//004Ch  未使用，必须为0</span></span><br><span class="line">    DWORD SizeOfImage;                 <span class="comment">//0050h  内存中的整个PE文件映像大小（按照内存对齐）</span></span><br><span class="line">    DWORD SizeOfHeaders;               <span class="comment">//0054h  所有头+节表的大小</span></span><br><span class="line">    DWORD CheckSum;                    <span class="comment">//0058h  校验和（一般EXE文件为0，而DLL和SYS文件则必须是正确的值）</span></span><br><span class="line">    WORD  Subsystem;                   <span class="comment">//005Ch  文件子系统</span></span><br><span class="line">    WORD  DllCharacteristics;          <span class="comment">//005Eh  DLL文件特性</span></span><br><span class="line">    DWORD SizeOfStackReserve;          <span class="comment">//0060h  初始化时保留的栈的大小（默认1M）</span></span><br><span class="line">    DWORD SizeOfStackCommit;           <span class="comment">//0064h  初始化时实际提交的栈的大小（默认4K）</span></span><br><span class="line">    DWORD SizeOfHeapReserve;           <span class="comment">//0068h  初始化时保留的堆的大小（默认1M）</span></span><br><span class="line">    DWORD SizeOfHeapCommit;            <span class="comment">//006Ch  初始化时实际提交的堆大小（默认4K）</span></span><br><span class="line">    DWORD LoaderFlags;                 <span class="comment">//0070h  加载标志一般为0</span></span><br><span class="line">    DWORD NumberOfRvaAndSizes;         <span class="comment">//0074h  数据目录的数量</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory&#123;IMAGE_NUMBEROF_DIRECTORY_ENTRIES&#125;;  <span class="comment">//0078h 数据目录数组  导入表的定位由这个值给出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataDirectory：数据目录表，是个数组，由NumberOfRvaAndSize个IMAGE_DATA_DIRECTORY结构体组成。该数组包含输入表、输出表、资源等数据的RVA。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span>&#123;</span></span><br><span class="line">    DWORD VirtualAddress,</span><br><span class="line">    DWORD Size</span><br><span class="line">&#125;IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY</span><br></pre></td></tr></table></figure><p>数据目录中的第二个目录，即IMAGE_DIRECTORY_ENTRY_IMPORT（该结构体保存了导入表的RVA地址）</p><p>描述导入表的结构体是IMAGE_IMPORT_DESCRIPTOR，一个DLL文件对应一个IMAGE_IMPORT_DESCRIPTOR结构体。在文件中以全0的IMAGE_IMPORT_DESCRIPTOR为结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD OriginalFirstThunk;<span class="comment">//在磁盘中时和内存中时保存INT(IMPORT NAME TABLE)，其实保存一个RVA，该RVA就是该DLL文件的INT的地址</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD TimeDateStamp;</span><br><span class="line">    DWORD ForwarderChain;</span><br><span class="line">    DWORD Name;</span><br><span class="line">    DWORD FirstThunk;</span><br><span class="line">&#125;IMAGE_IMPORT_DESCRIPTOR<span class="comment">//在磁盘中时保存INT(IMPORT NAME TABLE),在内存中时保存IAT(IMPORT ADDRESS TABLE)，其实保存一个RVA，该RVA就是该DLL文件的IAT或INT的地址</span></span><br></pre></td></tr></table></figure><p>IAT保存了一堆函数的代码入口地址（代码入口地址就是函数执行功能的首地址），每一个函数名对应一个IMAGE_THUNK_DATA32<br>INT保存了一堆函数的名字地址（通过地址找到该函数的名称），每一个函数名对应一个IMAGE_THUNK_DATA32</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME 8</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_SIZEOF_SECTION_HEADER&#123;<span class="comment">//节表，占用40个字节</span></span><br><span class="line">    BYTE Name[IMAGE_SIZEOF_SHORT_NAME];   <span class="comment">//0000h 节名称</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        DWORD PhysicalAddress;</span><br><span class="line">        DWORD VirtualSize;                <span class="comment">//0008h 节区的尺寸</span></span><br><span class="line">    &#125;Misc;</span><br><span class="line">    DWORD VirtualAddress;                 <span class="comment">//000Ch 节区的RVA地址</span></span><br><span class="line">    DWORD SizeOfRawData;                  <span class="comment">//0010h 在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD PointerToRawData;               <span class="comment">//0014h 该节在文件中的偏移</span></span><br><span class="line">    DWORD PointerToRelocations;           <span class="comment">//0018h 在OBJ文件中使用</span></span><br><span class="line">    DWORD PointerToLinenumbers;           <span class="comment">//001Ch 行号表的位置（供调试用）</span></span><br><span class="line">    WORD NumberOfRelocations;             <span class="comment">//0020h 在OBJ文件中使用</span></span><br><span class="line">    WORD NumberOfLinenumbers;             <span class="comment">//0024h 行号表中行号的数量</span></span><br><span class="line">    DWORD Characteristics;                <span class="comment">//0028h 节的属性</span></span><br><span class="line">&#125;IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041339111.png" alt="image-20211030222927544"></p><ol><li><strong>所有可执行文件（EXE，DLL文件等）都以4D 5A开头</strong></li><li><strong>MZ为可执行（EXE，DLL文件等）文件标识</strong></li><li><strong>Intel的CPU都采用小尾方式，网络上传输数据或者其他CPU架构都采用大尾方式</strong></li><li><strong>不是MZ或者4D 5A开头的都不是可执行文件</strong></li><li><strong>有效的PE文件能从DOS头部找到PE头地址，且PE头开始标志为50 45 或者字符串中的PE</strong></li><li><strong>DOS头占用64个字节</strong></li></ol><p>从内存中的字符串的位置找到文件中的字符串的位置</p><p>1.通过VA转换为RVA</p><p>403006-400000&#x3D;3006</p><p>2.找RVA所在的节</p><p>3006在.data节</p><p>3.计算.data节起始RVA和起始FOA的差值</p><p>3000-800&#x3D;2800（十六进制相减）</p><p>4.通过RVA减去差值</p><p>3006-2800&#x3D;806</p><p><strong>添加节的步骤：</strong></p><ol><li>增加节表项，在节表的最后面添加一个IMAGE_SECTION_HEADER</li><li>修正文件的映像长度，更新IMAGE_OPTIONAL_HEADER中的SizeOfImage</li><li>修正一个节的数量，更新IMAGE_FILE_HEADER中的NumberOfSections字段</li><li>增加文件的节数据</li></ol><h3 id="需要调用外部函数库，需要用到导入表-导入表在PE文件体中"><a href="#需要调用外部函数库，需要用到导入表-导入表在PE文件体中" class="headerlink" title="需要调用外部函数库，需要用到导入表(导入表在PE文件体中)"></a>需要调用外部函数库，需要用到导入表(导入表在PE文件体中)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD Characteristics; </span><br><span class="line">        DWORD OriginalFirstThunk;  <span class="comment">//保存一个RVA，这个RVA指向一个INT（Import Name Table）表，这个表中保存的是所有导入函数名称的RVA</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD TimeDateStamp;</span><br><span class="line">    DWORD ForwarderChain;</span><br><span class="line">    DWORD Name;                    <span class="comment">//保存一个RVA，这个RVA指向的内容是DLL的文件名</span></span><br><span class="line">    DWORD FirstThunk;              <span class="comment">//保存一个RVA，这个RVA指向一个IAT（Import Address Table）表，这个表中保存的是所有导入函数的地址（VA）</span></span><br><span class="line">&#125;IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p><strong>构造PE头部，包括：</strong></p><ol><li>IMAGE_DOS_HEADER</li><li>IMAGE_PE_SIGNATURE</li><li>IAMGE_FILE_HEADER</li><li>IMAGE_OPTION_HEADER</li><li>IMAGE_SECTION_HEADER</li></ol><p><strong>构造PE体，包括：</strong></p><ol><li>构造代码.text</li><li>构造数据.data</li><li>构造导入表.rdata</li><li>修正代码</li><li>修正PE头</li></ol><p>1.加壳：压缩壳、加密壳（隐藏程序的真正入口点）、虚拟机壳（VM关键代码，让破解者毫无头绪）</p><p>加壳的过程：</p><ol><li>压缩节 1000-&gt;200</li><li>压缩引擎 体积减小</li><li>加密代码 采用加密算法</li><li>VM关键代码</li><li>隐藏导入表</li><li>写入shell</li></ol><p>2.查壳：识别程序的签名（特征码）</p><p>3.脱壳：专门的脱壳工作、通用的脱壳工具、手动脱壳（找OEP、DUMP、修复导入表）</p><p><strong>特征码通过提取指令的操作码（opcode）集合</strong></p><h4 id="PE文件主要运行步骤"><a href="#PE文件主要运行步骤" class="headerlink" title="PE文件主要运行步骤"></a>PE文件主要运行步骤</h4><ol><li>PE文件被执行，PE装载器检查DOS MZ Header里面的PE Header偏移量。如果找到则跳转到PE Header。</li><li>PE装载器检查PE Header的有效性。如果有效，就跳转到PE Header 的尾部</li><li>紧跟PE Header的是节表。PE装载器读取其中的节信息，并采用文件映射方式将这些节映射到内存中，同时附上节表里指定的节属性。</li><li>PE文件映射入内存后，PE装载器将处理PE文件中类似import table（引入表）的逻辑部分。程序加载的时候需要加载很多函数和DLL文件，这时程序需要判断目标函数的地址并将该函数插补到该执行文件的映像中，所需要的信息都是放在PE文件的Import表中，PE文件中的每一个输入函数都明确的存于该表中。</li></ol><h4 id="执行文件遇到的节"><a href="#执行文件遇到的节" class="headerlink" title="执行文件遇到的节"></a>执行文件遇到的节</h4><p>1.text节。它的内容是指令代码，必须加密。</p><p>2.data节。data包括初始化的数据，比如编译时被初始化的global和static变量，和字符串。也可加密。</p><p>3.idata节。这个节是输入数据，包括输入目录和输入地址名字表（IAT{Import Address Table}和INT{Import Name Table}）。idata包含其他外来DLL的函数及数据信息。</p><p>4.rsrc节。包括所有资源文件。</p><p>5.reloc节。reloc保存基地址重定位表（当文件刚开始装载入内存，若指定的内存装载地址已被其他进程占用，则需要此重定位表，来重定位重新装载进内存的地址，这个重定位表包含了调整所需的数据）。</p><p>6.edata节。该PE文件输出的函数和数据的表。</p><p>7.tls节。线程本地存储器。</p><p>8.rdata节。存放调试目录和说明字符串。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ida使用日记</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/ida%E4%BD%BF%E7%94%A8%E6%97%A5%E8%AE%B0/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/ida%E4%BD%BF%E7%94%A8%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CODE-XREF-代码交叉引用"><a href="#1-CODE-XREF-代码交叉引用" class="headerlink" title="1.CODE XREF:代码交叉引用"></a>1.CODE XREF:代码交叉引用</h3><p>   DATA XREF:数据交叉引用</p><p><strong>XREF分类：</strong><br>CODE XREF:代码交叉引用<br>DATA XREF:数据交叉引用</p><p><strong>XREF描述含义：<img src="https://img-blog.csdn.net/20160127145320795" alt="这里写图片描述"></strong></p><p>这是个代码交叉引用<br>sub401000是被引用者，main+2A是引用者（引用sub401000的位置)<br>下箭头表示引用者的地址比sub401000高，你需要向下滚动才能到达引用者地址（main+2A),上行反之~<br>4.每个交叉引用注释都包含一个单字符后缀（箭头后面），用以说明交叉引用的类型，这里是↓P</p><h3 id="CODE-XREF"><a href="#CODE-XREF" class="headerlink" title="CODE XREF"></a>CODE XREF</h3><p>代码交叉引用用于表示一条指令将控制权转交给另一条指令。在IDA中，指令转交控制权的方式叫做流（flow）<br><strong>IDA中有3种基本流：</strong></p><p>普通流<br>调用流<br>跳转流</p><p>示例代码：</p><p>int read_it;<br>int write_it;<br>int ref_it;<br>void callflow() {} </p><p>int main()<br>{<br>    int *p &#x3D; &amp;ref_it;<br>    *p &#x3D; read_it;<br>    write_it &#x3D; *p;<br>    callflow();<br>    if (read_it &#x3D;&#x3D; 3)<br>    {<br>        write_it &#x3D; 2;<br>    }<br>    else<br>    {<br>        write_it &#x3D; 1;<br>    }<br>    callflow();<br>}<br>示例汇编:</p><p>.text:00401010 ; int __cdecl main(int argc, const char **argv, const char **envp)<br>.text:00401010 _main           proc near               ; CODE XREF: __tmainCRTStartup+10Ap<br>.text:00401010<br>.text:00401010 p               &#x3D; dword ptr -4<br>.text:00401010 argc            &#x3D; dword ptr  8<br>.text:00401010 argv            &#x3D; dword ptr  0Ch<br>.text:00401010 envp            &#x3D; dword ptr  10h<br>.text:00401010<br>.text:00401010                 push    ebp<br>.text:00401011                 mov     ebp, esp<br>.text:00401013                 push    ecx<br>.text:00401014                 mov     [ebp+p], offset int ref_it<br>.text:0040101B                 mov     eax, [ebp+p]<br>.text:0040101E                 mov     ecx, int read_it<br>.text:00401024                 mov     [eax], ecx<br>.text:00401026                 mov     edx, [ebp+p]<br>.text:00401029                 mov     eax, [edx]<br>.text:0040102B                 mov     int write_it, eax<br>.text:00401030                 ③call    callflow(void)<br>.text:00401035                 cmp     int read_it, 3<br>.text:0040103C                 jnz     short loc_40104A<br>.text:0040103E                 mov     int write_it, 2<br>.text:00401048                 jmp     short loc_401054<br>.text:0040104A ; —————————————————————————<br>.text:0040104A<br>.text:0040104A loc_40104A:                             ; CODE XREF: _main+2C↑j<br>.text:0040104A                 mov     int write_it, 1<br>.text:00401054<br>.text:00401054 loc_401054:                             ; CODE XREF: _main+38↑j<br>.text:00401054                 ③call    callflow(void)<br>.text:00401059                 xor     eax, eax<br>.text:0040105B                 mov     esp, ebp<br>.text:0040105D                 pop     ebp<br>.text:0040105E                 retn<br>.text:0040105E _main           endp<br>.text:0040105E</p><p><strong>普通流</strong><br>普通流表示由一条指令到另一条指令的顺序流。这是所有非分支指令（如ADD）的默认执行流。</p><p><strong>调用流</strong><br>如果IDA认为某个函数并不返回（在分析阶段确定,注意不是运行阶段），那么，在调用该函数时，它就不会为该函数分配普通流</p><p>.text:00401030                 ③call    callflow(void)<br>.text:00401054                 ③call    callflow(void)<br>1<br>2<br>指令用于调用函数，如③处的 call指令，它分配到一个调用流（call flow），表示控制权被转交给目标函数<br>callflow函数的反汇编：</p><p>.text:00401000 void __cdecl callflow(void) proc near   ; ①CODE XREF: _main+20↓p<br>.text:00401000                                         ; ①_main:loc_401054↓p<br>.text:00401000                 push    ebp<br>.text:00401001                 mov     ebp, esp<br>.text:00401003                 pop     ebp<br>.text:00401004                 retn<br>.text:00401004 void __cdecl callflow(void) endp</p><p>callflow所在的位置显示了两个交叉引用(①处)，表示这个函数被调用了两次</p><p>由函数调用导致的交叉引用使用后缀↓p（看做是Procedure）。</p><p><strong>跳转流</strong><br>每个无条件分支指令和条件分支指令将分配到一个跳转流（jump flow）</p><p>.text:00401048                 jmp     short loc_401054<br>.text:0040104A ; —————————————————————————<br>.text:0040104A</p><p>无条件分支并没有相关的普通流，因为它总会进入分支。上处的虚线表示相邻的两条指令之间并不存在普通流（也就是00401048后没有跟着顺序执行的指令）</p><p>跳转交叉引用使用后缀↑j（看做是Jump）。</p><h4 id="DATA-XREF"><a href="#DATA-XREF" class="headerlink" title="DATA XREF"></a>DATA XREF</h4><p>数据交叉引用用于跟踪二进制文件访问数据的方式。数据交叉引用与IDA数据库中任何牵涉到虚拟地址的字节有关（换言之，数据交叉引用与栈变量毫无关系）<br>最常用的3种数据交叉引用:</p><p>address何时被读取(读取交叉引用)<br>address何时被写入(写入交叉引用)<br>address何时被引用(偏移量交叉引用)</p><p>.data:00403378 int ref_it      db    ? ;               ; DATA XREF: _main+4↑o<br>.data:00403379                 db    ? ;<br>.data:0040337A                 db    ? ;<br>.data:0040337B                 db    ? ;<br>.data:0040337C int write_it    dd ?                    ; DATA XREF: _main+1B↑w<br>.data:0040337C                                         ; _main+2E↑w …<br>.data:00403380 int read_it     dd ?                    ; DATA XREF: _main+E↑r<br>.data:00403380                                         ; _main+25↑r</p><p><strong>读取交叉引用</strong><br>读取交叉引用（read cross-reference）表示访问的是某个内存位置的内容<br>可以看到read_it在_main+E处、_main+25被读取,如下</p><p>.text:0040101E                 mov     ecx, int read_it<br>.text:00401035                 cmp     int read_it, 3</p><p>读取交叉引用使用后缀↑r（看做是Read）。</p><p><strong>写入交叉引用</strong><br>写入交叉引用指出了修改变量内容的程序位置<br>可以看到write_it在_main+1B、_main+2E处被写入，如下</p><p>.text:0040102B                 mov     int write_it, eax<br>.text:0040103E                 mov     int write_it, 2</p><p>写入交叉引用使用后缀↑w（看做是Write）。</p><p><strong>偏移量交叉引用</strong><br>偏移量交叉引用表示引用的是某个位置的地址（而非内容）<br>可以看到ref_it在_main+4处被引用</p><p>.text:00401014                 mov     [ebp+p], offset int ref_it</p><p>偏移量交叉引用使用后缀↑o（看做是Offset）。</p><p>与仅源自于指令位置的读取和写入交叉引用不同，偏移量交叉引用可能源于指令位置或数据位置，例如虚表<br>回溯偏移量交叉引用是一种有用的技术，可迅速在程序的数据部分定位C++虚表。</p><h3 id="使用快捷键"><a href="#使用快捷键" class="headerlink" title="使用快捷键"></a>使用快捷键</h3><ul><li>;表示添加注释</li><li>空格键将反汇编代码转换为流程图</li><li>交叉引用部分的···表明有多个交叉引用，Ctrl+X组合键即可查看所有的交叉引用</li><li>重命名函数的快捷键是N</li><li>定义函数，选中对应行后，按P键</li><li>在函数窗口中选中并按Ctrl+E组合键，或在反汇编窗口的函数内部按Alt+P组合键</li><li>反汇编窗口中选中变量、函数后按Y键，弹出对话框，从中输入正确的C语言类型，IDA就可以解析并自动应用这个类型</li><li>Alt+F7执行python文件，Shift+F2，获得简易编辑器</li><li>Shift+F12打开Strings窗口</li><li>按F2可对十六进制窗口中的数据进行修改，再按一次保存。</li></ul><p><strong>另外下面快捷键需要让光标在对应行上才能生效</strong></p><ul><li>U键：取消一个地方已有的数据类型定义，此时会弹出确认的对话框</li><li>D键：让某一个位置变成数据</li><li>C键：让某一个位置变成指令</li><li>A键：会以该位置为起点定义一个以”\0”结尾的字符串类型</li><li>*键：将此处定义为一个数组，此时弹出一个对话框，用来设置数组的属性</li><li>O键：将此处定义为一个地址偏移</li></ul><h3 id="根据地址的颜色分辨某个位置的数据类型"><a href="#根据地址的颜色分辨某个位置的数据类型" class="headerlink" title="根据地址的颜色分辨某个位置的数据类型"></a>根据地址的颜色分辨某个位置的数据类型</h3><ul><li>被标注为代码的位置，其地址将会是黑色显示的</li><li>被标注为数据的位置，其地址将会是灰色显示的</li><li>未定义数据类型的位置则会显示为黄色</li></ul><ol><li>byte，1字节整形，对应char、__int8</li><li>word，2字节整形，对应short、__int16</li><li>dword，4字节整形，对应int、__int32</li><li>qword，8字节整形，对应__int64、long long</li></ol><h3 id="FLIRT函数签名识别库"><a href="#FLIRT函数签名识别库" class="headerlink" title="FLIRT函数签名识别库"></a>FLIRT函数签名识别库</h3><p>shift+F5，打开Signature列表，其中会显示已经应用的函数签名库。<br><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041335656.png" alt="image-20211125234213921"></p><p>按insert，新增需要匹配的函数签名库</p><p><strong>如果没有匹配的签名库，则可以在网上查找相应的签名库，如：<a href="https://github.com/push0ebp/sig-database">https://github.com/push0ebp/sig-database</a> 和 <a href="https://github.com/Maktm/FLIRTDB%E7%AD%89">https://github.com/Maktm/FLIRTDB等</a></strong></p><h3 id="call-analysis-failed"><a href="#call-analysis-failed" class="headerlink" title="call analysis failed"></a>call analysis failed</h3><p>函数调用约定出错</p><h3 id="sp-analysis-failed"><a href="#sp-analysis-failed" class="headerlink" title="sp-analysis failed"></a>sp-analysis failed</h3><p>调用约定或者参数个数出错<br>解决办法：Options -》General ，弹出的对话框勾选“Stack pointer”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WindowsAPI</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/WindowsAPI%20/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/WindowsAPI%20/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Windows编程"><a href="#5-Windows编程" class="headerlink" title="5.Windows编程"></a>5.Windows编程</h1><p>Windows下的<strong>窗口</strong>应用程序都是基于消息机制的。</p><h4 id="API"><a href="#API" class="headerlink" title="API:"></a>API:</h4><p><strong>1.FindWindow()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">FindWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpClassName,</span></span><br><span class="line"><span class="params">    LPCTSTR lpWindowName</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>使用示例：::FindWindow(“Notepad”,NULL); 或者 ::FindWindow(NULL,”无标题 - 记事本”)<br>功能是：通过指定的窗口类名（lpClassName）或窗口标题（lpWindowName）查找匹配的窗口并返回最上层的窗口句柄。<br>窗口标题总是变化的话，最好使用窗口类名。</p><p><strong>2.SendMessage</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRESULT SendMessage&#123;</span><br><span class="line">    HWND hWnd,  <span class="comment">//指定接收消息的窗口的窗口句柄</span></span><br><span class="line">    UINT Msg,   <span class="comment">//要发送消息的消息类型，值有WM_CLOSE、WM_SETTEXT和WM_GETTEXT</span></span><br><span class="line">    WPARAM wParam, <span class="comment">//消息的附加参数</span></span><br><span class="line">    LPARAM lParam <span class="comment">//消息的附加参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：::SendMessage(hWnd,WM_SETTEXT,(WPARAM)0,(LPARAM)pCaptionText)<br>功能：根据指定的窗口句柄将消息发送给指定的窗口。</p><ul><li>WM_CLOSE：将WM_CLOSE消息发送后，接收到该消息的窗口或应用程序将要关闭。WM_CLOSE消息没有需要的附加参数，因此wParam和lParam两个参数都为NULL。</li><li>WM_SETTEXT：应用程序发送WM_SETTEXT消息对窗口的文本进行设置。该消息需要附加参数，wParam参数未被使用，必须指定为0值，lParam参数是一个指向以NULL为结尾的字符串的指针。</li><li>WM_GETTEXT：应用程序发送WM_GETTEXT消息，将对应窗口的文本复制到调用者的缓冲区中。该消息也需要附加参数，wParam参数指定要复制的字符数数量，lParam是接收文本的缓冲区。</li></ul><p>Windows窗口应用程序的主函数——WinMain()</p><p><strong>3.CreateFile</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpFileName,  <span class="comment">//欲打开或创建的文件名，这里可以是设备对象之类的被视为文件的相关对象。</span></span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess,   <span class="comment">//对文件的访问模式，它指定了要对打开的对象进行何种操作。有连个值，GENERIC_READ和GENERIC_WRITE,分别表示只读模式和只写模式；还可同时指定两种模式，如GENERIC_READ|GENERIC|WRITE</span></span></span><br><span class="line"><span class="params">    DWORD dwShareMode, <span class="comment">//打开文件的共享模式，表示文件被打开后是否允许其他进程进行操作，如果可以进行操作，可以指定其操作的模式</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpSecurityAttributes, <span class="comment">//安全属性，可以指定返回的文件句柄是否可以被子进程继承，值为NULL或者一个SECURITY_ATTRIBUTES的结构体的地址，通常为NULL</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationDisposition, <span class="comment">//在创建或打开的文件存在或不存在时该函数的处理方式</span></span></span><br><span class="line"><span class="params">    DWORD dwFlagsAndAttributes, <span class="comment">//指定新建文件的属性和对文件操作的方式</span></span></span><br><span class="line"><span class="params">    HANDLE hTemplateFile <span class="comment">//文件模板句柄，系统会复制该文件模板的所有属性到当前创建的文件中</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：可以打开文件也可以创建文件。</p><p><strong>4.CloseHandle</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CloseHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hObject  <span class="comment">//文件句柄等其他句柄</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：关闭文件，可关闭文件句柄、事件句柄、进程句柄、线程句柄等一系列对象句柄。</p><p><strong>5.DeleteFile</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">DeleteFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpFileName <span class="comment">//文件名</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：删除文件。</p><p><strong>6.ReadFile</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ReadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hFile, <span class="comment">//文件句柄</span></span></span><br><span class="line"><span class="params">    LPVOID lpBuffer, <span class="comment">//指向一个缓冲区，函数会将从文件中读出的数据保存在该缓冲区中。</span></span></span><br><span class="line"><span class="params">    DWORD nNumberOfBytesToRead, <span class="comment">//要求读入的字节数，通常情况下是缓冲区的大小</span></span></span><br><span class="line"><span class="params">    LPDWORD lpNumberOfBytesRead, <span class="comment">//值为指向一个DWORD类型的变量，用户返回实际读入的字节数</span></span></span><br><span class="line"><span class="params">    LPOVERLAPPED lpOverlapped <span class="comment">//一般为NULL</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：读文件</p><p><strong>7.WriteFile</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hFile, <span class="comment">//文件句柄</span></span></span><br><span class="line"><span class="params">    LPCVOID lpBuffer, <span class="comment">//指向一个缓冲区，该函数会将该缓冲区的内容进行写入。</span></span></span><br><span class="line"><span class="params">    DWORD nNumberOfBytesToWrite,<span class="comment">//要求写入的字节数，通常情况下是缓冲区的大小</span></span></span><br><span class="line"><span class="params">    LPDWORD lpNumberOfBytesWritten,<span class="comment">//值为指向一个DWORD类型的变量，用户返回实际写入的字节数</span></span></span><br><span class="line"><span class="params">    LPOVERLAPPED lpOverlapped <span class="comment">//一般为NULL</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：写文件</p><p>注意：写入的数据通常被Windows暂时保存在内部的高速缓冲区，操作系统会定期进行盘写入，从而避免频繁进行I&#x2F;O操作影响执行效率。</p><p><strong>8.FlushFileBuffers</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">FlushFileBuffers</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hFile <span class="comment">//文件句柄</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：会将指定文件句柄的缓冲区进行清空，使得windows将缓冲区中的文件写入磁盘，保证数据即时写入。</p><p><strong>9.SetFilePointer</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">SetFilePointer</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hFile, <span class="comment">//文件句柄</span></span></span><br><span class="line"><span class="params">    LONG lDistanceToMove, <span class="comment">//指定要移动文件指针的距离</span></span></span><br><span class="line"><span class="params">    PLONG lpDistanceToMoveHigh, <span class="comment">//一个指向LONG型的指针，移动距离的高32位，一般为NULL</span></span></span><br><span class="line"><span class="params">    DWORD dwMoveMethod <span class="comment">//指定移动的起始位置，值有FILE_BEGIN（文件开始位置），FILE_CURRENT（当前文件位置），FILE_END（文件的末尾）</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：设置文件指针</p><p><strong>10.GetLogicalDriveStrings</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetLogicalDriveStrings</span><span class="params">(</span></span><br><span class="line"><span class="params">    DWORD nBufferLength, <span class="comment">//表示lpBuffer的长度</span></span></span><br><span class="line"><span class="params">    LPTSTR lpBuffer <span class="comment">//表示接受本地逻辑驱动器名的缓冲区</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：获取本地所有逻辑驱动器函数的名字。</p><p>注意：返回字符串的形式如：”C:\“,0,”D:\“,0,”E:\“,0,0。</p><p><strong>11.GetDriveType</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UINT <span class="title function_">GetDriveType</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpRootPathName <span class="comment">//要获取逻辑驱动器类型的驱动器名，如：“C: \”。</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：获取驱动器类型。</p><p>注意：函数返回值取以下值之一。</p><table><thead><tr><th>DRIVE_UNKNOWN</th><th>无法识别此驱动器类型</th></tr></thead><tbody><tr><td><strong>DRIVE_NO_ROOT_DIR</strong></td><td><strong>无效的驱动器路径</strong></td></tr><tr><td><strong>DRIVE_REMOVEABLE</strong></td><td><strong>可移动驱动器，如U盘，移动硬盘等</strong></td></tr><tr><td><strong>DRIVE_FIXED</strong></td><td><strong>不可移动驱动器，指硬盘</strong></td></tr><tr><td><strong>DRIVE_REMOTE</strong></td><td><strong>网络驱动器</strong></td></tr><tr><td><strong>DRIVE_CDROM</strong></td><td><strong>光盘驱动器</strong></td></tr><tr><td><strong>DRIVE_RAMDISK</strong></td><td><strong>虚拟驱动器</strong></td></tr></tbody></table><p><strong>12.CreateDirectory</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateDirectory</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpPathName, <span class="comment">//创建目录的目录名称</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpSecurityAttributes <span class="comment">//安全属性，一般设置为NULL</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：创建目录</p><p><strong>13.RemoveDirectory</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">RemoveDirectory</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpPathName <span class="comment">//移除的目录的目录名</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：删除目录</p><p><strong>14.RegOpenKeyEx</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegOpenKeyEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey, <span class="comment">//指定一个父键句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpSubKey, <span class="comment">//指向一个字符串，用来表示要打开的子健名称</span></span></span><br><span class="line"><span class="params">    DWORD ulOptions, <span class="comment">//系统保留，必须指定为0值</span></span></span><br><span class="line"><span class="params">    REGSAM samDesired, <span class="comment">//打开的注册表的存取权限，为了方便对注册表的操作，通常使用KEY_ALL_ACCESS即可</span></span></span><br><span class="line"><span class="params">    PHKEY phkResult <span class="comment">//指向一个双字变量，用来接收打开的子键句柄</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：打开注册表</p><p>注意：实质是打开注册表的某一个子键，然后进行操作</p><p><strong>15.RegCloseKey</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegCloseKey</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey <span class="comment">//注册表句柄</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：关闭释放注册表句柄</p><p><strong>16.RegCreateKeyEx</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegCreateKeyEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey,<span class="comment">//用来指定父键句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpSubKey,<span class="comment">//指向一个字符串，用来表示要创建的子键名称</span></span></span><br><span class="line"><span class="params">    DWORD Reserved,<span class="comment">//系统保留，必须指定为0值</span></span></span><br><span class="line"><span class="params">    LPTSTR lpClass,<span class="comment">//子键类名，一般设置为NULL值</span></span></span><br><span class="line"><span class="params">    DWORD dwOptions,<span class="comment">//创建子键时的选项，通常情况下使用REG_OPTION_NON_VOLATILE宏，表示创建的子键被创建到注册表文件中，而不是内存中</span></span></span><br><span class="line"><span class="params">    REGSAM samDesired,<span class="comment">//打开注册表的存取权限，通常使用KEY_ALL_ACCESS</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpSecurityAttributes,<span class="comment">//指向一个SECURITY_ATTRIBUTES结构体，用来指定键句柄的安全属性，一般使用NULL</span></span></span><br><span class="line"><span class="params">    PHKEY phkResult,<span class="comment">//指向一个双字变量，用来接收打开的子键句柄</span></span></span><br><span class="line"><span class="params">    LPDWORD lpdwDisposition<span class="comment">//一般为NULL</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：创建一个子键<br>注意：若函数执行成功，则返回ERROR_SUCCESS，并且在phkResult中保存创建出的子键的句柄。若子键存在，</p><p><strong>17.RegDeleteKey</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegDeleteKey</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey, <span class="comment">//父键句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpSubKey <span class="comment">//指向要删除的子键名称字符串</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：删除子键<br>注意：能用来删除键值项</p><p><strong>18.RegQueryValueEx</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegQueryValueEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey,<span class="comment">//用来指定要读取的键值项所处的子键句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpValueName,<span class="comment">//用来指定要读取的键值项的名称</span></span></span><br><span class="line"><span class="params">    LPDWORD lpReserved,<span class="comment">//保留参数，必须为NULL值</span></span></span><br><span class="line"><span class="params">    LPDWORD lpType,<span class="comment">//接收返回的键值类型，如果不需要，指定为NULL值</span></span></span><br><span class="line"><span class="params">    LPBYTE lpData,<span class="comment">//指向一个缓冲区，用来接收返回的键值数据</span></span></span><br><span class="line"><span class="params">    LPDWORD lpcbData<span class="comment">//调用时，指定缓冲区的长度。函数返回时，该值被填充为缓冲实际接收到的长度</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：读取键名称中的数据或者查询键名称的属性</p><p><strong>19.RegSetValueEx</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegSetValueEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey,<span class="comment">//指定写入的键值项所处的句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpValueName,<span class="comment">//指向定义键值项名称的字符串</span></span></span><br><span class="line"><span class="params">    DWORD Reserved,<span class="comment">//保留参数，必须为0值</span></span></span><br><span class="line"><span class="params">    DWORD dwType,<span class="comment">//指出要写入的键值数据的类型</span></span></span><br><span class="line"><span class="params">    CONST BYTE *lpData,<span class="comment">//指向要写入键值数据的缓冲区</span></span></span><br><span class="line"><span class="params">    DWORD cbData<span class="comment">//要写入键值数据的缓冲区长度</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：写入键值项。</p><p><strong>20.RegDeleteValue</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegDeleteValue</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey,<span class="comment">//用来指定删除的句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpValueName<span class="comment">//被删除键值项的名称</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：删除键值项。</p><p><strong>21.RegEnumKeyEx</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegEnumKeyEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey,<span class="comment">//指定被枚举的子键句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwIndex,<span class="comment">//指定需要返回信息的子键索引编号</span></span></span><br><span class="line"><span class="params">    LPTSTR lpName,<span class="comment">//用户接收返回子键名称的缓冲区</span></span></span><br><span class="line"><span class="params">    LPDWORD lpcName,<span class="comment">//在调用前，该参数保存lpName指向缓冲区的长度。在调用后，该参数保存缓冲区实际接收到的数据的长度</span></span></span><br><span class="line"><span class="params">    LPDWORD lpReserved,<span class="comment">//保留参数，一般为NULL</span></span></span><br><span class="line"><span class="params">    LPTSTR lpClass,<span class="comment">//一般为NULL</span></span></span><br><span class="line"><span class="params">    LPDWORD lpcClass,<span class="comment">//一般为NULL</span></span></span><br><span class="line"><span class="params">    PFILETIME lpftLastWriteTime<span class="comment">//指向一个FILETIME结构体，用于接收最后一次被写入的时间</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：枚举子键</p><p><strong>22.RegEnumValue</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LONG <span class="title function_">RegEnumValue</span><span class="params">(</span></span><br><span class="line"><span class="params">    HKEY hKey,<span class="comment">//指定被枚举的子键句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwIndex,<span class="comment">//指定需要返回信息的键值索引编号</span></span></span><br><span class="line"><span class="params">    LPTSTR lpValueName,<span class="comment">//用户接收返回键值名称的缓冲区</span></span></span><br><span class="line"><span class="params">    LPDWORD lpcValueName,<span class="comment">//在调用前，该参数保存lpValueName指向缓冲区的长度。在调用后，该参数保存缓冲区实际接收到的数据的长度</span></span></span><br><span class="line"><span class="params">    LPDWORD lpReserved,<span class="comment">//保留参数，必须为NULL</span></span></span><br><span class="line"><span class="params">    LPDWORD lpType,<span class="comment">//指向一个返回键值数据类型的双字变量</span></span></span><br><span class="line"><span class="params">    LPBYTE lpData,<span class="comment">//用户接收返回键值数据的缓冲区</span></span></span><br><span class="line"><span class="params">    LPDWORD lpcbData<span class="comment">//在调用前，该参数保存lpData指向缓冲区的长度。在调用后，该参数保存缓冲区实际接收到的数据的长度</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：枚举键值</p><p><strong>23.OpenSCManager</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">OpenSCManager</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpMachineName,<span class="comment">//指向欲打开服务器控制管理器数据库的目标主机名，本机则设置为NULL</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpDatabaseName,<span class="comment">//指向目标主机SCM数据库名字的字符串</span></span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess<span class="comment">//指定对SCM数据库的访问权限</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：打开服务管理器<br>注意：若调用成功，返回一个SCM句柄，否则返回NULL</p><p><strong>24.CloseServiceHandle</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CloseServiceHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCObject <span class="comment">//使用OpenSCManager()或OpenService()打开的句柄</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：关闭服务管理器</p><p><strong>25.EnumServicesStatus</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">EnumServicesStatus</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCManager,<span class="comment">//OpenSCManager()函数返回的句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwServiceType,<span class="comment">//指定枚举的服务类型，也就是自定义函数的参数</span></span></span><br><span class="line"><span class="params">    DWORD dwServiceState,<span class="comment">//枚举指定状态的服务</span></span></span><br><span class="line"><span class="params">    LPENUM_SERVICE_STATUS lpServices,<span class="comment">//指向ENUM_SERVICE_STATUS类型的指针</span></span></span><br><span class="line"><span class="params">    DWORD cbBufSize,<span class="comment">//指定缓冲区的大小</span></span></span><br><span class="line"><span class="params">    LPDWORD pcbBytesNeeded,<span class="comment">//返回实际使用的内存空间的大小</span></span></span><br><span class="line"><span class="params">    LPDWORD lpServicesReturned,<span class="comment">//返回枚举服务的个数</span></span></span><br><span class="line"><span class="params">    LPDWORD lpResumeHandle<span class="comment">//返回枚举是否成功</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：枚举服务</p><p>注意：ENUM_SERVICE_STATUS结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ENUM_SERVICE_STATUS</span>&#123;</span></span><br><span class="line">    LPTSTR lpServiceName;</span><br><span class="line">    LPTSTR lpDisplayName;</span><br><span class="line">    SERVICE_STATUS ServiceStatus;</span><br><span class="line">&#125;ENUM_SERVICE_STATUS,*LPENUM_SERVICE_STATUS</span><br></pre></td></tr></table></figure><p>SERVICE_STATUS结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SERVICE_STATUS</span> &#123;</span></span><br><span class="line">    DWORD dwServiceType;</span><br><span class="line">    DWORD dwCurrentState;</span><br><span class="line">    DWORD dwControlsAccepted;</span><br><span class="line">    DWORD dwWin32ExitCode;</span><br><span class="line">    DWORD dwServiceSpecificExitCode;</span><br><span class="line">    DWORD dwCheckPoint;</span><br><span class="line">    DWORD dwWaitHint;</span><br><span class="line">&#125;SERVICE_STATUS,*LPSERVICE_STATUS;</span><br></pre></td></tr></table></figure><p><strong>26.OpenService</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE <span class="title function_">OpenService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hSCManager,<span class="comment">//指定由OpenSCManager()函数打开的服务句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpServiceName,<span class="comment">//指定要打开的服务的名称</span></span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess<span class="comment">//对要打开的服务的访问权限</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：打开指定服务</p><p><strong>27.StartService</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">StartService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hService,<span class="comment">//指定要启动服务的句柄，由OpenService()返回</span></span></span><br><span class="line"><span class="params">    DWORD dwNumServiceArgs,<span class="comment">//指向启动服务所需的参数个数</span></span></span><br><span class="line"><span class="params">    LPCTSTR *lpServiceArgVectors<span class="comment">//指向启动服务的参数</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：启动服务</p><p><strong>28.ControlService</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ControlService</span><span class="params">(</span></span><br><span class="line"><span class="params">    SC_HANDLE hService,<span class="comment">//指定一个由OpenService()打开的服务句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwControl,<span class="comment">//指定要发送的控制码，停止服务为SERVICE_CONTROL_STOP</span></span></span><br><span class="line"><span class="params">    LPSERVICE_STATUS lpServiceStatus<span class="comment">//返回服务的状态</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：控制服务</p><p><strong>29.WinExec</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UINT <span class="title function_">WinExec</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpCmdLine,<span class="comment">//指向一个要执行的可执行文件的字符串，比如&quot;C:\Windows\System32\Notepad.exe&quot;</span></span></span><br><span class="line"><span class="params">    UINT uCmdShow<span class="comment">//程序运行后的窗口状态，两个值SW_HIDE和SW_SHOW</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：执行某个可执行文件</p><p><strong>30.URLDownloadToFile</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HRESULT <span class="title function_">URLDownloadToFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPUNKNOWN pCaller,</span></span><br><span class="line"><span class="params">    LPCTSTR szURL, <span class="comment">//指向下载地址的URL的字符串</span></span></span><br><span class="line"><span class="params">    LPCTSTR szFileName,<span class="comment">//指向要保存到本地位置的字符串</span></span></span><br><span class="line"><span class="params">    DWORD dwReserved,</span></span><br><span class="line"><span class="params">    LPBINDSTATUSCALLBACK lpfnCB</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：从网络上某个地址下载程序</p><p><strong>31.CreateProcess</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpApplicationName,<span class="comment">//指定可执行文件的文件名</span></span></span><br><span class="line"><span class="params">    LPTSTR lpCommandLine,<span class="comment">//指定欲传送给新进程的命令行的参数</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//进程安全属性，一般为NULL</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//进程安全属性，一般为NULL</span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandles,<span class="comment">//指定当前进程中的可继承句柄是否被新进程继承</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags,<span class="comment">//指定新进程的优先级以及其他创建标志，如果是一个被调试进程的话，值为DEBUG_PROCESS,如果不希望子进程创建的“孙”进程也处在被调试状态，那么在父进程创建子进程时传递DEBUG_ONLY_THIS_PROCESS，如果希望被创建子进程的主线程暂时不要进行，那么可以指定CREATE_SUSPENDED</span></span></span><br><span class="line"><span class="params">    LPVOID lpEnvironment,<span class="comment">//指定新进程的环境变量，通常为NULL</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpCurrentDirectory,<span class="comment">//指定新进程使用的当前目录</span></span></span><br><span class="line"><span class="params">    LPSTARTUPINFO lpStartupInfo,<span class="comment">//指向STARTUOINFO结构体的指针</span></span></span><br><span class="line"><span class="params">    LPPROCESS_INFORMATION lpProcessInformation<span class="comment">//指向PROCESS_INFORMATION结构体的指针</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：创建一个进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFO</span>&#123;</span></span><br><span class="line">    DWORD cb;</span><br><span class="line">    LPTSTR lpReserved;</span><br><span class="line">    LPTSTR lpDesktop;</span><br><span class="line">    LPTSTR lpTitle;</span><br><span class="line">    DWORD dwX;</span><br><span class="line">    DWORD dwY;</span><br><span class="line">    DWORD dwXSize;</span><br><span class="line">    DWORD dwYSize;</span><br><span class="line">    DWORD dwXCountChars;</span><br><span class="line">    DWORD dwYCountChars;</span><br><span class="line">    DWORD dwFillAttribute;</span><br><span class="line">    DWORD dwFlags;</span><br><span class="line">    WORD wShowWindow;</span><br><span class="line">    WORD cbReserved2;</span><br><span class="line">    LPBYTE lpReserved2;</span><br><span class="line">    HANDLE hStdInput;</span><br><span class="line">    HANDLE hStdOutput;</span><br><span class="line">    HANDLE hStdError</span><br><span class="line">&#125;STARTUPINFO,*LPSTARTUPINFO;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span>&#123;</span></span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwProcessId;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">&#125;PROCESS_INFORMATION;</span><br></pre></td></tr></table></figure><p><strong>32.GetWindowThreadProcessId</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetWindowThreadProcessId</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd,<span class="comment">//窗口句柄，由FindWindow()函数获取</span></span></span><br><span class="line"><span class="params">    LPDWORD lpdwProcessId<span class="comment">//一个指向DWORD类型的指针，用户返回窗口句柄所对应的进程</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：得到进程ID</p><p><strong>33.OpenProcess</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">OpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess,<span class="comment">//打开进程欲获得的访问权限，为了方便可设置为PROCESS_ALL_ACCESS</span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandle,<span class="comment">//指定获取的句柄是否可以继承</span></span></span><br><span class="line"><span class="params">    DWORD dwProcessId<span class="comment">//指定欲打开的进程ID号</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：打开进程</p><p><strong>34.TerminateProcess</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">TerminateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hProcess,<span class="comment">//欲结束进程的进程句柄</span></span></span><br><span class="line"><span class="params">    UINT uExitCode<span class="comment">//进程的退出码，通常为0值</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：终止进程</p><p><strong>35.CreateToolhelp32Snapshot</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateToolhelp32Snapshot</span><span class="params">(</span></span><br><span class="line"><span class="params">    DWORD dwFlags,<span class="comment">//指明要建立系统快照的类型。</span></span></span><br><span class="line"><span class="params">    DWORD th32ProcessID<span class="comment">//根据dwFlags参数的不同而不同。如果dwFlags为TH32CS_SNAPPROCESS或TH32CS_SNAPTHREAD，则该参数为NULL，如果是TH32CS_SNAPMODULE，那么该参数是进程ID</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：创建指定的相关快照</p><p><strong>36.Process32First</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">Process32First</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hSnapshot,<span class="comment">//为CreateToolhelp32Snapshot()返回的句柄</span></span></span><br><span class="line"><span class="params">    LPPROCESSENTRY32 lppe<span class="comment">//指向PROCESSENTRY32结构体的指针</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：获取第一个进程</p><p><strong>37.Process32Next</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">Process32Next</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hSnapshot,</span></span><br><span class="line"><span class="params">    LPPROCESSENTRY32 lppe</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：获取下一个进程</p><p><strong>38.SuspendThread</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">SuspendThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hThread<span class="comment">//使用OpenThread()函数获取的句柄</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：暂停线程</p><p><strong>39.OpenThread</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">OpenThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    DWORD dwDesiredAccess,<span class="comment">//对获取的线程句柄的操作权限</span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandle,<span class="comment">//是否可继承</span></span></span><br><span class="line"><span class="params">    DWORD dwThreadId<span class="comment">//线程id</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：返回指定线程id的线程句柄</p><p><strong>40.ResumeThread</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">ResumeThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hThread <span class="comment">//使用OpenThread()函数获取的句柄</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：恢复被暂停的线程</p><p><strong>41.CreateThread</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//安全属性</span></span></span><br><span class="line"><span class="params">    DWORD dwStackSize,<span class="comment">//指定线程使用缺省的堆栈大小，如果为NULL，则与进程主线程栈相同</span></span></span><br><span class="line"><span class="params">    LPTHREAD_START_ROUTINE lpStartAddress,<span class="comment">//指定开始地址，开始地址为线程函数入口地址</span></span></span><br><span class="line"><span class="params">    LPVOID lpParameter,<span class="comment">//表示传递给线程函数的第一个参数</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags,<span class="comment">//指明创建线程后的线程状态，创建后立即执行，值为0，创建后处于暂停状态，设置为CREATE_SUSPENDED</span></span></span><br><span class="line"><span class="params">    LPDWORD lpThreadId<span class="comment">//返回新创建的线程ID</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：创建线程</p><p><strong>42.WaitForSingleObject</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">WaitForSingleObject</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hHandle,<span class="comment">//要等待的对象句柄</span></span></span><br><span class="line"><span class="params">    DWORD dwMilliseconds<span class="comment">//设为0，立即返回。设为INFINITE，则表示一直等待线程的返回</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：主线程等待一个新线程的完成才得以进行</p><p><strong>43.WaitForMultipleObjects</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">WaitForMultipleObjects</span><span class="params">(</span></span><br><span class="line"><span class="params">    DWORD nCount,<span class="comment">//要让函数等待线程的数量</span></span></span><br><span class="line"><span class="params">    CONST HANDLE *lpHandles,<span class="comment">//线程句柄的数组指针</span></span></span><br><span class="line"><span class="params">    BOOL fWaitAll,<span class="comment">//是否等待全部线程的状态完成。</span></span></span><br><span class="line"><span class="params">    DWORD dwMilliseconds<span class="comment">//设为0，立即返回。设为INFINITE，则表示一直等待线程的返回</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：主线程等待多个新线程的完成才得以进行</p><p><strong>44.DllMain</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(</span></span><br><span class="line"><span class="params">    HINSTANCE hinstDLL,<span class="comment">//当前DLL模块的句柄</span></span></span><br><span class="line"><span class="params">    DWORD fdwReason,<span class="comment">//被调用的原因</span></span></span><br><span class="line"><span class="params">    LPVOID lpvReserved<span class="comment">//保留参数</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：DLL文件入口函数</p><p><strong>45.WriteProcessMemory</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hProcess, <span class="comment">//指定进程的进程句柄</span></span></span><br><span class="line"><span class="params">    LPVOID lpBaseAddress, <span class="comment">//指定写入目标进程内存的起始位置</span></span></span><br><span class="line"><span class="params">    LPVOID lpBuffer,<span class="comment">//写入目标进程内存的缓冲区</span></span></span><br><span class="line"><span class="params">    DWORD nSize, <span class="comment">//指定缓冲区的长度</span></span></span><br><span class="line"><span class="params">    LPDWORD lpNumverOfBytesWritten <span class="comment">//用于接收实际写入内容的长度</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：把缓冲区的内容写入目标进程的内存的起始地址</p><p><strong>46.VirtualAllocxEx</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID <span class="title function_">VirtualAllocxEx</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hProcess,<span class="comment">//指定进程的进程句柄</span></span></span><br><span class="line"><span class="params">    LPVOID lpAddress,<span class="comment">//在目标进程中申请内存的起始地址</span></span></span><br><span class="line"><span class="params">    SIZE_T dwSize,<span class="comment">//申请内存的长度</span></span></span><br><span class="line"><span class="params">    DWORD flAllocationType,<span class="comment">//申请内存的状态类型</span></span></span><br><span class="line"><span class="params">    DWORD flProtect<span class="comment">//申请内存的属性</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：在目标进程中申请内存<br>注意：返回在目标进程中申请到的内存的起始地址</p><p><strong>47.FreeLibrary</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">FreeLibrary</span><span class="params">(</span></span><br><span class="line"><span class="params">    HMODULE hModule <span class="comment">//要卸载的模块的句柄</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：卸载DLL</p><p><strong>48.QueueUserAPC</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">QueueUserAPC</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PAPCFUNC pfnAPC,<span class="comment">//指向一个APC函数的地址</span></span></span><br><span class="line"><span class="params">    _In_ HANDLE hThread,<span class="comment">//指向目标线程的句柄</span></span></span><br><span class="line"><span class="params">    _In_ ULONG_PTR dwData<span class="comment">//传递给pfnAPC指向函数的参数</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>功能：在APC链中增加一个APC（Asynchronous Procedure Call，异步进程调用）</p><p><strong>49.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**41.**<strong>40.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**41.**<strong>40.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**41.**<strong>40.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**41.**<strong>40.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**41.**<strong>40.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**41.**<strong>40.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**41.**<strong>40.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>**41.**<strong>40.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>41.</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="stdcall、-cdcel和-fastcall三者的区别"><a href="#stdcall、-cdcel和-fastcall三者的区别" class="headerlink" title="__stdcall、__cdcel和__fastcall三者的区别"></a>__stdcall、__cdcel和__fastcall三者的区别</h2><ol><li>调用协议常用场合</li><li><ol><li>__stdcall：Windows API默认的函数调用协议。</li><li>__cdecl：C&#x2F;C++默认的函数调用协议。</li><li>__fastcall：适用于对性能要求较高的场合。</li></ol></li><li>函数参数入栈方式</li><li><ol><li><strong>__stdcall：函数参数由右向左入栈。</strong></li><li><strong>__cdecl：函数参数由右向左入栈。</strong></li><li><strong>__fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。</strong></li><li>问题一：__fastcall在寄存器中放入不大于4字节的参数，故性能较高，适用于需要高性能的场合。</li></ol></li><li>栈内数据清除方式</li><li><ol><li><strong>__stdcall：函数调用结束后由被调用函数清除栈内数据。</strong></li><li><strong>__cdecl：函数调用结束后由函数调用者清除栈内数据。</strong></li><li><strong>__fastcall：函数调用结束后由被调用函数清除栈内数据。</strong></li><li>问题一：不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。</li><li>问题二：某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。</li><li>问题三：由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。</li></ol></li><li>C语言编译器函数名称修饰规则</li><li><ol><li>__stdcall：编译后，函数名被修饰为“_functionname@number”。</li><li>__cdecl：编译后，函数名被修饰为“_functionname”。</li><li>__fastcall：编译后，函数名给修饰为“@functionname@nmuber”。</li><li>注：“functionname”为函数名，“number”为参数字节数。</li><li>注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。</li></ol></li><li>C++语言编译器函数名称修饰规则</li><li><ol><li>__stdcall：编译后，函数名被修饰为“?functionname@@YG******@Z”。</li><li>__cdecl：编译后，函数名被修饰为“?functionname@@YA******@Z”。</li><li>__fastcall：编译后，函数名被修饰为“?functionname@@YI******@Z”。</li><li>注：“******”为函数返回值类型和参数类型表。</li><li>注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。</li><li>C语言和C++语言间如果不进行特殊处理，也无法实现函数的互相调用。</li></ol></li></ol><p>__int8、__int16、__int32和__int64<br>unsigned __int8、unsigned __int16、unsigned __int32和unsigned __int64<br>都是微软的VC自己定义的数据类型，因为不同编译环境中int、long和short的值会和具体字长有关，尤其是int的具体长度更是没有定义，为了方便移植，所以定义了固定长度的整型</p><p>GDB（GNU Debugger）</p><h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p><strong>加密算法：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjM3MDkwLTYzMWU1ZTJlOGUzYTBmOTQucG5n?x-oss-process=image/format,png" alt="img"></p><p>图中的C是密文，M是明文，E是公钥（E和 φ(N)互为质数），N是公共模数（质数 P 、Q相乘得到N），MOD就是模运算</p><p><strong>解密算法：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjM3MDkwLWJkM2Y5ZjdiNDQ5ODNlODUucG5n?x-oss-process=image/format,png" alt="img"></p><p>图中的C是密文，M是明文，D是私钥（私钥由这个公式计算得出E * D % φ(N) &#x3D; 1），N是公共模数（质数 P 、Q相乘得到N），MOD就是模运算，φ(N)是欧拉函数（由这个公式计算得出φ(N) &#x3D; (P-1)(Q-1)）。</p><p>（a+b）%c&#x3D;（a%c+b%c）%c</p><p>a&#x3D;（b+c）%d<br>b&#x3D;（a-c）%d</p><p><strong>公钥N &#x3D; P * Q，其中P和Q是两个大素数</strong></p><p><strong>D是随机选择的数，作为公钥</strong></p><p><strong>D是跟E有关的一个数，E是私钥，满足条件式：ED&#x3D;1（mod phi（N））</strong></p><p><strong>phi（n）是欧拉函数，phi（n）&#x3D;（p-1）（q-1）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"></span><br><span class="line">e= <span class="number">65537</span></span><br><span class="line">n= <span class="number">86934482296048119190666062003494800588905656017203025617216654058378322103517</span></span><br><span class="line">p= <span class="number">285960468890451637935629440372639283459</span></span><br><span class="line">q= <span class="number">304008741604601924494328155975272418463</span></span><br><span class="line">d= <span class="number">81176168860169991027846870170527607562179635470395365333547868786951080991441</span>//私钥</span><br><span class="line"></span><br><span class="line">key = rsa.PrivateKey(n,e,d,q,p)         <span class="comment">#在pkcs标准中,pkcs#1规定,私钥包含(n,e,d,p,q)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;D:\\ctfbisai\\buumima\\0eaf8d6c-3fe5-4549-9e81-94ac42535e7b\\flagenc.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  <span class="comment">#以二进制读模式，读取密文</span></span><br><span class="line">    f = f.read()</span><br><span class="line">    <span class="built_in">print</span>(rsa.decrypt(f,key))           <span class="comment"># f:公钥加密结果  key:私钥</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">86934482296048119190666062003494800588905656017203025617216654058378322103517</span></span><br><span class="line">p = <span class="number">285960468890451637935629440372639283459</span></span><br><span class="line">q = <span class="number">304008741604601924494328155975272418463</span></span><br><span class="line"></span><br><span class="line">phin = (q-<span class="number">1</span>)*(p-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phin)</span><br><span class="line"></span><br><span class="line">key = rsa.PrivateKey(n, e, <span class="built_in">int</span>(d), p, q)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\10245\\Desktop\\output\\flag.enc&quot;</span>, <span class="string">&quot;rb+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f = f.read()</span><br><span class="line">    <span class="built_in">print</span>(rsa.decrypt(f, key))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"> </span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">c = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line">n = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = gmpy2.powmod(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]).decode(encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">//m转化成<span class="number">16</span>进制序列后再转化成字符串</span><br></pre></td></tr></table></figure><p><strong>压缩壳找到程序入口点</strong></p><p>首先压缩壳会保护寄存器的值，这些寄存器的值是程序被装载进内存由操作系统填充的，一般压缩壳程序会pushad，将寄存器的值一次性压入栈中，此时我们可以在栈顶[esp]设置硬件断点，当使用popad指令弹栈的时候会中断，此时就是pop指令所在的子程序就是程序入口点。</p><p><strong>找main函数</strong></p><ul><li><strong>main()函数经常在可执行文件的靠前位置</strong></li><li><strong>VC的入口点（IDA中的Start()函数）会直接调用main()函数，在start()函数中被调用的函数（main()函数）有3个参数，并且返回值被传入exit()函数</strong></li><li><strong>GCC将main()函数的地址传入__libc_start_main来调用main()函数，查看__libc_start_main函数的参数就可找到main()函数的地址</strong></li></ul><h3 id="特征值识别"><a href="#特征值识别" class="headerlink" title="特征值识别"></a>特征值识别</h3><table><thead><tr><th>算法</th><th>特征值</th><th>备注</th></tr></thead><tbody><tr><td>TEA</td><td>9e3779b9</td><td>Delta值</td></tr><tr><td>AES</td><td>63 7c 77 7b f2 6b 6f c5…<br />52 09 6a d5 30 36 a5 38…</td><td>S盒<br />逆S盒</td></tr><tr><td>DES</td><td>3a 32 2a 22 1a 12 0a 02…<br />39 31 29 21 19 11 09 01…<br />0e 11 0b 18 01 05 03 1c…<br />0e 04 0d 01 02 0f 0b 08…</td><td>置换表<br />密钥变换数组PC-1<br />密钥变换数组PC-2<br />S函数表格1</td></tr><tr><td>BlowFish</td><td>243f6a88 85a308d3 13198a2e 03707344</td><td>P数组</td></tr><tr><td>MD5</td><td>67452301 efcdab89 98badcfe 10325476<br />d76aa478 e8c7b756 242070db c1bdceee…</td><td>寄存器初始值<br />Ti数组常量</td></tr><tr><td>SHA1</td><td>67452301 efcdab89 98badcfe 10325476 c3d2e1f0</td><td>寄存器初始值</td></tr><tr><td>CRC32</td><td>00000000 77073096 ee0e612c 990951ba</td><td>CRC表</td></tr><tr><td>Base64</td><td>字符串”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;“</td><td>字符集</td></tr></tbody></table><h3 id="特征运算识别"><a href="#特征运算识别" class="headerlink" title="特征运算识别"></a>特征运算识别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RC4算法</span></span><br><span class="line">i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">swap(s[i],s[j]);</span><br><span class="line">t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line"><span class="comment">//说明；流密钥生成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">swap(s[i],s[j]);</span><br><span class="line"><span class="comment">//循环256次</span></span><br><span class="line"><span class="comment">//说明；S盒变换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Base64</span></span><br><span class="line">b1=c1&gt;&gt;<span class="number">2</span>;</span><br><span class="line">b2=((c1&amp;<span class="number">0x3</span>)&lt;&lt;<span class="number">4</span>)|(c2&gt;&gt;<span class="number">4</span>);</span><br><span class="line">b3=((c2&amp;<span class="number">0xF</span>)&lt;&lt;<span class="number">2</span>)|(c3&gt;&gt;<span class="number">6</span>);</span><br><span class="line">b4=c3&amp;<span class="number">0x3F</span>;</span><br><span class="line"><span class="comment">//说明；8位变6位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TEA系列</span></span><br><span class="line">((x&lt;&lt;<span class="number">4</span>)+kx)^(y+sum)^((y&gt;&gt;<span class="number">5</span>)+ky)</span><br><span class="line"><span class="comment">//说明；轮函数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//MD5</span></span><br><span class="line">(X&amp;Y)|((~X)&amp;Z)<span class="comment">//说明；F函数</span></span><br><span class="line">(X&amp;Z)|(Y&amp;(~Z))<span class="comment">//说明；G函数</span></span><br><span class="line">X^Y^Z         <span class="comment">//说明；H函数</span></span><br><span class="line">Y^(X|(~Z))    <span class="comment">//说明；I函数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//AES</span></span><br><span class="line">x[j]=s[i][(j+i)%<span class="number">4</span>]</span><br><span class="line"><span class="comment">//循环四次</span></span><br><span class="line">s[i][j]=x[j]</span><br><span class="line"><span class="comment">//循环四次</span></span><br><span class="line"><span class="comment">//整体循环四次</span></span><br><span class="line"><span class="comment">//说明；行位移</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//DES</span></span><br><span class="line">L=R</span><br><span class="line">R=F(R,K)^L</span><br><span class="line"><span class="comment">//说明：Feistel结构</span></span><br></pre></td></tr></table></figure><h3 id="CTF逆向常见题型"><a href="#CTF逆向常见题型" class="headerlink" title="CTF逆向常见题型"></a><strong>CTF逆向常见题型</strong></h3><p>​    PWN和MISC中的某些涉及到一些逆向知识的题目就先不提了，就谈在CTF中最常见的逆向题吧。</p><p>   其实CTF逆向题无论是哪种语言（python、CC+、java等），哪个平台（Windows、Linux、Android等）都离不开这两大项：</p><p><strong>1、 暴力破解：</strong>逆向中的暴力破解和web中的爆破还不一样，这里的暴力破解主要是通过修改汇编代码来跳过程序验证部分（俗称打补丁）的形式来过掉程序的最终校验，进而满足题目要求来获取flag，此类题目比较考验选手查找程序中验证代码的能力。</p><p><strong>2、 算法破解：</strong>这类题目通常需要逆向分析其程序加密部分汇编代码，然后还原其加密算法实现过程，然后根据分析结果编写出对应的解密程序，进而算出flag，此类题目比较考验选手的耐心和细心程度，不仅需要选手有扎实的逆向功底，还需要选手具备一定的编程能力。</p><h3 id="常见CTF逆向题解题流程"><a href="#常见CTF逆向题解题流程" class="headerlink" title="常见CTF逆向题解题流程"></a><strong>常见CTF逆向题解题流程</strong></h3><p><strong>1、 突破保护：</strong>拿到程序时先查看程序属于哪平台下的，例如windows X86&#x2F;X64、android、linux等，有没有设置保护措施，例如：代码混淆（代码混淆(Obfuscated code)亦称花指令，是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。 代码混淆可以用于程序源代码，也可以用于程序编译而成的中间代码。 执行代码混淆的程序被称作代码混淆器。 已经存在许多种功能各异的代码混淆器。）、保护壳、各种反调试等，如果有则通过去混淆、脱壳、反反调试等技术来去除或绕过这些保护措施。</p><p><strong>2、 定位关键代码：</strong>我们需要将目标软件进行反汇编，然后结合IDA和OD快速定位到关键代码（例如验证函数）。</p><p><strong>3、 动静结合：</strong>我们找到程序的关键代码之后就要对其进行详细的逆向分析了，如果程序在IDA中F5可以生成伪代码，那么我们就先根据伪代码进行静态分析，然后模糊不清的地方可以结合OD进行动态调试观察来验证自己的猜想。</p><p><strong>4、 破解验证算法：</strong>我们详细分析完程序的关键代码（例如：验证算法）之后，我们就要根据我们分析出的结果来进行暴力破解或者进行代码的编写，对算法进行破解来编写逆算法生成flag。</p><p>常见的验证算法通常有以下几种（以下为还原后的源码展示，比赛中肯定不会给你源码）：</p><ol><li>直接比较验证：密钥一般没有经过加密，直接跟内置的key进行比较，此类题型比较简单。</li></ol><p><img src="https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-124037-1582790647.jpeg" alt="img">      图 1 直接比较验证源码示例</p><ol start="2"><li>加密比较验证：密钥一般进行了例如异或、base64、MD5、RC4等形式的加密，此类题型需要识别出其加密方式，然后再根据其算法特点还原出相应的key，幸运的是比赛中的加密方式有限，自己可以针对练习，但是现实竞赛中也有可能出现密钥用不同加密算法分段加密或嵌套验证等多种加密组合起来的方式，也需要自己去分辨。</li></ol><p><img src="https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-124037-15827906471.jpeg" alt="img">           <strong>图 2 加密比较验证源码示例</strong></p><ol start="3"><li>逆向自己实现的算法：这类题目就需要选手自己去逆向题目作者自己编写的算法了，例如下图的迷宫问题题目，选手需要识别出其是迷宫问题题目然后分析出其每个函数代表什么操作来进一步解题，需要逆向算法的题目一般都比较难，需要理清算法实现思路，跟踪自己输入的数据使用算法进行了哪些处理，最后变成了什么和什么比较，需要有一定的耐心和细心，建议多加练习。</li></ol><p><img src="https://secpulseoss.oss-cn-shanghai.aliyuncs.com/wp-content/uploads/1970/01/beepress-image-124037-15827906472.jpeg" alt="img">             <strong>图3 算法逆向源码示例</strong></p><ol start="4"><li>其他类型的加密题目：实在解不出来的，也可以看其是否可以<strong>绕过或暴力破解穷举</strong>等。</li></ol><p><strong>如果给你一个程序需要你找到他验证部分的代码，那么你如何查找呢？这里给大家总结了几个常用的方法</strong>：</p><ol><li><p><strong>顺序跟踪</strong>：如果大家拿到的程序较小，代码量不多且主函数入口好找，即可使用顺序跟踪法，从程序主函数入口顺序跟踪，一步步看完整个程序的执行过程，基本就知道程序的验证部分了，至于各个类型程序主函数的查找方法大家可以自行百度，这里还需要分清楚程序入口点和main函数的区别，大家一般需要找main函数，但也不全是找main函数，如果遇到了MFC的程序大家还需要根据具体情况具体分析，如果有条件大家也可以自己编写相应程序然后反汇编来练习查找程序的主函数，这个需要大家平时多练习、多积累、多总结。</p></li><li><p><strong>字符串查找</strong>：如果给定的程序没有做混淆处理而且还有比较明显的字符串提示，那么我们就可以根据程序运行的提示使用字符串查找功能查找程序所提示字符串的方式来反向查找其被引用的地址，例如IDA中shift+F12的字符串窗口，OD中查找-&gt;所有参考文本字串，字符串搜索的优先级很高，很多情况下对我们解题有奇效，所以拿到程序后可以优先尝试。</p></li><li><p><strong>API断点</strong>：如果程序非常大而且也没有啥字符串提示信息可以利用，那么我们就可以根据程序所使用的API来定位关键验证代码，这需要大家掌握C语言还有windows核心编程的知识，熟悉哪些API具有哪些功能，例如：程序出现了一个弹窗，那么程序就有可能调用了Messagebox这个API，如果程序出现了输出，那么程序就有可能调用了printf这个API等等，所以我们可以通过程序所表现出的状态来下相应的API断点，然后栈回溯反向查找其引用位置，进而找到关键代码。</p></li></ol><h3 id="逆向进阶"><a href="#逆向进阶" class="headerlink" title="逆向进阶"></a><strong>逆向进阶</strong></h3><p>​    其实逆向总结起来就一句话：入门难、进阶难、精通更难。所以说我们入门了逆向之后还需要进阶一下，下面来介绍一下逆向进阶所需要攻克的难点：</p><p><strong>1． 绕过软件保护：</strong>例如windows程序常见的加壳（大部分是压缩壳和简单的加密壳，一般不会出很难的加密壳或者虚拟机壳这种强壳因为这种壳都不是短时间内能够脱掉的）、混淆（对反汇编代码进行变形使人难以逆向）、花指令（添加无用代码或函数浪费逆向者时间，摧毁其心态）、反调试（检测调试状态、检测调试器、检测断点、检测跟踪、检测补丁等）、反虚拟机等。我们要克服软件保护这个难点的话需要熟悉操作系统调试相关的知识，推荐大家一本<strong>张银奎的《软件调试》</strong>这本书，只需要膜拜就完事了哦，我们还需要对我们日常遇到的软件保护手段多做总结，因为招式是有限的，我们总结的多了也就会见招拆招了。</p><p><strong>2． 理解各种目标程序的特性：</strong></p><p>指令集：x86、x64、arm、arm64等；</p><p>平台：Windows、Linux、Android、ios等；</p><p>语言：C、C++、Java、Python、C#、VB、.Net、易语言等；</p><p>编译器：VS、GCC、VC、易语言等；</p><p>库与框架：MFC、QT、STL、易语言库等；</p><p>要想克服语言难点，我们除了需要了解各个语言的语言特性、运行、开发环境等，达到可以进行一定的正向开发的程度之外，我们还需要根据目标程序所用语言找到其专用的反编译工具（可以从githubgoogle上找），比如android程序所用到的的androidkiller，python程序的EasyPythonDecompiler、MFC程序的xspy、C#的ILspy等，这些工具有时都可以直接把源程序反编译成近乎源码形式，让我们解题事半功倍，除了这些特定语言程序之外，剩下的常规的程序一般都是IDA静态分析和OD动态调试结合分析。</p><p><strong>3.   理解各种算法：</strong>大家还需要一些算法的功底，因为有时候出题使用的算法和公开的算法会有一些区别，比如进行了简单的修改或者变形，用通用的解密方法解密不了，这时候就需要自己编写解密脚本来进行解密，所以大家还需要对算法有一定研究。想要克服算法难点的话需要大家了解常见的数据结构和算法实现，多在ACM平台练练题等。</p><h2 id="二进制代码保护和混淆"><a href="#二进制代码保护和混淆" class="headerlink" title="二进制代码保护和混淆"></a>二进制代码保护和混淆</h2><p>干扰反汇编器最简单的方法就是在代码中增加花指令。<br>花指令，是指在程序中完全冗余，不影响程序功能却会对逆向工程产生干扰的指令。花指令没有固定的形式，泛指用于干扰逆向工作的无用指令。</p><ul><li>插入一些无用代码，干扰反汇编器的判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//比如反汇编器判断函数</span><br><span class="line">push ebp</span><br><span class="line">mov  ebp,esp</span><br><span class="line">sub  esp,0x100</span><br><span class="line"></span><br><span class="line">//加入一些无用指令干扰汇编器判断函数,pushfd和popfd等指令会让一些解析栈指针的逆向工具产生错误</span><br><span class="line">push ebp</span><br><span class="line">pushfd</span><br><span class="line">add esp,0xd</span><br><span class="line">nop</span><br><span class="line">sub esp,0xd</span><br><span class="line">popfd</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><ul><li>正常的指令中插入一个特定的字节（比如 0x8E，为call指令的操作码），这个字节被称为<strong>脏字节</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push ebp                 </span><br><span class="line">jmp  addr1        //动态反汇编器采用线性扫描反汇编算法，从开始逐个向下进行扫描，</span><br><span class="line">                  //静态反汇编器采用递归下降反汇编算法，递归下降反汇编算法在遇到无条件跳转时（比如jmp），</span><br><span class="line">                  //会转向跳转的目标地址递归地继续解析指令，而jmp指令后的直接被跳过</span><br><span class="line">db 0xE8           //在遇到这个字节，动态反汇编器会解析为Call指令，导致后面的指令报废</span><br><span class="line">addr1:</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jz   addr1        //然而，递归下降反汇编算法并不是真正运行，所以不能获取到信息。</span><br><span class="line">jnz  addr1        //所以它不能获取到程序运行时的上下文信息（比如在这反汇编器不知道ZF标志寄存器的值）</span><br><span class="line">                  //递归下降反汇编算法遇到条件跳转语句时，它会递归地将跳转的分支与不跳转的分支都进行反汇编</span><br><span class="line">db   0xE8</span><br><span class="line">addr1:</span><br><span class="line">mov  ebp,esp</span><br><span class="line">sub  esp,0x100</span><br></pre></td></tr></table></figure><p>实际操作中，往往会将控制流混淆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">jz addr2</span><br><span class="line">jnz addr2  //递归下降反汇编算法将db 0xE8解析并将addr2地址处的指令解析</span><br><span class="line">db 0xE8</span><br><span class="line">addr3:</span><br><span class="line">sub esp,0x100</span><br><span class="line">...</span><br><span class="line">addr2:</span><br><span class="line">mov ebp,esp</span><br><span class="line">jmp addr3  //无条件跳转到被污染了而无法正确解析的addr3，导致程序错误</span><br></pre></td></tr></table></figure><ul><li>指令替换，又称为“变形”。在汇编中，大量的指令都可以设法使用其他指令来实现相同或者类似的功能。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call addr </span><br></pre></td></tr></table></figure><p>可替换成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push addr</span><br><span class="line">ret //弹出栈顶返回地址给EIP</span><br></pre></td></tr></table></figure><p>ret也可以替换成以下代码段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ecx      </span><br><span class="line">mov  ecx,[esp+4] //弹出栈顶返回地址给ecx</span><br><span class="line">add  esp,8</span><br><span class="line">jmp  ecx</span><br></pre></td></tr></table></figure><p><strong>出题人通常选择替换涉及函数调用与返回的指令，从而导致IDA Pro等工具解析出的函数地址范围与调用关系出错，从而干扰静态分析。</strong></p><ul><li>代码自修改（Self-Modifying Code,SMC），意思就是给到一个程序，这个程序是加密过的，程序运行时会对自己进行修改从而解密，然后开始执行真正的程序。所以静态分析中看不到原本的程序，只能看到加密了的程序，源代码在静态分析中不会出现。待SMC的代码在IDA等工具中会被识别为数据，但会出现将该数据地址当作函数指针并进行函数调用的操作。</li></ul><p><strong>解决办法就是：将待SMC的代码进行理解，看看修改了什么，然后自己实现这个SMC过程，还原出真正的代码。第二个办法就是使用动态分析，在解密完毕的位置设置断点，然后dump已经解密完毕后的代码，交给IDA进行静态分析</strong></p><h3 id="简单CrackMe破解"><a href="#简单CrackMe破解" class="headerlink" title="简单CrackMe破解"></a>简单CrackMe破解</h3><ul><li>找比较函数，比如strcmp()函数等下断点，然后执行程序，查看堆栈，可以看到正确的密码</li><li>修改比较条件，同样也是在比较函数下，找到跳转语句，修改跳转语句的条件，比如jnz改成jz</li></ul><h3 id="发布补丁的三种情况"><a href="#发布补丁的三种情况" class="headerlink" title="发布补丁的三种情况"></a>发布补丁的三种情况</h3><ol><li>直接将修改后的程序发布出去</li><li>发布一个文件补丁，它去修改原始的待破解的程序</li><li>发布一个内存补丁，它不修改原始的文件，而是修改内存中的指定部分</li></ol><h3 id="断点的三种类型"><a href="#断点的三种类型" class="headerlink" title="断点的三种类型"></a>断点的三种类型</h3><ol><li>INT3断点，通过汇编指令中的int3指令设置断点，调试器通过将被调试程序的想被中断的地址的操作码部分改成0xCC（int3指令的的机器码），当调试器捕获到该断点异常时，修改为原来的值即可</li><li>内存断点，内存是按页进行划分的，每页的大小为4KB，每一页内存都有其各自的内存属性，常见的内存属性有只读、可读写、可执行、可共享等。内存断点的原理就是通过对内存属性的修改，本该允许进行的操作无法进行，这样便会引发异常。</li><li>硬件断点，硬件断点是硬件进行支持的，它是硬件提供的调试寄存器组。通过这些硬件寄存器设置相应的值，然后让硬件断在需要下断点的地址。在CPU上有一组特殊的寄存器，被称作调试寄存器。该调试寄存器有8个，分别是DR0<del>DR7，用于设置和管理硬件断点，DR0</del>DR3用于存储所设置硬件断点的内存地址，所以最多只能设置4个硬件断点。寄存器DR4和DR5是系统保留的，并没有公开其用处。DR6，调试状态寄存器，记录了上一次断点触发所产生的调试事件类型信息。DR7用于设置触发硬件断点的条件，比如硬件读断点，硬件访问断点或硬件执行断点。</li></ol><h3 id="内联钩子InLine-Hook"><a href="#内联钩子InLine-Hook" class="headerlink" title="内联钩子InLine Hook"></a>内联钩子InLine Hook</h3><p>程序调用API函数，进入到API函数入口地址执行函数，将API函数一开始的第一条指令改成jmp 地址，地址是自己编写的函数的地址，当执行API函数时，会转到自己编写的函数的地址。</p><p>jmp 地址。这条指令的机器码为E9 1334F411，E9为jmp操作码，1334F411为地址码（偏移量&#x3D;目标地址-原地址-jcc的指令长度）</p><ol><li>构造跳转指令</li><li>在内存中找到欲HOOK函数地址，并保存欲HOOK位置处的前5字节。</li><li>将构造的跳转指令写入需HOOK的位置处。</li><li>当被HOOK位置被执行时会转到自己的流程执行</li><li>如果要执行原来的流程，那么取消HOOK，也就是还原被修改的字节。</li><li>执行原来的流程</li><li>继续HOOK住原来的位置</li></ol><h3 id="壳分为两类"><a href="#壳分为两类" class="headerlink" title="壳分为两类"></a>壳分为两类</h3><ol><li><strong>有的壳注重对代码的压缩，从而生成更小的可执行文件，如UPX、ASPack等</strong></li><li><strong>有的壳注重对代码的保护，以阻碍逆向者进行分析为目的，如VMP、ASProtect等</strong></li></ol><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p><strong>加密分为三类：数据加密，代码加密和算法加密</strong></p><ul><li>数据加密，指对程序已有的数据进行加密的过程，一般会在引用该数据的时候对其进行解密，在引用该数据的地方放置数据解密逻辑</li><li>代码加密，指对程序已有的代码进行加密的过程，一般会在真正执行该代码中的指令时对其进行解密（这个过程运用到了SMC技术）</li><li>算法加密，对关键算法进行混淆，模糊与隐藏。其中最常见的方式是虚拟机保护（最具代表性的是VMProtect）</li></ul><p>一般，加壳程序会将这两种加密方式与RSA等成熟密码学算法相结合，实现对软件“授权系统”及其关键数据的保护</p><p><strong>VMProtect除了提供常规的数据加密，代码加密和其他反调试等功能，还能在汇编指令层面对程序逻辑进行虚拟化，</strong></p><h4 id="将开发者指定的代码段中所有的汇编指令转变为自行编写的一套指令集中的指令，并在实际执行时由自行编写的虚拟机执行器进行模拟执行。"><a href="#将开发者指定的代码段中所有的汇编指令转变为自行编写的一套指令集中的指令，并在实际执行时由自行编写的虚拟机执行器进行模拟执行。" class="headerlink" title="将开发者指定的代码段中所有的汇编指令转变为自行编写的一套指令集中的指令，并在实际执行时由自行编写的虚拟机执行器进行模拟执行。"></a>将开发者指定的代码段中所有的汇编指令转变为自行编写的一套指令集中的指令，并在实际执行时由自行编写的虚拟机执行器进行模拟执行。</h4><p>比如：要实现一个移位，可能用到加，模等运算</p><p><strong>一般出题人会针对题目中的校验算法设计一套精简的指令集</strong></p><ol><li>虚拟CPU执行函数，模仿真实CPU行为，只能执行自己设计的指令集中的指令汇编后的二进制代码</li><li>自己设计的指令集，将某段程序用自己设计的指令集的指令实现</li><li>再将其汇编为该指令集的机器码（俗称<strong>虚拟字节码</strong>）</li></ol><p><strong>解题</strong></p><ol><li>对虚拟CPU执行函数逆向出虚拟架构的指令集</li><li>编写反汇编代码对虚拟字节码进行反汇编</li><li>根据反汇编的结果，分析出题目真正的校验算法</li></ol><h4 id="对于虚拟字节码数量比较小、VM执行器逻辑较为简单的题而言，一种高效的解法是在调试时跟踪并记录运行的指令（俗称“打log”）"><a href="#对于虚拟字节码数量比较小、VM执行器逻辑较为简单的题而言，一种高效的解法是在调试时跟踪并记录运行的指令（俗称“打log”）" class="headerlink" title="对于虚拟字节码数量比较小、VM执行器逻辑较为简单的题而言，一种高效的解法是在调试时跟踪并记录运行的指令（俗称“打log”）"></a>对于虚拟字节码数量比较小、VM执行器逻辑较为简单的题而言，一种高效的解法是在调试时跟踪并记录运行的指令（俗称“打log”）</h4><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>对一个程序进行逆向分析就少不了动态调试的过程。<br>所谓反调试，是指在程序代码中运用若干种反调试技术，干扰对某个进程进行动态调试、逆向分析的手段。</p><ol><li><p><strong>WindowsAPI</strong></p><ul><li>IsDebuggerPresent()</li><li>CheckRemoteDebuggerPresent()</li><li>NtQueryInformationProcess()</li></ul><p><strong>解法：对相应API进行HOOK</strong></p><p>用户态反反调试工具ScyllaHide（<a href="https://github.com/x64dbg/ScyllaHide%EF%BC%89%EF%BC%8C%E8%83%BD%E4%BD%9C%E4%B8%BAOD%E3%80%81x64dbg%E3%80%81IDA%E7%AD%89%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%B9%9F%E6%94%AF%E6%8C%81%E7%8B%AC%E7%AB%8B%E8%BF%90%E8%A1%8C%E3%80%82%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E8%83%BD%E7%BB%95%E8%BF%87VMProtect3.x%E7%9A%84%E5%8F%8D%E8%B0%83%E8%AF%95">https://github.com/x64dbg/ScyllaHide），能作为OD、x64dbg、IDA等常用工具的插件运行，也支持独立运行。最新版本能绕过VMProtect3.x的反调试</a></p></li><li><p><strong>断点检测</strong></p><ol><li><p>软件断点通常修改内存而实现，比如将待断点的地址处的几个字节修改成0xcc（int3断点的操作码），然后断点发生后，修改为原来要运行的指令。这类反调试主要是<strong>写一个计时器函数来时刻检测校验和（若被修改过，校验和不同）或者检测起始字节是否为0xcc。</strong> <strong>解法：逆向程序，找到相应检测逻辑，然后去除；在断点需求少的时候，也可以尽量使用硬件断点进行调试</strong></p></li><li><p>硬件断点可以通过API函数GetThreadContext检测到，<strong>解法：采用Hook的方式来绕过或者用工具ScyllaHide提供的DRxProtection选项来反硬件断点探测</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CheckHWBP</span><span class="params">()</span>&#123;</span><br><span class="line">    CONTEXT ctx=&#123;&#125;;</span><br><span class="line">    ctx.ContextFlags=CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">    <span class="keyword">if</span>(GetThreadContext(GetCurrentThread(),&amp;ctx))&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.Dr0 != <span class="number">0</span> || ctx.Dr1 !=<span class="number">0</span> || ctx.Dr2 !=<span class="number">0</span>|| ctx.Dr3!=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    SOME CODE</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(CheckHWBP())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HW breakpoint detected!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    SOME OTHER CODES</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>时间间隔检测</strong></p><p>在单步跟踪一段指令时，指令运行所耗费的时间与其未被跟踪时的相差巨大。例如：x86 CPU中存在一个名为TSC(Time Stamp Counter，时间戳计数器)的64位寄存器。CPU会对每个时钟周期计数，然后保存到TSC，RDTSC指令便是用来将TSC的值读入EDX:EAX寄存器的，因此RDTSC指令可以被用来进行时间探测。<strong>解法：直接将程序中所有相关RDTSC（0F 31）指令替换成XOR EAX,EAX（33 C0）指令，绕过这种检测。</strong></p></li><li><p><strong>基于异常的反调试</strong></p><p>在Windows系统中，若某进程正在被另一个进程调试，<strong>则其在运行过程中产生的异常将首先由其调试器进行处理，否则会直接由进程中注册的SEH（Structured Exception Handling）处理。</strong></p><p>所谓SEH，就是一种能在一个线程出现错误的时候令操作系统调用用户自定义的回调函数的机制。</p><p>所以，我们可以编写代码，主动抛出一个异常（如执行一条非法指令或者访问一段非法内存等），随后在我们注册的SEH处理函数中对该异常进行接管，接着处理该函数，同时进行一些反调试的操作。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH处理函数的形式如下：</span></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line">_IRQL_requires_same_</span><br><span class="line">_Function_class_(EXCEPTION_ROUTINE)</span><br><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">NTAPI</span><br><span class="line"><span class="title function_">EXCEPTION_ROUTINE</span><span class="params">(</span></span><br><span class="line"><span class="params">    _Inout_ <span class="keyword">struct</span> _EXCEPTION_RECORD *ExceptionRecord,</span></span><br><span class="line"><span class="params">    _In_ PVOID EstablisherFrame,</span></span><br><span class="line"><span class="params">    _Inout_ <span class="keyword">struct</span> _CONTEXT *ContextRecord,</span></span><br><span class="line"><span class="params">    _In_ PVOID DispatcherContext</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="keyword">typedef</span> EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION <span class="title function_">Handler</span><span class="params">(PEXCEPTION_RECORD ExceptionRecord,</span></span><br><span class="line"><span class="params">                             PVOID EstablisherFrame,</span></span><br><span class="line"><span class="params">                             PCONTEXT ContextRecord,</span></span><br><span class="line"><span class="params">                             PVOID DispatcherContext)</span>&#123;</span><br><span class="line">    ContextRecord-&gt;Eip+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ExceptionContinueExecution;<span class="comment">//告诉操作系统恢复产生异常线程的执行，此外，当回调函数无法处理相应异常时，需要返回ExceptionContinueSearch,以告诉操作系统继续寻找下一个回调函数，如果没有下一个回调函数可以接管该异常，那么操作系统会根据相应的注册表项，决定是终止应用程序还是调用某调试器对其进行附加调试。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH链中的项均是如下结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span><span class="comment">//指向下一个项的指针</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;<span class="comment">//对应的回调函数指针</span></span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure><p><strong>解法：对调试器进行配置，使之忽略程序产生的一些特定异常</strong></p><p>例如：将所有的条件跳转指令变成INT3指令，然后在程序自己注册的异常处理函数中，程序根据标志寄存器（RFLAGS）的状态和异常发生的地址模拟实现了这些条件跳转指令的执行。从而实现反调试以及混淆的目的。这种方式被俗称为“CC保护”。<strong>解法：对异常处理函数的逻辑进行逆向分析，将原本的指令恢复。</strong></p></li><li><p><strong>TLS反调试</strong></p><p>TLS（Thread Local Storage），是为解决一个进程中多个线程同时访问全局变量而提供的机制。为了方便开发者对TLS中的数据对象进行一些额外的初始化或销毁操作，Windows提供了TLS回调函数机制。通常，这些回调函数将先于程序入口点被操作系统调用。鉴于隐蔽性，许多开发者喜欢在TLS回调函数中编写调试器检测代码，实现反调试。<strong>解法：使用IDA对程序进行静态分析，IDA能很好地对程序的TLS回调函数进行识别，然后可以对其反调试逻辑进行逆向分析。对于动态调试而言，以x64dbg为例，可以在“顶部菜单-》选项-》选项-》事件“中勾选”TLS回调函数“项，再调试程序，调试器便会在该程序的TLS回调函数被调用前暂停，方便分析和跟踪</strong></p></li><li><p><strong>特定调试器检测</strong></p><p>直接对特定调试器进行探测，比如检测当前系统运行程序的可见窗口中有无包含“x64dbg”的窗口或进程列表中有无名为“x64dbg.exe”的进程等。这种检测方式依赖对诸如EnumWindows等API的调用。<strong>解法：使用HOOK住API，进行特定处理。</strong></p><ul><li>OD早期版本对OutputDebugStringA发送的字符串进行操作时存在一个格式化字符串的漏洞，利用该漏洞可以直接让调试器奔溃</li><li>OD早期版本对硬件断点的处理逻辑存在问题，导致程序主动设置的DRx在某些情况下会被重设，因此我们可以探测OD</li><li>WinDbg会对其启动的调试进程设置若干特有的环境变量，如WINDBG_DIR,SRCSRV_SHOW_TF_PROMPT等，探测这些环境变量是否存在可以实现对WinDbg的检测。</li></ul></li><li><p><strong>架构切换</strong></p><p>64位操作系统可以运行32位程序，此时，32位应用程序运行在Windows提供的一个兼容层WoW64上，必须要切换架构才能让运行在WoW64环境下的程序正常运行。运行在64位操作系统下的32位程序在进入系统调用前均需完成架构的切换，这是通过wow64cpu.dll中一个俗称Heaven‘s Gate的部分来完成的。实际上，它的逻辑非常简单，可以用如下几条指令描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//x86 asm</span><br><span class="line">push 0x33 //cs:0x33</span><br><span class="line">push x64_insn_addr</span><br><span class="line">retf</span><br></pre></td></tr></table></figure><p>切换为64位架构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 0x23  //cs:0x23</span><br><span class="line">push x86_insn_addr</span><br><span class="line">retfq</span><br></pre></td></tr></table></figure><p>Windows下大部分的用户态调试器均无法对架构切换后的代码进行跟踪，但是WinDbg（x64）可以进行动态调试，在retf处下断点，待断点触发后step—in，调试器便会自动切换到另一架构模式，此后调试器的寄存器，栈，地址空间等都会自动适配到64位模式。</p></li></ol><h3 id="OLLVM"><a href="#OLLVM" class="headerlink" title="OLLVM"></a>OLLVM</h3><p>OLLVM（Obfuscator(混淆器)-LLVM(Low Level Virtual Machine)），是基于LLVM实现的一个控制流平坦化混淆工具。<br>其主要思想是将程序的基本块之间的控制关系打乱，而交由统一的分发器进行管理。</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041341122.png" alt="image-20211130164543824"></p><p>第一个图为正常程序的控制流图，第二个图是其经过控制流平坦化处理后的控制流图</p><p>可以看出，控制流平坦化的特征非常明显，整个程序的执行流程通过一个主分发器来控制，每个基本块结束后会根据当前的状态更新state变量，从而决定下一个执行的基本块。</p><p>分发器的结构类似于VM的Handler比较相似，要分辨这两种结构，需要仔细观察控制程序执行流程的关键变量。</p><p><strong>解法：提取关键的state变量，并根据分发器的分发规则进行跟踪，即可还原出原始程序的控制流，详细的实现可以参考deflat.py(<a href="https://security.tencent.com/index.php/blog/msg/112)%E5%92%8CHexRaysDeob%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7(https://www.hex-rays.com/blog/hex-rays-microcode-api-vs-obfuscating-compiler/)">https://security.tencent.com/index.php/blog/msg/112)和HexRaysDeob开源工具(https://www.hex-rays.com/blog/hex-rays-microcode-api-vs-obfuscating-compiler/)</a></strong></p><p><strong>注意：这些通用的开源解混淆工具能解决的只是一部分标准的控制流平坦化混淆，然而原版的OLLVM在2017年便已停止了维护，现在的修改版OLLVM大多都是由个人维护的，并且一般会增加一些新的功能，或用新的实现方法来替代原版。</strong></p><ol><li>增加假的state变量，或者基本块之间的控制流关系存储在其他地方，干扰脚本分析</li><li>增加很多实际不会执行到的基本块，加大分析难度</li><li>利用一些操作系统的特殊机制（异常处理、信号机制等）来代替主分发器</li></ol><p><strong>解法：对一些关键数据（如输入的flag）内存读取&#x2F;写入设置断点，进而定位到程序中对关键数据进行操作的逻辑，或者使用trace类的工具提取出程序真实执行过的基本块，再着重分析这些基本块的逻辑即可。</strong></p><h2 id="高级语言逆向"><a href="#高级语言逆向" class="headerlink" title="高级语言逆向"></a>高级语言逆向</h2><p>CTF会出现一些其他高级语言逆向题，有时还会涉及一些特定库，如MFC等。</p><p>根据是否使用了虚拟机，高级语言分为两类：</p><ol><li>Rust、Go等是无虚拟机的高级语言</li><li>Python、C#等是基于虚拟机的高级语言</li></ol><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><ul><li>有符号情况下，比如：函数窗口中有诸如std::rt::lang_start_internal::这样的字符串，互联网搜索，推测语言</li><li>无符号情况下，在IDA中搜索诸如main.ts的Rust字符串</li></ul><p>为了方便分析，可以借助一些工具来优化IDA对程序的分析。<br>Rust目前公开的脚本工具有rust-reversing-helper（Github上），使用教程参考<a href="https://kong.re.kr/?p=71%EF%BC%8C%E8%AF%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E4%BA%865%E4%B8%AA%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%AD%BE%E5%90%8D%E5%8A%A0%E8%BD%BD%E6%98%AF%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%EF%BC%8C%E8%83%BD%E4%BC%98%E5%8C%96%E8%AF%86%E5%88%ABRust%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%87%8F%E5%B0%91%E5%88%86%E6%9E%90%E6%97%B6%E9%97%B4%E3%80%82">https://kong.re.kr/?p=71，该工具实现了5个功能，其中签名加载是最重要的，能优化识别Rust函数，从而减少分析时间。</a></p><p>std__rt__lang_start_internal函数是Rust的初始化函数，其功能如同start函数。</p><p>在Rust中，主函数（beginer_reverse__main）被当做初始化函数（std__rt__lang_start_internal）参数，主函数在程序初始化完成后（也就是初始化函数执行完后）加载执行的，这也是Rust程序的一个特点。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>为了方便分析，借助Golang的优化分析脚本工具，Github上有golang_loader_assist和IDAGolangHelper工具。</p><p>与Rust相同，Go主函数会作为初始化函数的参数，在初始化完成后被执行。</p><p><strong>注意：以runtime_、fmt_等前缀是go程序包名的函数，而以main_为前缀的函数，基本上是程序编写者自己编写的函数。</strong></p><p><strong>总而言之，无论是Rust还是Golang，这类无虚拟机的高级语言程序都可以被当做抽象层次较高、包含一些额外操作的C程序来对待。面对这样的程序，往往应当先寻找其特征，如字符串、函数名、符号变量、魔数等，从而判断其所属语言，这样才能知道应该采取何种修正方法，修正完后，则可以当做C程序来分析了。</strong></p><p><strong>基于虚拟机的高级语言，其可执行程序或文件中包含的字节码，并不是传统汇编指令的机器码，而是其本身虚拟机指令的字节码，所以这类程序或文件不宜使用IDA分析，应借助其他工具。</strong></p><h3 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h3><p>C#的逆向分析工具有**.NET Reflector、ILSpy&#x2F;dnSpy、Telerik JustDecompile、JetBrainsdotPeek<strong>等，除非有保护（有壳）的C#程序，不然用这些工具打开即可得到源码。<br>去壳工具可以使用</strong>de4dot**</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>在CTF比赛中，Python的逆向往往是对其PYC文件的逆向分析。<strong>PYC文件是PY文件编译后生成的字节码文件，对于一些没混淆过的PYC文件，利用Python的uncompyle2可以将其还原成PY文件。而对于混淆过的PYC文件，若无法去混淆，则只能分析其虚拟机指令。</strong></p><p>对于一个PYC文件，除去开头的8字节数据（版本号和修改时间），剩下的是一个大的PyCodeObject对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Bytecode object*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">int</span> co_argcount;</span><br><span class="line">    <span class="type">int</span> co_kwonlyargcount;</span><br><span class="line">    <span class="type">int</span> co_nlocals;              <span class="comment">//Code Block中局部变量个数，包括其位置参数个数</span></span><br><span class="line">    <span class="type">int</span> co_stacksize;            <span class="comment">//执行该段Code Block需要的栈空间</span></span><br><span class="line">    <span class="type">int</span> co_flags;</span><br><span class="line">    PyObject *co_code;           <span class="comment">//Code Block编译后的字节码序列，以PyStringObject的形式存在</span></span><br><span class="line">    PyObject *co_consts;         <span class="comment">//PyTupleObject，保存Code Block中的所有常量</span></span><br><span class="line">    PyObject *co_names;          <span class="comment">//PyTupleObject，保存Code Block中的所有符号</span></span><br><span class="line">    PyObject *co_varnames;       <span class="comment">//Code Block中的局部变量名集合</span></span><br><span class="line">    PyObject *co_freevars;       <span class="comment">//Python实现闭包存储内容</span></span><br><span class="line">    PyObject *co_cellvars;       <span class="comment">//Code Block中内部嵌套函数所引用的局部变量名集合</span></span><br><span class="line">    <span class="comment">/*The rest doesn&#x27;t count for hash or comparisons*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *co_cell2arg;</span><br><span class="line">    PyObject *co_filename;       <span class="comment">//Code Block对应的.py文件完成路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将读取的二进制数据反序列化成PyCodeObject，只需在Python中执行以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line">code = marshal.loads(data) //code是PYC文件的PyCodeObject</span><br></pre></td></tr></table></figure><p>由于PYC的混淆往往出现在PyCodeObject的co_code字段中，便需要提取co_code的字段的数据进行去混淆。<strong>这里的混淆与传统汇编指令的混淆近似，所以去混淆的方法与传统汇编指令的去混淆方法基本相同。</strong></p><p><strong>注意：PyCodeObject的字段也有可能被混淆过，所以需要对其每个可遍历字段进行遍历，以免出现纰漏。去混淆后，便可还原成py文件</strong></p><p>如果去混淆比较困难，只能分析<strong>虚拟机指令，</strong> <strong>因此需要根据Python对应版本的字节码表，自己来实现对其字节码的反汇编，以达到分析的目的。</strong></p><h3 id="C-MFC"><a href="#C-MFC" class="headerlink" title="C++ MFC"></a>C++ MFC</h3><p>MFC的多层封装，让逆向者难以找主代码。</p><p>MFC内部的消息映射表存储的结构为AFX_MSGMAP和AFX_MSGMAP_ENTRY</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AFX_MAGMAP</span>&#123;</span></span><br><span class="line">    <span class="type">const</span> AFX_MSGMAP* (PASCAL* pfnGetBaseMap)();</span><br><span class="line">    <span class="type">const</span> AFX_MSGMAP_ENTRY* lpEntries;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AFX_MAGMAP_ENTRY</span>&#123;</span></span><br><span class="line">    UINT nMessage;</span><br><span class="line">    UINT nCode;</span><br><span class="line">    UINT nID;</span><br><span class="line">    UINT nLastID;</span><br><span class="line">    UINT_PTR nSig;</span><br><span class="line">    AFX_PMSG pfn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要找到MessageMap，就可以找到所有的消息处理函数，待找到消息处理函数后，即可使用一般的逆向分析技巧进行分析。</p><ol><li><p><strong>利用CWnd的类和实例方法，动态获取目标窗口的MessageMap信息</strong></p><p>使用<strong>xspy工具</strong>，将代码拖动到对应窗口和按钮上，即可自动解析出相关的消息处理函数。</p><p>xspy的内部原理是将一个DLL注入进程序，然后在注入的DLL中HOOK窗口的WndProc，从而获取到程序UI线程的执行权限。</p><p>在MFC的代码中，利用硬编码的已有模式搜索CWnd::FromHandlePermanent的地址，搜索到就可以利用这个函数将获取到的hWnd转为CWnd类的实例，转为CWnd的实例后就可以调用CWnd的各种方法，如GetMessageMap等。</p></li><li><p><strong>利用IDA的引用关系寻找</strong></p><p>在IDA寻找CDialog字符串，然后寻找对CDialog字符串的交叉引用，在其周围找到AFX_MSGMAP。<br>也可以使用IDA搜索常量的功能，搜索按钮的资源id，从而找到AFX_MASSAGE_ENTRY。</p></li></ol><h2 id="现代逆向工程"><a href="#现代逆向工程" class="headerlink" title="现代逆向工程"></a>现代逆向工程</h2><p>两种常见技巧：<strong>符号执行和二进制插桩</strong></p><h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><p>符号执行是一种程序分析技术，可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时的具体值。在到达目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。在实际环境下，符号执行被广泛运用到自动化漏洞挖掘测试的过程中。</p><p>符号执行目前有许多现成的工具可以使用</p><table><thead><tr><th>工具</th><th>适用范围</th></tr></thead><tbody><tr><td>angr</td><td>x86,x86-64,ARM,AARCH64,MIPS,MIPS64,PPC,PPC64</td></tr><tr><td>S2E</td><td>X86,X86-64,ARM架构下的用户态和内核态程序</td></tr><tr><td>BE-PUM</td><td>x86</td></tr><tr><td>Manticore</td><td>x86,x86-64,ARMv7,EVM</td></tr></tbody></table><p>只需pip install angr命令即可完成安装。angr本身对z3进行了一些改动，所以推荐安装在虚拟机中。</p><p>angr分为5个模块，主分析器angr、约束求解器claripy、二进制文件加载器cle、汇编翻译器pyvex（用于将二进制代码翻译为统一的中间语言）、架构信息库archinfo（存放着很多架构相关的信息，用于针对性地处理不同的架构）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    p=angr.Project(<span class="string">&quot;r100&quot;</span>)  //载入需要分析的程序</span><br><span class="line">    </span><br><span class="line">    simgr=p.factory.simulation_manager(p.factory.full_init_state()) </span><br><span class="line">   //使用p.factory.simulation_manager创建了</span><br><span class="line">   //一个simulation_manager进行模拟执行。其中传入一个SimState作为初始状态</span><br><span class="line">   //SimState代表程序的一种状态，状态中包含了程序的寄存器、内存、执行路径等信息。他有三个值，如下：</span><br><span class="line">   //blank_state(**kwargs)返回一个未初始化的state，此时需要自己手动设置入口地址，以及自定义的参数</span><br><span class="line">   //entry_state(**kwargs)返回程序入口地址的state，默认会使用该装填</span><br><span class="line">   //full_init_state(**kwargs)同entry_state(**kwargs)类似，但是在入口点前应调用每个库的初始化函数</span><br><span class="line">    </span><br><span class="line">    simgr.explore(find=<span class="number">0x400844</span>,avoid=<span class="number">0x400855</span>)//find表示要到达的目标地址，avoid表示要避免的目标地址</span><br><span class="line">    //两个可以为数组，表示要到达/要避免的路径</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>).strip(<span class="string">b&#x27;\0\n&#x27;</span>)</span><br><span class="line">    //通过simgr.found[<span class="number">0</span>]找到了一条到达目标地址的路径，然后返回一个SimState的数据类型。可以通过这个这个数据类型</span><br><span class="line">    //获取到程序此时的所有状态，包括寄存器（如simgr.found[<span class="number">0</span>].regs.rax）、内存（如simgr.found[<span class="number">0</span>].mem[<span class="number">0x400610</span>].byte）等</span><br><span class="line">    //而posix代表了程序通过POSIX（Portable Operating System Interface）规范中的接口获取的数据，包含环境变量、命令行参数、标准输入、标准输出等。posix.dumps(<span class="number">0</span>)代表获取标准输入中的数据，posix.dumps(<span class="number">1</span>)代表获取标准输出中的数据，</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">assert</span> main().startswith(<span class="string">b&#x27;Code_Talkers&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__=__main__:</span><br><span class="line">    <span class="built_in">print</span>(main())</span><br></pre></td></tr></table></figure><p>优化后的程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line">//要实现HOOK函数要继承angr.SimProcedure这个类并重写run方法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_fgets</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,s,num,f</span>):</span><br><span class="line">        simfd=self.state.posix.get_fd(<span class="number">0</span>)//获得标准输入流</span><br><span class="line">        data,real_size=simfd.read_data(<span class="number">12</span>)//获取<span class="number">12</span>个字节的输入</span><br><span class="line">        self.state.memory.store(s,data)//将数据存在内存s</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span></span><br><span class="line">p.hook_symbol(<span class="string">&#x27;fgets&#x27;</span>,my_fgets(),replace=<span class="literal">True</span>)//hook fgets函数</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    p=angr.Project(<span class="string">&quot;r100&quot;</span>,auto_load_libs=<span class="literal">False</span>)  //默认为<span class="literal">True</span>，angr会自动载入依赖库，然后分析库函数调用时也会进入库函数，会增加分析的工具量，如果为<span class="literal">False</span>，那么程序调用库函数时直接返回一个不受约束的符号值。libc由angr专门做了优化，不需要加载libc库</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    state=p.factory.blank_state(addr=<span class="number">0x4007E8</span>)//直接从main函数开始分析</span><br><span class="line">    </span><br><span class="line">    flag_chars=[claripy.BVS(<span class="string">&#x27;flag_%d&#x27;</span>%i,<span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>)]//claripy.BVS用来创建符号变量，第一个参数为变量名，第二个为位数。</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">        state.men[state.regs.rsp+i*<span class="number">4</span>].dword=flag_chars[i] //存入内存</span><br><span class="line">    state.regs.rpi=state.regs.rsp //用rpi代表这个数组的起始位置</span><br><span class="line">    </span><br><span class="line">    p.hook_symbol(<span class="string">&#x27;printf&#x27;</span>,angr.SIM_PROCEDURES[<span class="string">&#x27;stubs&#x27;</span>][<span class="string">&#x27;ReturnUnconstrained&#x27;</span>](),replace=<span class="literal">True</span>)</span><br><span class="line">    //前面去掉了载入依赖库，而printf依赖库，所以直接去掉printf，让他直接返回。replace代表替代之前的HOOK</span><br><span class="line">    </span><br><span class="line">    simgr=p.factory.simulation_manager(state) </span><br><span class="line">    </span><br><span class="line">    simgr.one_active.options.add(angr.options.LAZY_SOLVES)//运行的时候不检查当前的条件能否成功到达目标位置</span><br><span class="line">    </span><br><span class="line">    simgr.explore(find=<span class="number">0x400844</span>,avoid=<span class="number">0x400855</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    //<span class="keyword">return</span> simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>).strip(<span class="string">b&#x27;\0\n&#x27;</span>)手动设置符号变量后，不能使用dumps来获取标准输入输出流，要使用<span class="built_in">eval</span>函数</span><br><span class="line">    flag=<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(s.one_found_solver.<span class="built_in">eval</span>(c)) <span class="keyword">for</span> c <span class="keyword">in</span> flag_chars)</span><br><span class="line">    <span class="keyword">return</span> flag </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">assert</span> main().startswith(<span class="string">b&#x27;Code_Talkers&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__=__main__:</span><br><span class="line">    <span class="built_in">print</span>(main())</span><br></pre></td></tr></table></figure><p>angr支持对特定的地址进行hook</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_hook</span>(<span class="params">addr,myfunction</span>):</span><br><span class="line">    proj.hook(addr,myfunction)//第一个为HOOK的地址，第二个为自己编写的函数地址</span><br></pre></td></tr></table></figure><h2 id="二进制插桩"><a href="#二进制插桩" class="headerlink" title="二进制插桩"></a>二进制插桩</h2><p>插桩是在保证程序原有逻辑完整性的基础上，在程序中插入探针，通过探针的执行来收集程序运行时信息的技术。</p><p>根据实现插桩的方式，插桩分为两类：<strong>源码插桩和二进制插桩</strong></p><p>二进制插桩分为<strong>静态二进制插桩和动态二进制插桩</strong></p><ol><li>静态二进制插桩：在运行前插入额外的指令和数据并生成修改后的二进制文件。</li><li>动态二进制插桩：在程序运行时插入额外的指令和数据，不会修改当前的可执行文件。</li></ol><h3 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h3><p>Pin是二进制动态插桩引擎，支持32&#x2F;64位的Windows、Linux、Mac、Android。</p><h5 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h5><p>…</p><h5 id="Pintool使用"><a href="#Pintool使用" class="headerlink" title="Pintool使用"></a>Pintool使用</h5><p>…</p><table><thead><tr><th>插桩粒度</th><th>API</th><th>执行时机</th></tr></thead><tbody><tr><td>指令级插桩</td><td>INS_AddInstrumentFunction</td><td>执行一条新指令</td></tr><tr><td>轨迹级插桩(基本块级插桩)</td><td>TRACE_AddInstrumentFunction</td><td>执行一个新trace</td></tr><tr><td>镜像级插桩</td><td>IMG_AddInstrumentFunction</td><td>加载新镜像时</td></tr><tr><td>函数级插桩</td><td>RTN_AddInstrumentFunction</td><td>执行一个新函数时</td></tr></tbody></table><p>基本格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">bblTrace</span><span class="params">(TRACE trace,VOID *v)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(BBL bbl=TRACE_BblHead(trace);BBL_Valid(bbl);bbl=BBL_Next(bbl))&#123;</span><br><span class="line">        BBL_InsertCall(bbl,IPOINT_BEFORE,(AFUNPTR)myTrace,IARG_INST_PTR,IARG_END);<span class="comment">//给自己编写的myTrace函数传参，传递的参数为IARG_INST_PTR，IARG_END代表结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dump内存"><a href="#Dump内存" class="headerlink" title="Dump内存"></a>Dump内存</h2><p>对于Windows系统，查看用户态程序内存，可以使用调试器；查看内核驱动的内存，则可以使用高级的内核级系统维护工具，如<strong>PCHunter</strong>（使用版本较低的Windows虚拟机）</p><p><strong>PCHunter从内核入手，绕开驱动的保护。</strong></p><p><img src="/./image-20211203192859640.png" alt="image-20211203192859640"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static main()      //dump内存</span><br><span class="line">&#123;</span><br><span class="line">    auto i,fp;</span><br><span class="line">    fp = fopen(&quot;d:\\dump&quot;,&quot;wb&quot;);</span><br><span class="line">    auto start = 0x402176;</span><br><span class="line">    auto size = 487; //长度加1</span><br><span class="line">    for(i=start;i&lt;start+size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fputc(Byte(i),fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fp.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Call-5"><a href="#Call-5" class="headerlink" title="Call $+5"></a>Call $+5</h3><p>1）call 的本质作用是将ip压栈，然后jmp ，ret的本质作用是pop栈到ip；call和ret是为函数准备的命令，但它们的功能是分离的，都可以单独使用。<br>2）$代表当前的地址，而IP寄存器又不能直接操作，所以使用 call $+5 , pop eax这样的指令将当前地址传给eax。<br>3）call指令占5个字节，所以$+5，就是下一条指令的地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反汇编C语言</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/%E5%8F%8D%E6%B1%87%E7%BC%96C%E8%AF%AD%E8%A8%80/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/%E5%8F%8D%E6%B1%87%E7%BC%96C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>Windows下的API函数调用约定是stdcall，参数从右到左依次被送入堆栈，参数的平栈是在API函数内完成的。（多参的API函数仍然在函数调用方进行平栈）<br>与之相反的是cdecl，参数的平栈是在调用方完成的。</p><p>stdcall是Windows下的标准函数调用约定。Windows提供的应用层及内核层函数均使用stdcall的调用约定方式<br>cdecl是C语言的调用函数约定方式</p><p>call ds:__imp__MessageBoxA@16 </p><p>ds:__imp__   ds:表示动态链接，__imp__表示导入函数。@16表示（16%4&#x3D;4）表示4个参数</p><p>[ebp+var_4]表示变量</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041346440.png" alt="image-20211203192859640"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041343074.png" alt="image-20211030202522485" style="zoom:200%;" /><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041343229.png" alt="image-20211101163123444"></p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>CPU指令集（CPU微处理器架构）分为x86以及ARM</p><p>ASM（assembly language）：汇编语言</p><p>在运行 Microsoft Windows 的 x86 系统中，其他一些有名的汇编器包括：TASM（Turbo 汇编器），NASM（Netwide 汇编器）和 MASM32（MASM 的一种变体）。GAS（GNU 汇编器）和 NASM 是两种基于 Linux 的汇编器。在这些汇编器中，NASM 的语法与 MASM 的最相似。</p><p>32 位保护模式（32-Bit Protected Mode）：32 位保护模式程序运行于所有的 32 位和 64 位版本的 Microsoft Windows 系统。它们通常比实模式程序更容易编写和理解。从现在开始，将其简称为 32 位模式。</p><p>64 位模式（64-Bit Mode）：64 位程序运行于所有的 64 位版本 Microsoft Windows 系统。</p><p>16 位实地址模式（16-Bit Real-Address Mode）：16 位程序运行于 32 位版本 Windows 和嵌入式系统。 64 位 Windows 不支持这类程序。</p><p>汇编语言与机器语言是一对一（one-to-one）的关系：每一条汇编语言指令对应一条机器语言指令。</p><h1 id="2-x86"><a href="#2-x86" class="headerlink" title="2.x86"></a>2.x86</h1><ul><li><p>字节（Byte）：8位，比如AL、BL、CL。</p></li><li><p>字（word）：16位，比如AX、BX、CX。</p></li><li><p>双字（Double Word）：32位，比如EAX、EBX、ECX。</p><h2 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h2><p>x86 处理器有三个主要的操作模式：<strong>保护模式、实地址模式和系统管理模式</strong>；以及一个子模式：虚拟 8086 (virtual-8086) 模式，这是保护模式的特殊情况。以下是对这些模式的简介：</p><h3 id="1-保护模式-Protected-Mode"><a href="#1-保护模式-Protected-Mode" class="headerlink" title="1) 保护模式 (Protected Mode)"></a>1) 保护模式 (Protected Mode)</h3><p>保护模式是处理器的原生状态，在这种模式下，所有的指令和特性都是可用的。分配给程序的独立内存区域被称为段，而处理器会阻止程序使用自身段范围之外的内存。</p><h3 id="2-虚拟-8086-模式-Virtual-8086-Mode"><a href="#2-虚拟-8086-模式-Virtual-8086-Mode" class="headerlink" title="2) 虚拟 8086 模式 (Virtual-8086 Mode)"></a>2) 虚拟 8086 模式 (Virtual-8086 Mode)</h3><p>保护模式下，处理器可以在一个安全环境中，直接执行实地址模式软件，如 MS-DOS 程序。换句话说，如果一个程序崩溃了或是试图向系统内存区域写数据，都不会影响到同一时间内执行的其他程序。现代操作系统可以同时执行多个独立的虚拟 8086 会话。</p><h3 id="3-实地址模式-Real-Address-Mode"><a href="#3-实地址模式-Real-Address-Mode" class="headerlink" title="3) 实地址模式 (Real-Address Mode)"></a>3) 实地址模式 (Real-Address Mode)</h3><p>实地址模式实现的是早期 Intel 处理器的编程环境，但是增加了一些其他的特性，如切换到其他模式的功能。当程序需要直接访问系统内存和硬件设备时，这种模式就很有用。</p><h3 id="4-系统管理模式-System-Management-Mode"><a href="#4-系统管理模式-System-Management-Mode" class="headerlink" title="4) 系统管理模式 (System Management Mode)"></a>4) 系统管理模式 (System Management Mode)</h3><p>系统管理模式 (SMM) 向操作系统提供了实现诸如电源管理和系统安全等功能的机制。这些功能通常是由计算机制造商实现的，他们为了一个特定的系统设置而定制处理器。</p></li></ul><p>x86通过一种环级别（ring level）的抽象来支持特权隔离。处理器支持4种特权级别，编号为0到3（通常不使用ring1和ring2，所以不讨论）</p><ol><li>ring0具有最高特权级别，可以修改所有的系统设置。</li><li>ring3的特权级别最低，只能读取&#x2F;修改部分系统设置。</li></ol><p>因此现代操作系统通常将用户模式应用程序运行在ring3级别，内核运行在ring0级别，以此实现用户&#x2F;内核特权隔离，ring级别编码于CS寄存器</p><table><thead><tr><th align="left">通用寄存器名</th><th>作用</th></tr></thead><tbody><tr><td align="left">EAX（双字）</td><td>存放函数返回值</td></tr><tr><td align="left">EBX（双字）</td><td></td></tr><tr><td align="left">ECX（双字）</td><td>循环计数</td></tr><tr><td align="left">EDX</td><td></td></tr><tr><td align="left">EDI</td><td>字符串&#x2F;内存操作的目标</td></tr><tr><td align="left">ESI</td><td>字符串&#x2F;内存操作的源</td></tr><tr><td align="left">EBP</td><td>帧基指针，保存基址</td></tr><tr><td align="left">ESP</td><td>栈指针</td></tr></tbody></table><table><thead><tr><th>其他寄存器</th><th>作用</th></tr></thead><tbody><tr><td>EIP</td><td>存储指令指针，存储CPU当前要运行的内存地址</td></tr><tr><td>EFLAGS</td><td>用于存储算术运算状态以及其他运行状态（比如陷阱标志位DF）</td></tr><tr><td>CR0</td><td>控制分页机制的开关</td></tr><tr><td>CR2</td><td>保存着导致缺页异常发生的线性地址</td></tr><tr><td>CR3</td><td>分页数据结构的基地址</td></tr><tr><td>CR4</td><td>控制硬件虚拟化设置</td></tr><tr><td>DR0~DR7</td><td>用于设置内存断电，其中系统只支持4个内存断电（DR0~DR3），其余寄存器用于保存状态</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>其他寄存器</th><th>作用</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>MOVSB&#x2F;MOVSW&#x2F;MOVSD</td><td>指令分别以1字节，2字节或4字节为单位，在两个内存地址之间移动数据</td></tr><tr><td>SCAS(B&#x2F;W&#x2F;D)</td><td>SCAS指令隐式地把（当指令为SCASB&#x2F;SCASW&#x2F;SCASD时）AL&#x2F;AX&#x2F;EAX的数值与地址为EDI的内存数值比较。根据EFLAGS中DF标志位的不同，EDI自动递增或递减。</td></tr><tr><td>REP</td><td>重复执行目标指令n次，比如：rep movsd ；复制4n字节（重复n次movsd），找ECX，每循环一次，ECX值减一，满足条件ECX&gt;0</td></tr><tr><td>LEA</td><td></td></tr><tr><td>repne（repeat no equal）</td><td>不相等时重复（零标志位）<strong>ZF&#x3D;0且ECX&gt;0进行重复</strong></td></tr><tr><td>repe（repeat equal）</td><td>相等是时候重复（零标志位）<strong>ZF&#x3D;1且ECX&gt;0进行重复</strong></td></tr><tr><td>MUL（无符号）</td><td>只允许后面有一个操作数，比如：mul ebx  ；将ebx的值与eax的值相乘，若结果存不下，则扩展为EDX:EAX。乘法运算，寄存器值与AL、AX或EAX值相乘，结果存储于AX、DX:AX或EDX:EAX                                 例如：mul ecx    ;EDX:EAX&#x3D;EAX*ECX</td></tr><tr><td>DIV（无符号）</td><td>只允许后面有一个操作数，比如：div ebx  ；将EAX &#x2F; EBX 的商放入EAX，余数放入EDX。计算得到的商和余数存储在AL&#x2F;AH、AX&#x2F;DX或EAX&#x2F;EDX中。</td></tr><tr><td>IMUL（有符号）</td><td>可有多个操作数。例如：imul ebx,ecx ；若溢出，结果高位部分存到ECX，低位部分存入EBX。</td></tr></tbody></table><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>NOP</strong></td><td>垃圾指令，不执行任何操作</td></tr><tr><td>PUSHFD</td><td>对标志位进行现场保护，将32位标志寄存器EFLAGS压入堆栈</td></tr><tr><td>POPFD</td><td>还原标志位寄存器，从栈中弹出标志位寄存器的值到标志位寄存器</td></tr><tr><td>MOVSX</td><td>有符号扩展（ movsx eax，bx)（movsx eax , bh(或者bl)）如果bx（对应2个字节），bh&#x2F;bl（对应一个字节）的值大于它所对应字节的一半+1，则复制到的存储器的高位值要变负。</td></tr><tr><td>MOVZX</td><td>无符号扩展（ movzx eax,   bx)（movzx eax, bh(或者bl)）如果bx（对应2个字节），bh&#x2F;bl（对应一个字节）的值大于它所对应字节的一半+1，则复制到的存储器的高位值不用变。</td></tr><tr><td>XCHG</td><td>值交换，将两个值交换</td></tr><tr><td>ADC</td><td>比如：adc eax,ebx 相当于 eax&#x3D;eax+ebx+CF（进位标志位）</td></tr><tr><td>SBB</td><td>比如：sbb eax,ebx 相当于 eax&#x3D;eax-ebx-CF</td></tr><tr><td>INC</td><td>递增，就是寄存器自动加1</td></tr></tbody></table><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>DEC</td><td>递减，就是寄存器自动减1</td></tr><tr><td>IDIV                              （有符号）</td><td></td></tr><tr><td>XADD</td><td>例如：xadd ebx,eax ; 设ebx为3，eax为2，则执行执行这条指令，交换双方的值，ebx为2，eax为3，然后相加返回给ebx，则ebx为5。</td></tr><tr><td>NEG</td><td>取反指令，neg ebx ；若ebx为100，则执行此指令，ebx为-100</td></tr><tr><td>CMP</td><td>比较指令，比较两个寄存器的值是否想等。例如：cmp edx,eax ；其实是两个值相减，sub edx,eax比较两个值是否相等，结果并不会存到edx寄存器，若比较出来结果相等，即相减为0，则运算结果为0，ZF标志位置为1</td></tr><tr><td>PUSH</td><td>传递函数参数</td></tr><tr><td>TEST</td><td>比较指令，比较两个寄存器的值是否相等。例如：test eax,ebx；其实是两个值进行与运算，and eax,ebx；运算结果是否为0，若为0，则置ZF为1，否则置0。结果不保存到EAX寄存器上。</td></tr><tr><td>JMP</td><td>无条件跳转指令，不根据标志位来改变程序运行逻辑</td></tr><tr><td>JE&#x2F;JZ</td><td>根据ZF标志位来进行跳转，如果ZF标志位为1时则跳，为0时不跳</td></tr></tbody></table><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>JNE&#x2F;JNZ</td><td>根据ZF标志位来进行跳转，ZF标志位为0时则跳，为1时则不跳</td></tr><tr><td>JS</td><td>如果结果为负，SF为1，根据SF标志位来进行跳转，如果SF标志位为1时则跳，为0时则不跳</td></tr><tr><td>JNS</td><td>根据SF标志位来进行跳转，如果SF标志位为0时则跳，为1时则不跳</td></tr><tr><td>JP&#x2F;JPE</td><td>如果结果的低十六位含1个数为偶数时，PF为1。根据PF标志位来进行跳转，如果PF标志位为1时则跳，为0时则不跳</td></tr><tr><td>JNP&#x2F;JPO</td><td>根据PF标志位来进行跳转，如果PF标志位为0时则跳，为1时则不跳</td></tr><tr><td>JO</td><td>根据OF标志位来进行跳转，如果OF标志位为1时则跳，为0时则不跳</td></tr><tr><td>JNO</td><td>根据OF标志位来进行跳转，如果OF标志位为0时则跳，为1时则不跳</td></tr><tr><td>JB</td><td>（判断无符号）根据CF标志位（根据无符号进行运算，只有进位或借位，不存在有无符号）来进行跳转，如果CF标志位为1时则跳，为0时则不跳</td></tr><tr><td>JNB</td><td>根据CF标志位来进行跳转，如果CF标志位为0时则跳，为1时则不跳</td></tr></tbody></table><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>JBE</td><td>根据CF或ZF标志位来进行跳转，如果CF或者ZF标志为1时则跳，为0则不跳。例如：cmp eax,ebx；若运算结果为0，ZF为1，运算结果小于0，CF为1。所以就是看eax-ebx的结果是否&lt;&#x3D;0，就是判断eax&lt;&#x3D;ebx</td></tr><tr><td>JNBE&#x2F;JA</td><td>根据CF和ZF标志位来进行跳转，如果CF和ZF标志都为0时则跳，有一个为1时则不跳。例如：cmp eax,ebx；若运算结果不为0，ZF为0，运算结果大于0，CF为0。所以就是看eax-ebx的结果是否&gt;0，就是判断eax&gt;ebx</td></tr><tr><td>JL</td><td>（判断有符号）根据SF标志位（根据有符号进行运算）来进行跳转，若SF为1，则跳，为0则不跳</td></tr><tr><td>JNL</td><td>（判断有符号）根据SF标志位（根据有符号进行运算）来进行跳转，若SF为0，则跳，为1则不跳</td></tr><tr><td>CALL</td><td>函数调用，例如：call 00007FFB59C4A838 ；跳到子程序的地址执行，主程序的下个地址存入栈中，当子程序执行完后，从栈顶弹出地址赋值给EIP，然后继续执行主程序后的部分。</td></tr><tr><td>RET</td><td>call和ret配合使用，当运行到ret时，表示子程序返回到主程序。弹出栈顶把地址给EIP或者将ECX的值给EIP</td></tr><tr><td>LOOP</td><td>根据寄存器ECX值递减至1时，则不继续循环，且ECX减为0；常见有loopd，loopb和loop是一样的 loopd使用ECX 32位计数器。loopb使用ECX 8位计数器。</td></tr><tr><td>OFFSET</td><td>OFFSET 找到标记位置的操作符，比如：mov si, OFFSET start  ; 找到start标记的指令的偏移地址</td></tr><tr><td>SAR</td><td>将目的操作数进行右移运算（左移表示乘2，右移表示除2）</td></tr></tbody></table><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>PUSHAD</td><td>将所有的32位通用寄存器压入堆栈</td></tr><tr><td>RETF</td><td>retf用栈中数据同时改CS,IP,远转移</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>x86独有的，支持INC或ADD指令，让内存地址中的某个数递增</p><h4 id="根据汇编器-x2F-反汇编器的不同，x86汇编代码有两种语法记法：Intel和AT-amp-T"><a href="#根据汇编器-x2F-反汇编器的不同，x86汇编代码有两种语法记法：Intel和AT-amp-T" class="headerlink" title="根据汇编器&#x2F;反汇编器的不同，x86汇编代码有两种语法记法：Intel和AT&amp;T"></a>根据汇编器&#x2F;反汇编器的不同，x86汇编代码有两种语法记法：Intel和AT&amp;T</h4><ol><li><p>Intel</p><p>mov ecx , AABBCCDDh<br>mov ecx , [eax]<br>mov ecx , eax</p></li><li><p>AT&amp;T</p><p>movl $0xAABBCCDD , %ecx<br>movl (%eax) , %ecx<br>movl %eax , %ecx</p></li></ol><ul><li><strong>AT&amp;T记法在寄存器名前加前缀%，立即数加$。Intel记法不加前缀</strong></li><li><strong>AT&amp;T记法加入了指示指令宽度的后缀，比如MOVL(长整形)，MOVB（字节）等。而Intel记法没有这种标识</strong></li><li><strong>AT&amp;T记法把源操作数放在目标操作数前面。而Intel记法相反</strong></li></ul><p>x86使用[]标识内存地址，<strong>LEA指令也使用[]，但不一定指内存</strong>，<strong>LEA不访问内存</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr [eax] , 1</span><br><span class="line">;把1放入EAX内存地址</span><br><span class="line">mov ecx, [eax]</span><br><span class="line">;访问EAX寄存器存储的地址值，并把这个地址值当做内存地址值去访问内存，把值提取出来并放入ECX寄存器</span><br><span class="line">mov [eax], ebx</span><br><span class="line">;把EBX寄存器里的值放入EAX内存地址</span><br><span class="line">mov [esi+34h], eax</span><br><span class="line">;把EAX寄存器里的值放入内存地址为（ESI+0x34）的值</span><br><span class="line">mov eax, [esi+34h]</span><br><span class="line">;把内存地址为（ESI+0x34）的值放入EAX寄存器</span><br><span class="line">mov edx, [ecx+eax]</span><br><span class="line">;把内存地址为（ECX+EAX）的值放入EDX寄存器</span><br></pre></td></tr></table></figure><p>转化为C伪码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*eax=1;</span><br><span class="line">ecx=*eax;//EAX寄存器存储了一个地址值，通*EAX访问这个地址值里的内容，并将内容赋给ECX</span><br><span class="line">*eax=ebx;</span><br><span class="line">*(esi+0x34)=eax;</span><br><span class="line">eax=*(esi+0x34);</span><br><span class="line">edx=*(ecx+eax);</span><br></pre></td></tr></table></figure><p>dword   (double word)双字 就是四个字节<br>ptr     pointer缩写 即指针<br>[]里的数据是一个地址值，这个地址指向一个双字型数据<br>比如mov eax, dword ptr [12345678]  把内存地址12345678中的双字型（32位）数据赋给eax </p><p><strong>C语言实现strlen()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xor al,al </span><br><span class="line">;al置0</span><br><span class="line">mov ebx,edi</span><br><span class="line">;复制edi寄存器的值到ebx</span><br><span class="line">repne scasb</span><br><span class="line">;SCAS指令隐式地把（当指令为SCASB/SCASW/SCASD时）AL/AX/EAX的数值与地址为EDI的内存数值比较，若不同(对应repne)，则重复扫描。同时EDI-1</span><br><span class="line">sub edi,ebx</span><br><span class="line">ebx寄存器的值减去edi寄存器的值，结果存入edi寄存器，得到扫描的字符串的长度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041343826.png" alt="image-20211028140257199"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041344587.png" alt="image-20211028144511317"></p><h4 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h4><p>某些通用寄存器有特殊用法：</p><ul><li><strong>乘除指令默认使用EAX</strong>。它常常被称为扩展累加器（extended accumulator）寄存器。</li><li><strong>CPU 默认使用 ECX 为循环计数器。</strong></li><li>ESP 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针（extended stack pointer）寄存器。</li><li>ESI 和 EDI 用于高速存储器传输指令，有时也被称为扩展源变址（extended source index）寄存器和扩展目的变址（extended destination index）寄存器。</li><li>高级语言通过 EBP 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针（extended frame pointer）寄存器。</li></ul><h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>实地址模式中，16 位段寄存器表示的是预先分配的内存区域的基址，这个内存区域称为段。保护模式中，段寄存器中存放的是段描述符表指针。一些段中存放程序指令（代码），其他段存放变量（数据），还有一个堆栈段存放的是局部函数变量和函数参数。</p><h1 id="3-X86-64"><a href="#3-X86-64" class="headerlink" title="3.X86-64"></a>3.X86-64</h1><p>本节重点关注所有使用 x86-64 指令集的 64 位处理器的基本架构细节。这些处理器包括 Intel 64 和 AMD64 处理器系列。指令集是已讨论的 x86 指令集的 64 位扩展。以下为一些基本特征：</p><ol><li><p><strong>向后兼容 x86 指令集。</strong></p></li><li><p>地址长度为 64 位，虚拟地址空间为 2 64 字节。按照当前芯片的实现情况，<strong>只能使用地址的低 48 位。</strong></p></li><li><p>可以使用 64 位通用寄存器，允许指令具有 64 位整数操作数。</p></li><li><p>比 x86 多了 8 个通用寄存器。</p></li><li><p>物理地址为 48 位，支持高达 256TB 的 RAM。</p></li></ol><p>另一方面，<strong>当处理器运行于本机 64 位模式时，是不支持 16 位实模式或虚拟 8086 模式的。</strong>（在传统模式（legacy mode）下，还是支持 16 位编程，但是在 Microsoft Windows 64 位版本中不可用。）</p><p>注意尽管 x86-64 指的是指令集，但是也可以将其看作是处理器类型。学习<a href="http://c.biancheng.net/asm/">汇编语言</a>时，没有必要考虑支持 x86-64 的处理器之间的硬件实现差异。</p><h2 id="64-位操作模式"><a href="#64-位操作模式" class="headerlink" title="64 位操作模式"></a>64 位操作模式</h2><p>Intel 64 架构引入了一个新模式，称为 IA-32e。从技术上看，包含两个模式：<strong>兼容模式</strong>（compatibility mode）和 <strong>64 位模式</strong>（64-bit mode）。不过它们常常被看做是模式而不是子模式，因此，先来了解这两个模式。</p><h4 id="1-兼容模式"><a href="#1-兼容模式" class="headerlink" title="1) 兼容模式"></a>1) 兼容模式</h4><p>在兼容模式下，现有的 16 位与 32 位应用程序通常不用进行重新编译就可以运行。但是，16 位 Windows（Win16）和 DOS 应用程序不能运行在 64 位 Microsoft Windows 下。</p><p>与早期 Windows 版本不同，64 位 Windows 没有虚拟 DOS 机器子系统来利用处理器的功能切换到虚拟 8086 模式。</p><h4 id="2-64-位模式"><a href="#2-64-位模式" class="headerlink" title="2) 64 位模式"></a>2) 64 位模式</h4><p>在 64 位模式下，处理器执行的是使用 64 位线性地址空间的应用程序。这是 64 位 Microsoft Windows 的原生模式，该模式能使用 64 位指令操作数。</p><table><thead><tr><th>操作数大小</th><th>可用寄存器</th></tr></thead><tbody><tr><td>8 位</td><td>AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L</td></tr><tr><td>16 位</td><td>AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W</td></tr><tr><td>32 位</td><td>EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D</td></tr><tr><td>64 位</td><td>RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15</td></tr></tbody></table><p>64 位模式下，虽然处理器现在只能支持 48 位的地址，但是理论上，地址最大为 64 位。从寄存器来看，64 位模式与 32 位最主要的区别如下所示：</p><ul><li>16 个 64 位通用寄存器（32 位模式只有 8 个通用寄存器）</li><li>8 个 80 位浮点寄存器</li><li>1 个 64 位状态标志寄存器 RFLAGS （只使用低 32 位）</li><li>1 个 64 位指令指针寄存器 RIP</li><li>32 位模式和 64 位模式具有相同的状态标志</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/windows%E5%BC%80%E5%8F%91/c++/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/windows%E5%BC%80%E5%8F%91/c++/</url>
      
        <content type="html"><![CDATA[<h2 id="C和C-的不同"><a href="#C和C-的不同" class="headerlink" title="C和C++的不同"></a>C和C++的不同</h2><ol><li>C++的头文件比如<iostream>，没有后缀.h，有些c语言的头文件被转换为c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为c++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。例如c++版本的math.h为cmath.</li><li>而C的头文件比如&lt;stdio.h&gt;,&lt;stdlib.h&gt;,都有后缀.h</li></ol><h3 id="引进作用域"><a href="#引进作用域" class="headerlink" title="引进作用域"></a>引进作用域</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//1. 局部变量和全局变量同名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//打印局部变量a</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部变量a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//打印全局变量a</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局变量a:&quot;</span> &lt;&lt; ::a &lt;&lt; endl; <span class="comment">//::表示全局作用域，::a表示全局作用域下的a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个命名空间，命名空间就是作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;<span class="comment">//代表A命名空间（作用域）下的变量a，A::a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>命名空间只能全局范围内定义，不能局部范围内定义</p></li><li><p>命名空间可相互嵌套</p></li><li><p>命名空间随时可以加入新的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;<span class="comment">//往命名空间A中追加一个函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无命名空间只能在本文件内访问</p></li></ul><p>想在文件里用其他命名空间有两种方式：</p><ol><li>using namespace a; 可使用命名空间下的所有东西</li><li>using a::fun(); 指定只使用命名空间a下的fun函数</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/linux/%E5%88%9D%E5%AD%A6/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/linux/%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux目录夹"><a href="#Linux目录夹" class="headerlink" title="Linux目录夹"></a>Linux目录夹</h1><table><thead><tr><th>目录</th><th>作用</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>存放着最经常使用的命令</td></tr><tr><td>&#x2F;sbin</td><td>存放的是系统管理员使用的系统管理程序</td></tr><tr><td>&#x2F;home</td><td>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</td></tr><tr><td>&#x2F;root</td><td>该目录为系统管理员，也被称作超级权限者的用户主目录。</td></tr><tr><td>&#x2F;lib</td><td>系统开机所需要最基本的动态链接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</td></tr><tr><td>&#x2F;etc</td><td>所有系统管理所需要的配置文件</td></tr><tr><td>&#x2F;usr</td><td>用户的很多应用程序和文件都放在这个目录下</td></tr><tr><td>&#x2F;boot</td><td>存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</td></tr><tr><td>&#x2F;proc</td><td>这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息</td></tr><tr><td>&#x2F;srv</td><td>该目录存放一些服务启动之后需要提取的数据</td></tr><tr><td>&#x2F;sys</td><td>该目录下安装了2.6内核中新出现的一个文件系统</td></tr><tr><td>&#x2F;tmp</td><td>这个目录是用来存放一些临时文件的</td></tr><tr><td>&#x2F;dev</td><td>类似于windows的设备管理器，把所有的硬件映射成文件</td></tr><tr><td>&#x2F;media</td><td>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下</td></tr><tr><td>&#x2F;mnt</td><td>系统提供该目录是为了让用户临时挂载别的文件系统（比如自己本机的文件系统）的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里面的内容了</td></tr><tr><td>&#x2F;opt</td><td>存储主机额外<strong>安装软件</strong>的目录。如安装ORACLE数据库就可放到该目录下。 默认为空</td></tr><tr><td>&#x2F;usr&#x2F;local</td><td>这是另一个存储主机额外<strong>安装软件</strong>，并给软件安装的目录。一般是通过编译源码方式安装的程序</td></tr><tr><td>&#x2F;var</td><td>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。 包括各种日志文件</td></tr><tr><td>&#x2F;selinux</td><td>SELinux是一个安全子系统，它能控制程序只能访问特定文件</td></tr></tbody></table><h1 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h1><p>三种模式：</p><ol><li>正常模式，可以使用快捷键，以 vim 打开一个文档就直接进入这个模式了(这是默认的模式)。在这个模式中， 你可以使用 『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、粘贴』来处理你的文件数据。</li><li>插入模式，输入i进入插入模式，可以输入内容。</li><li>命令行模式，可以提供你的相关指令，完成读取、存盘、替换、离开 vim 、显示行号等。</li></ol><ul><li>正常模式—-》插入模式，点击i键</li><li>插入模式—-》命令行模式，shift+:键</li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>输入wq，写入保存并退出</p><p>输入q，适用于打开看，不写入，退出用q</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041351521.png" alt="image-20211210115800354">若是写入，然后用q退出会显示此提示。</p><p>输入q!，强制退出，不保存直接退出</p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>正常模式下</p><ul><li>在光标下输入yy代表复制，5yy表示从光标位置起，复制五行，然后p代表粘贴</li><li>dd删除当前行，5dd代表删除光标位置起向下五行</li><li>gg，代表到达文件首行，G，代表到达文件末尾行</li><li>u，代表撤销刚刚输入的字符串</li><li>需要在显示行号了的情况下，20（光标要到达的行，20代表光标到达第20行），shift+g（跳到指定的行）</li></ul><p>命令行模式下</p><ul><li>输入&#x2F;hello，表示查找hello字符串，再输入n，表示查找下一个</li><li>输入:set nu，表示设置行号，:set nonu，表示取消行号</li></ul><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h3 id="关机-amp-重启命令"><a href="#关机-amp-重启命令" class="headerlink" title="关机&amp;重启命令"></a>关机&amp;重启命令</h3><p>shutdown -h now 表示立即关机<br>shutdown -h 1 表示1分钟后关机<br>shutdown -r now 立即重启<br>halt 表示关机<br>reboot 表示重启系统<br>sync 把内存的数据同步到磁盘上，保存数据</p><h3 id="用户登录与注销"><a href="#用户登录与注销" class="headerlink" title="用户登录与注销"></a>用户登录与注销</h3><p>logout 注销，退出登录账号，远程登录有效。</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h5 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h5><p>useradd [选项] 用户名          创建一个用户，未指定所属，<strong>默认创建一个组</strong>，该组名默认为该用户的用户名。</p><p>useradd -g 用户组 用户名    创建一个用户，并指定所属组</p><p>useradd -d &#x2F;home&#x2F;ss xq      创建一个用户，指定用户创建的目录</p><h5 id="指定-x2F-修改密码"><a href="#指定-x2F-修改密码" class="headerlink" title="指定&#x2F;修改密码"></a>指定&#x2F;修改密码</h5><p>passwd 用户名</p><h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><p>userdel 用户名     <strong>默认保留家目录</strong><br>userdel -r 用户名 <strong>连带删除家目录</strong></p><h5 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h5><p>id 用户名</p><h5 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h5><p>su - 用户名  切换用户<br>exit              返回到原来的用户</p><h5 id="查询当前用户"><a href="#查询当前用户" class="headerlink" title="查询当前用户"></a>查询当前用户</h5><p>whoami</p><h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><h5 id="增加用户组"><a href="#增加用户组" class="headerlink" title="增加用户组"></a>增加用户组</h5><p>groupadd 组名 </p><h5 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h5><p>groupdel 组名</p><h5 id="修改用户所属组"><a href="#修改用户所属组" class="headerlink" title="修改用户所属组"></a>修改用户所属组</h5><p>usermod -g 用户组 用户名</p><p>用户配置文件（用户信息）<br>&#x2F;etc&#x2F;passwd</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041352668.png" alt="image-20211210155537770"></p><p>组配置文件（组信息）<br>&#x2F;etc&#x2F;group</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041352440.png" alt="image-20211210155928205"></p><p>口令配置文件（密码和登录信息，加密的）<br>&#x2F;etc&#x2F;shadow</p><h3 id="linux运行级别"><a href="#linux运行级别" class="headerlink" title="linux运行级别"></a>linux运行级别</h3><p>运行级别说明： </p><p>0 ：关机<br>1 ：单用户【找回丢失密码】 （进入root，不需要密码即可登录）<br>2 ：多用户状态没有网络服务<br>3 ：多用户状态有网络服务<br>4 ：系统未使用保留给用户<br>5 ：图形界面<br>6 ：系统重启 </p><p>常用运行级别是3和5 ，要修改默认的运行级别可改文件 <strong>&#x2F;etc&#x2F;inittab</strong>的<strong>id:5:initdefault:这一行中的数字</strong> </p><p>命令：init [012356]</p><p><strong>系统运行级别配置文件：&#x2F;etc&#x2F;inittab</strong></p><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><p>man [命令或者配置文件]</p><p>help [命令]</p><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h3><ul><li><p>pwd 查看当前工作目录（显示的是绝对路径）</p></li><li><p>ls   [选项]  [目录或是文件]</p><ul><li>-a ：显示当前目录所有的文件和目录，包括隐藏的</li><li>-l ：以列表的方式显示信息</li></ul></li><li><p>cd [参数]</p><ul><li>cd ~ 或者cd        回到自己的家目录</li><li>cd ..                     回到当前目录的上一级目录</li></ul></li><li><p>mkdir [选项]  要创建的目录</p><ul><li>-p ：创建多级目录</li></ul></li><li><p>rmdir [选项] 要删除的空目录</p><p>提示：如果需要删除非空目录，需要使用 rm -rf 要删除的目录，-f表示强制删除，没有提示，-r表示递归地删除目录和它里面的内容</p></li><li><p>touch 文件名称1 文件名称2 …</p><p>创建一个空文件，可以一次性创建多个文件</p></li><li><p>cp [选项] source dest</p><p>-r：递归复制整个文件夹</p></li><li><p>\cp [选项] source dest</p><p>若dest有同名文件，则强制覆盖</p></li><li><p>rm [选项] 要删除的文件或目录</p><p>-f表示强制删除，没有提示，-r表示递归地删除目录和它里面的内容</p></li><li><p>mv  原文件名 目的地文件名</p><p>移动 文件与目录 或重命名</p></li></ul><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><ul><li><p>cat [选项] 要查看的文件 |more</p><ul><li>浏览文件，但是不能修改</li><li>-n 表示显示行号</li><li>|more可加或不加，表示分页，空格键跳到下一页</li></ul></li><li><p>more 要查看的文件</p><ul><li>浏览文件</li><li>空白键 (space) 代表向下翻一页</li><li>Enter 代表向下翻『一行』 </li><li>q 代表立刻离开 more ，不再显示该文件内容</li><li>Ctrl+F 向下滚动一屏 </li><li>Ctrl+B 返回上一屏 </li><li>&#x3D; 输出当前行的行号 </li><li>:f输出文件名和当前行的行号</li></ul></li><li><p>less 要查看的文件</p><ul><li>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据<strong>显示需要</strong>加载内容，对于显示大型文件具有较高的效率。</li><li>空白键代表向下翻动一页</li><li>[pagedown] 向下翻动一行</li><li>[pageup] 向上翻动一行</li><li>&#x2F;字串 向下搜寻『字串』的功能；n：向下查找；N：向上查找</li><li>?字串 向上搜寻『字串』的功能；n：向上查找；N：向下查找 </li><li>q 离开 less 这个程序</li></ul></li><li><p>&gt;覆盖写指令</p><ul><li>ls -l &gt; a.txt 将ls -l指令显示的内容覆盖写入到a.txt，若a.txt不存在，则创建此文件；若存在，直接覆盖此文件</li></ul></li><li><p>&gt;&gt;追加写指令</p><ul><li>ls -l &gt;&gt; a.txt 将ls -l指令显示的内容追加写入到a.txt，若a.txt不存在，则创建此文件；若存在，直接覆盖此文件</li></ul></li><li><p>echo [选项] [输出内容]</p><ul><li>echo $PATH输出环境变量<img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041353620.png" alt="image-20211210192809571"></li></ul></li><li><p>cal</p><p>输出日历<img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041352046.png" alt="image-20211210192541104"></p></li><li><p>head  文件</p><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容<br>-n 5 指定显示开头前5行</p></li><li><p>tail 文件 </p><p>与head用法相同，-f 表示实时追踪该文档的所有更新</p></li><li><p>ln -s [原文件或目录] [软链接名] </p><p>软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径<br>该指令给原文件创建一个软链接，删除软链接用rm -rf </p></li><li><p>history </p><p>查看已经执行过的历史命令,也可以执行历史指令<br>后面加数字代表查看多少个命令，比如history 5，查看最后五条命令<br>!+编号，表示执行第几条指令。<img src="/./image-20211210194251957.png" alt="image-20211210194251957"></p></li><li><table><thead><tr><th>日期时间指令</th><th>功能</th></tr></thead><tbody><tr><td>date</td><td>功能描述：显示当前时间</td></tr><tr><td>date +%Y</td><td>功能描述：显示当前年份</td></tr><tr><td>date +%m</td><td>功能描述：显示当前月份</td></tr><tr><td>date +%d</td><td>功能描述：显示当前是哪一天</td></tr><tr><td>date “+%Y-%m-%d %H:%M:%S”</td><td>功能描述：显示年月日时分秒</td></tr><tr><td>date -s 字符串时间</td><td>功能描述：设置系统时间<br />date -s “2018-10-10 11:22:22”</td></tr><tr><td>cal 2020</td><td>功能描述：显示2020年日历</td></tr><tr><td>cal</td><td>功能描述：显示本月日历</td></tr></tbody></table></li></ul><h3 id="搜索查找指令"><a href="#搜索查找指令" class="headerlink" title="搜索查找指令"></a>搜索查找指令</h3><ul><li><p>find [搜索范围] [选项]</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name 文件名</td><td>按照指定的<strong>文件名</strong>查找文件</td></tr><tr><td>-user   用户名</td><td>查找属于指定<strong>用户名</strong>的所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件，文件大小后加 +n代表大于n， -n代表小于n，n代表等于n</td></tr></tbody></table></li><li><p>locate 搜索文件</p><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径 的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。 为了保证查询结果的准确度，管理员必须定期更新locate时刻。<br><strong>第一次运行前，必须使用updatedb指令创建locate数据库</strong></p></li><li><p>|管道符号，表示将前一个命令的处理结果输出传递给后面的命令处理</p></li><li><p>grep [选项]  查找内容  原文件</p><ul><li>过滤查找</li><li>-n，显示匹配行及行号</li><li>-i，忽略字母大小写</li></ul></li></ul><h3 id="压缩和解压缩指令"><a href="#压缩和解压缩指令" class="headerlink" title="压缩和解压缩指令"></a>压缩和解压缩指令</h3><ul><li><p>gzip&#x2F;gunzip指令，gzip用来压缩，生成.gz后缀的压缩文件，gunzip用来解压缩，不会保留原来的文件</p></li><li><p>zip&#x2F;unzip指令，zip用来压缩，unzip用来解压缩</p><ul><li>zip [选项] XXX.zip 要压缩的文件，-r表示递归压缩，即压缩目录</li><li>unzip [选项] XXX.zip，-d 目录，指定解压后文件的存放目录</li></ul></li><li><p>tar指令，最后打包后的文件后缀是.tar.gz的文件</p><ul><li><p>tar [选项] XXX.tar.gz 打包的内容 </p></li><li><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解压.tar文件</td></tr><tr><td>-C</td><td>解压到指定目录（目录必须存在）</td></tr></tbody></table></li></ul></li></ul><h3 id="查看文件所属用户和组"><a href="#查看文件所属用户和组" class="headerlink" title="查看文件所属用户和组"></a>查看文件所属用户和组</h3><p>ls -ahl</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041354494.png" alt="image-20211212145753264"></p><h3 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h3><p>chown 用户名 文件名</p><h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><p>chgrp 组名 文件名或者目录</p><p>-R代表把该目录下所有文件或目录所属组修改成该组</p><h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><p>usermod -g 组名 用户名</p><h3 id="改变用户登录的初始目录"><a href="#改变用户登录的初始目录" class="headerlink" title="改变用户登录的初始目录"></a>改变用户登录的初始目录</h3><p>usermod -d 目录名 用户名</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041354080.png" alt="image-20211212150935335">第一位如果是，-代表普通文件，d代表目录，l代表软链接，c代表字符设备（鼠标、键盘)，b代表块文件，硬盘<br>rwx表示文件所有者的权限，r代表read（r&#x3D;4)，w代表写（w&#x3D;2)，x代表执行（x&#x3D;1)，-代表忽略<br>r-x表示文件所在组的用户的权限<br>r-x表示文件其他组的用户的权限<br>如果是文件，表示硬链接的数，如果是目录则表示该目录的子目录个数</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041354396.png" alt="image-20211212151812594"></p><p>文件所属用户，文件所属用户组，文件的大小（如果是目录，显示4096），文件最后修改时间，文件名</p><h3 id="修改文件的权限"><a href="#修改文件的权限" class="headerlink" title="修改文件的权限"></a>修改文件的权限</h3><p>u：所有者     g：所有组     o：其他人    a：所有人<br>chmod u&#x3D;rwx，g&#x3D;rx，o&#x3D;x     文件目录名<br>chmod o+w 文件目录名    &#x2F;&#x2F;增加一个权限<br>chmod a-x   文件目录名    &#x2F;&#x2F;减少一个权限<br>chmod 777 文件名</p><h3 id="改变文件所有者"><a href="#改变文件所有者" class="headerlink" title="改变文件所有者"></a>改变文件所有者</h3><p>chown 文件所有者  文件或目录<br>chown 文件所有者:文件所有组 文件或目录<br>-R，代表递归改变该目录下所有文件或目录的所有者</p><h3 id="定时调用脚本或指令"><a href="#定时调用脚本或指令" class="headerlink" title="定时调用脚本或指令"></a>定时调用脚本或指令</h3><ol><li>crontab -e，crontab [选项]<img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041355285.png" alt="image-20211212155934592"></li><li>*&#x2F;1 * * * *  ls –l &#x2F;etc&#x2F;  &gt;&gt;  &#x2F;tmp&#x2F;to.txt   <img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041355051.png" alt="image-20211212160048137"></li><li><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041355575.png" alt="image-20211212160218459"></li></ol><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041355369.png" alt="image-20211212160609927"></p><h3 id="重启任务调度"><a href="#重启任务调度" class="headerlink" title="重启任务调度"></a>重启任务调度</h3><p>service crond restart</p><h1 id="linux分区"><a href="#linux分区" class="headerlink" title="linux分区"></a>linux分区</h1><h3 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h3><h4 id="分区的方式："><a href="#分区的方式：" class="headerlink" title="分区的方式："></a>分区的方式：</h4><ol><li><p>mbr分区: </p><ol><li>最多支持四个主分区 </li><li>系统只能安装在主分区 </li><li>扩展分区要占一个主分区 </li><li>MBR最大只支持2TB，但拥有最好的兼容性</li></ol></li><li><p>gtp分区: </p><p>1.支持无限多个主分区（但操作系统可能限制，比如 windows下最多128个分区） </p><p>2.最大支持18EB的大容量（1EB&#x3D;1024 PB，1PB&#x3D;1024 TB ） </p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041356553.png" alt="image-20211212162709851"></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041356091.png" alt="image-20211212162720067"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041356706.png" alt="image-20211212162730451"></p><h3 id="查看系统的分区和挂载的情况"><a href="#查看系统的分区和挂载的情况" class="headerlink" title="查看系统的分区和挂载的情况"></a>查看系统的分区和挂载的情况</h3><p>lsblk -f</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041356203.png" alt="image-20211212163022101"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041356976.png" alt="image-20211212163119788"></p><p>NAME分区名字或分区标识，FSTYPE分区类型，LABEL标签，UUID唯一标识该分区的字符串，MOUNTPOINT挂载点</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041357630.png" alt="image-20211212163835732"></p><h3 id="增加一个硬盘"><a href="#增加一个硬盘" class="headerlink" title="增加一个硬盘"></a>增加一个硬盘</h3><ol><li>新增一个硬盘</li><li>分区 fdisk &#x2F;dev&#x2F;sdb</li><li>格式化磁盘 mkfs -t ext4 &#x2F;dev&#x2F;sdb1</li><li>挂载 mount &#x2F;dev&#x2F;sdb1 &#x2F;newdisk，卸载为umount  &#x2F;dev&#x2F;sdb1或umount &#x2F;newdisk</li><li>自动挂载vim &#x2F;etc&#x2F;fstab，执行mount -a即刻生效</li></ol><h3 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h3><p>df -h</p><h3 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h3><p>du -h 目录</p><ul><li>-s指定目录占用大小汇总</li><li>-h带计量单位</li><li>-a含文件</li><li>-c列出明细的同时，增加汇总值</li><li>–max-depth&#x3D;1 子目录深度</li></ul><h3 id="统计-x2F-home文件夹下文件的个数"><a href="#统计-x2F-home文件夹下文件的个数" class="headerlink" title="统计&#x2F;home文件夹下文件的个数"></a>统计&#x2F;home文件夹下文件的个数</h3><p>ls -l &#x2F;home |grep “^-“|wc -l</p><h3 id="统计-x2F-home文件夹下目录的个数"><a href="#统计-x2F-home文件夹下目录的个数" class="headerlink" title="统计&#x2F;home文件夹下目录的个数"></a>统计&#x2F;home文件夹下目录的个数</h3><p>ls -l &#x2F;home |grep “^d”|wc -l </p><h3 id="统计-x2F-home文件夹下文件的个数，包括子文件夹里的"><a href="#统计-x2F-home文件夹下文件的个数，包括子文件夹里的" class="headerlink" title="统计&#x2F;home文件夹下文件的个数，包括子文件夹里的"></a>统计&#x2F;home文件夹下文件的个数，包括子文件夹里的</h3><p>ls -lR &#x2F;home |grep “^-“ | wc -l </p><h3 id="统计文件夹下目录的个数，包括子文件夹里的"><a href="#统计文件夹下目录的个数，包括子文件夹里的" class="headerlink" title="统计文件夹下目录的个数，包括子文件夹里的"></a>统计文件夹下目录的个数，包括子文件夹里的</h3><p>ls -lR &#x2F;home |grep “^d” | wc -l </p><h3 id="以树状显示目录结构"><a href="#以树状显示目录结构" class="headerlink" title="以树状显示目录结构"></a>以树状显示目录结构</h3><p>tree</p><h3 id="修改IP为固定IP"><a href="#修改IP为固定IP" class="headerlink" title="修改IP为固定IP"></a>修改IP为固定IP</h3><p>说明：直接修改配置文件来指定IP,并可以连接到外网(程序员推荐)，编辑 vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</p><p>&#x2F;etc&#x2F;sysctl.d&#x2F;10-network-security.conf（ubuntu）</p><p>要求：将ip地址配置的静态的，ip地址为192.168.184.130</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041357676.png" alt="image-20211213144454454"></p><h3 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h3><p>ps -aux</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041357342.png" alt="image-20211213145654963"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041358231.png" alt="image-20211213145355762"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041358258.png" alt="image-20211213145406593"></p><h3 id="查看进程及其父进程"><a href="#查看进程及其父进程" class="headerlink" title="查看进程及其父进程"></a>查看进程及其父进程</h3><p>ps -ef<br>ps -ef是以全格式显示当前所有的进程 </p><ul><li>-e 显示所有进程</li><li>-f 全格式</li></ul><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>kill [选项] 进程号（功能描述：通过进程号杀死进程） </p><p>killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</p><p>常用选项：<br>-9 :表示强迫进程立即停止</p><h3 id="终止用户"><a href="#终止用户" class="headerlink" title="终止用户"></a>终止用户</h3><p>ps -aux | grep sshd</p><p>kill 进程号</p><h3 id="终止远程登录"><a href="#终止远程登录" class="headerlink" title="终止远程登录"></a>终止远程登录</h3><p>ps -aux |grep sshd</p><p>kill 进程号</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041358858.png" alt="image-20211213151541441"></p><h3 id="杀掉终端"><a href="#杀掉终端" class="headerlink" title="杀掉终端"></a>杀掉终端</h3><p>ps -aux|grep bash</p><p>kill -9 进程号</p><h3 id="以树状形式展示进程信息"><a href="#以树状形式展示进程信息" class="headerlink" title="以树状形式展示进程信息"></a>以树状形式展示进程信息</h3><p>pstree [选项] ,可以更加直观的来看进程信息</p><p>常用选项： </p><ul><li>-p :显示进程的PID </li><li>-u :显示进程的所属用户</li></ul><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>systemctl status firewalld<br>查看防火墙状态</p><p>查看所有服务</p><p> systemctl list-unit-files</p><h5 id="systemctl-动作-服务名-service"><a href="#systemctl-动作-服务名-service" class="headerlink" title="systemctl 动作 服务名.service"></a>systemctl 动作 服务名.service</h5><p>systemctl start httpd.service        &#x2F;&#x2F;启动 Apache httpd</p><p>systemctl restart httpd.service    &#x2F;&#x2F;重新启动</p><p>systemctl stop httpd.service        &#x2F;&#x2F;停止服务</p><p>systemctl enable httpd.service    &#x2F;&#x2F;开机启动 httpd</p><p>systemctl disable httpd.service   &#x2F;&#x2F;禁止开机启动 httpd</p><p>systemctl status httpd.service     &#x2F;&#x2F;httpd 当前状态</p><h3 id="打开网络设置"><a href="#打开网络设置" class="headerlink" title="打开网络设置"></a>打开网络设置</h3><p>nmtui</p><h3 id="监视进程"><a href="#监视进程" class="headerlink" title="监视进程"></a>监视进程</h3><p>top<br><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041358700.png" alt="image-20211213161842288"></p><ul><li>输入u，然后输入用户名，监视指定用户进程</li><li>输入k，然后输入进程号，杀死特定进程</li><li>输入P，以CPU使用率排序</li><li>输入M，以内存使用率排序</li><li>输入N，以PID排序</li><li>q退出</li></ul><p>top -d 10 代表每10秒刷新一次</p><h3 id="查看系统网络情况"><a href="#查看系统网络情况" class="headerlink" title="查看系统网络情况"></a>查看系统网络情况</h3><p>netstat [选项]</p><p>-an 按一定顺序排列输出<br>-p   显示哪个进程在调用</p><h3 id="查询电脑安装的所有包"><a href="#查询电脑安装的所有包" class="headerlink" title="查询电脑安装的所有包"></a>查询电脑安装的所有包</h3><h4 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h4><p>rpm -qa<br>-qa代表查询所有</p><p>rpm -q   包名<br>查询软件包是否安装</p><p>rpm -qi  包名<br>查询包的详细信息</p><p>rpm -ql  包名<br>查询包的文件安装在哪里，安装了什么文件</p><p>rpm -qf  文件名<br>查询此文件属于哪个软件包</p><p>rpm -e 包名<br>删除指定包<br><strong>当其他包依赖此包时，删除会出现提示，可以使用rpm -e –nodeps 包名</strong></p><p>rpm -ivh 包全路径名称</p><ul><li>i&#x3D;install 安装</li><li>v&#x3D;verbose 提示</li><li>h&#x3D;hash 进度条</li></ul><p>dvd文件在&#x2F;run&#x2F;media&#x2F;用户名下</p><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>yum list|grep 软件名<br>查询你要安装的软件在yum服务器上有没有</p><p>yum install 软件名<br>安装所需要的包（默认安装最新版本）</p><h5 id="配置环境变量在-x2F-etc-x2F-profile，输入这三行"><a href="#配置环境变量在-x2F-etc-x2F-profile，输入这三行" class="headerlink" title="配置环境变量在&#x2F;etc&#x2F;profile，输入这三行"></a>配置环境变量在&#x2F;etc&#x2F;profile，输入这三行</h5><p>​    JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdk1.7.0_79 </p><p>​    PATH&#x3D;&#x2F;opt&#x2F;jdk1.7.0_79&#x2F;bin:$PATH </p><p>​    export JAVA_HOME PATH</p><h3 id="防火墙配置在-x2F-etc-x2F-sysconfig-x2F-firewalld"><a href="#防火墙配置在-x2F-etc-x2F-sysconfig-x2F-firewalld" class="headerlink" title="防火墙配置在&#x2F;etc&#x2F;sysconfig&#x2F;firewalld"></a>防火墙配置在&#x2F;etc&#x2F;sysconfig&#x2F;firewalld</h3><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041359673.png" alt="image-20211213202417573"></p><p>开头格式#!&#x2F;bin&#x2F;bash，告知系统以这个来解析</p><h3 id="Shell的变量的介绍"><a href="#Shell的变量的介绍" class="headerlink" title="Shell的变量的介绍"></a>Shell的变量的介绍</h3><p>1.Linux Shell中的变量分为系统变量和用户自定义变量。 </p><p>2.系统变量：$HOME、$PWD、$SHELL、$USER等等，比如： echo $HOME 等等.. </p><p>3.显示当前shell中所有变量：set</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041359858.png" alt="image-20211213202859881"></p><h3 id="shell变量的定义"><a href="#shell变量的定义" class="headerlink" title="shell变量的定义"></a>shell变量的定义</h3><ol><li>基本语法 <ul><li>定义变量：变量&#x3D;值 </li><li>撤销变量：unset 变量 </li><li>声明静态变量：readonly变量，注意：不能unset</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041359492.png" alt="image-20211213203423331"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041359899.png" alt="image-20211213203523532"></p><h3 id="定义变量的规则"><a href="#定义变量的规则" class="headerlink" title="定义变量的规则"></a>定义变量的规则</h3><ul><li><p>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。 </p></li><li><p>等号两侧不能有空格 </p></li><li><p>变量名称一般习惯为大写</p></li></ul><h3 id="将命令的返回值赋给变量"><a href="#将命令的返回值赋给变量" class="headerlink" title="将命令的返回值赋给变量"></a>将命令的返回值赋给变量</h3><ul><li><p>A&#x3D;`ls -la` 反引号，运行里面的命令，并把结果返回给变量A </p></li><li><p>A&#x3D;$(ls -la) 等价于反引号</p></li></ul><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><ol><li>export 变量名&#x3D;变量值 （功能描述：将shell变量输出为环境变量） </li><li>source 配置文件 （功能描述：让修改后的配置信息立即生效） </li><li>echo $变量名 （功能描述：查询环境变量的值）</li></ol><p>#单行注释<br>:&lt;&lt;!多行注释!</p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量，比如 ： .&#x2F;myshell.sh 100 200 , 这个就是一个执行shell的命令行，可以在myshell 脚本中获取到参数信息 </p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>$n （功能描述：n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10} ） </p><p>$* （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体） </p><p>$@（功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待） </p><p>$#（功能描述：这个变量代表命令行中所有参数的个数） </p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041400748.png" alt="image-20211213205125146"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041400977.png" alt="image-20211213205137049"></p><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用 </p><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>$$ （功能描述：当前进程的进程号（PID）） </p><p>$!  （功能描述：后台运行的最后一个进程的进程号（PID）） </p><p>$? （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</p><p><strong>.&#x2F;myShell.sh &amp; 代表以后台的方式执行myShell.sh</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041400158.png" alt="image-20211213210415684"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041400296.png" alt="image-20211213210348273"></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>学习如何在shell中进行各种运算操作。 </p><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><ol><li>“$((运算式))”或“$[运算式]”          比如：$(((2+3)*2))，$[(2+3)*2]</li><li>expr m + n 注意expr运算符间要有空格  比如：TEMP&#x3D;<code>expr 2 + 3 </code></li><li>expr m - n </li><li>expr *, &#x2F;, % 乘，除，取余</li></ol><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h3><ol><li>[ condition ]（注意condition前后要有空格） </li><li>[]里的内容非空返回true，可使用$?验证（0为true，&gt;1为false）</li></ol><h3 id="常用判断条件"><a href="#常用判断条件" class="headerlink" title="常用判断条件"></a>常用判断条件</h3><ol><li><p>两个整数的比较 </p><ul><li><p>&#x3D; 字符串比较 </p></li><li><p>-lt 小于 </p></li><li><p>-le 小于等于 </p></li><li><p>-eq 等于 </p></li><li><p>-gt 大于 </p></li><li><p>-ge 大于等于 </p></li><li><p>-ne 不等于</p></li></ul></li><li><p>按照文件权限进行判断 </p><ul><li><p>-r 有读的权限[ -r 文件名 ]</p></li><li><p>-w 有写的权限 </p></li><li><p>-x 有执行的权限</p></li></ul></li><li><p>按照文件类型进行判断 </p><ul><li><p>-f 文件存在并且是一个常规的文件 </p></li><li><p>-e 文件存在  <img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041400755.png" alt="image-20211213212637432"></p></li><li><p>-d 文件存在并是一个目录</p></li></ul></li></ol><p><strong>if 判断</strong> </p><p>• 基本语法</p><p> if   [ 条件判断式 ]</p><p>then     程序 </p><p>fi </p><p>或者 </p><p>if   [ 条件判断式 ] </p><p>then     程序 </p><p>elif  [条件判断式] </p><p>then     程序 </p><p>fi </p><p>注意事项：</p><ol><li>[ 条件判断式 ]，中括号和条件判断式之间必须有空格 </li><li>推荐使用第二种方式</li></ol><p><strong>case语句</strong> </p><p>• 基本语法 </p><p>case $变量名 in </p><p>“值1”） </p><p>如果变量的值等于值1，则执行程序1 </p><p>;; </p><p>“值2”） </p><p>如果变量的值等于值2，则执行程序2 </p><p>;; </p><p>…省略其他分支… </p><p>*） </p><p>如果变量的值都不是以上的值，则执行此程序 </p><p>;; </p><p>esac</p><p><strong>for循环</strong> </p><p>• 基本语法1 </p><p>for 变量 in 值1 值2 值3… </p><p>​    do </p><p>​        程序 </p><p>​    done </p><p>• 基本语法2 </p><p>for (( 初始值;循环控制条件;变量变化 )) </p><p>​    do </p><p>​        程序 </p><p>​    done</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041401824.png" alt="image-20211213214041812"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041401357.png" alt="image-20211213214126334"></p><p><strong>while循环</strong> </p><p>• 基本语法</p><p>while [ 条件判断式 ] </p><p>​    do </p><p>​        程序 </p><p>​    done</p><h3 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a><strong>read读取控制台输入</strong></h3><p><strong>基本语法</strong> </p><p>read  选项  参数  </p><p><strong>选项：</strong> </p><p>-p：指定读取值时的提示符； </p><p>-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了</p><p>**参数 **</p><p>变量：指定读取值的变量名</p><p>举例：</p><p>read -t 100 -p “wuhu”  NUM1</p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p><strong>shell编程和其它编程语言一样，有系统函数，也可以自定义函数。</strong></p><p>系统函数中， 我们这里就介绍两个。 </p><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><p><strong>• basename基本语法</strong> </p><p>功能：返回完整路径最后 &#x2F; 的部分，常用于获取文件名 </p><p>basename [pathname] [suffix] </p><p>basename [string] [suffix] （功能描述：basename命令会删掉所有的前缀包括最后一个（‘&#x2F;’） 字符，然后将字符串显示出来。 </p><p>选项： suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041401036.png" alt="image-20211213215138936"></p><p> <strong>• dirname基本语法</strong> </p><p>功能：返回完整路径最后 &#x2F; 的前面的部分，常用于返回路径部分 </p><p>dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分）， 然后返回剩下的路径（目录的部分））</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><strong>• 基本语法</strong> </p><p>[ function ] funname[()] </p><p>{ </p><p>​        Action; </p><p>​        [return int;] </p><p>} </p><p>调用直接写函数名：funname [值]</p><p>举例：</p><p>function getSum(){</p><p>​            SUM&#x3D;$[$n1+$n2]<br>​            echo “$SUM”</p><p>} </p><p>n1&#x3D;2<br>n2&#x3D;3<br>getSum $n1 $n2</p><h2 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a>curl 命令</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>curl 命令在 Linux 操作系统中经常来测试网络和 url 的联通性，模拟正常的网络访问。除此之外，curl 还支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件等功能。</p><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2 常用方法"></a>2 常用方法</h3><ol><li><strong>curl url</strong>(获取网址的文本信息)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.baidu.com</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>curl -i url</strong>(获取文本的头部及文本信息)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i www.baidu.com</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>curl -x proxy url</strong>(使用代理请求网页内容)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -x 0.0.0.0 www.baidu.com</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>curl -v</strong>(获取整个通信过程)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v www.baidu.com</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>curl -X url</strong>(使用特定方法请求网页文本)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET www.baidu.com</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>curl -I url</strong>(仅返回头部信息)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="GCC编译常用选项"><a href="#GCC编译常用选项" class="headerlink" title="GCC编译常用选项"></a>GCC编译常用选项</h2><ul><li>-o file 指定输出文件为file</li><li>-g  在可执行程序中包含标准调试信息</li><li>-E 只进行预处理，不做其他处理</li><li>-S 只编译不汇编，生成汇编代码</li><li>-c  预处理、编译、汇编源文件，但是不链接，生成目标文件</li><li>-I dir   在头文件的搜索路径列表中添加dir目录</li><li>-L path 把指定目录path加到链接程序搜索库文件的路径表中</li><li>-lname 如果一个库文件名称为libname.a，程序执行时若要连接这个库文件，就要使用该选项进行连接，省略库名中的前缀“lib”和后缀“.a”。</li><li>-Wall  允许发出GCC提供的所有有用的报警信息</li></ul><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2><p>注意gcc编译时一定要加上选项“-g”，这样可执行代码中才包含调试信息，否则之后gdb无法载入该可执行文件</p><ul><li>查看文件命令  list              </li><li>设置断点命令  break</li><li>查看断点处情况 information      </li><li>运行命令  run</li><li>查看变量命令  print             </li><li>观察变量命令  watch</li><li>单步运行命令  next 或step       </li><li>继续运行命令  continue</li><li>退出命令  quit</li></ul><p>vMake工程管理器</p><ul><li>能够根据文件时间戳自动发现更新过的文件，从而减少编译工作量；</li><li>能够通过读入Makefile文件的内容来执行大量的编译工作，提高了项目的工作效率</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C高级</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/windows%E5%BC%80%E5%8F%91/c%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/windows%E5%BC%80%E5%8F%91/c%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="堆分配内存API："><a href="#堆分配内存API：" class="headerlink" title="堆分配内存API："></a>堆分配内存API：</h2><p> #include &lt;stdlib.h&gt;  </p><p>void <em><strong><strong>calloc</strong>(<strong>size_t nmemb</strong>,</strong> size_t size</em><em>);</em>*  </p><p>功能：  在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存置0。  </p><p>参数：  </p><p>​    nmemb：所需内存单元数量  </p><p>​    size：每个内存单元的大小（单位：字节）  </p><p>返回值：    </p><p>​    成功：分配空间的起始地址  </p><p>​    失败：NULL  </p><p> #include &lt;stdlib.h&gt;  </p><p>void **<strong><em>realloc</em>*(*<em>void <em><strong><strong>ptr</strong>,</strong> size_t size</em></em>);</strong>  </p><p>功能：  重新分配用malloc或者calloc函数在堆中分配内存空间的大小。  realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。  </p><p>参数：  </p><p>​    ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致 </p><p>​    size：为重新分配内存的大小**,** 单位：字节  </p><p>返回值：  </p><p>​    成功：新分配的堆内存地址  </p><p>​    失败：NULL  </p><h2 id="手动设置对齐模数"><a href="#手动设置对齐模数" class="headerlink" title="手动设置对齐模数:"></a>手动设置对齐模数:</h2><p> <strong>#pragma  pack(show)</strong>  </p><p>显示当前packing alignment的字节数，以warning message的形式被显示。  </p><p><strong>#pragma pack(n)</strong>  </p><p>指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT</span>&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line"><span class="type">float</span> d;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STUDENT2</span>&#123;</span></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line">Student b; </span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line">&#125;Student2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//a从偏移量0位置开始存储</span></span><br><span class="line"><span class="comment">//b从4位置开始存储</span></span><br><span class="line"><span class="comment">//c从8位置开始存储</span></span><br><span class="line"><span class="comment">//d从16位置开存储</span></span><br><span class="line"><span class="comment">//所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof Student:%d\n&quot;</span>,<span class="keyword">sizeof</span>(Student));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student2 </span></span><br><span class="line"><span class="comment">//a从偏移量为0位置开始 </span></span><br><span class="line"><span class="comment">//b从偏移量为Student内部最大成员整数倍开始，也就是8开始</span></span><br><span class="line"><span class="comment">//c从8的整数倍地方开始,也就是32开始</span></span><br><span class="line"><span class="comment">//所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof Student2:%d\n&quot;</span>, <span class="keyword">sizeof</span>(Student2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>  <span class="title function_">p</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;  <span class="comment">//p为函数类型，类似的还有 typedef void pp(int)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">  p p1; <span class="comment">//p1(10,20); //错误，不能直接调用，只描述了函数类型，但是并没有定义函数体，没有函数体无法调用</span></span><br><span class="line"></span><br><span class="line">  p* p2 = my_func;</span><br><span class="line"></span><br><span class="line">  p2(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//正确，指向有函数体的函数入口地址</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func01</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func01:%d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func02</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func02:%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func03</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func03:%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义函数指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>(*func_array[])(<span class="type">int</span>) = &#123; func01, func02, func03 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>(*func_array[<span class="number">3</span>])(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">  func_array[<span class="number">0</span>] = func01;</span><br><span class="line"></span><br><span class="line">  func_array[<span class="number">1</span>] = func02;</span><br><span class="line"></span><br><span class="line">  func_array[<span class="number">2</span>] = func03;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line"></span><br><span class="line">    func_array[i](<span class="number">10</span> + i);</span><br><span class="line"></span><br><span class="line">    (*func_array[i])(<span class="number">10</span> + i);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-宏定义"><a href="#2-宏定义" class="headerlink" title=".2 宏定义"></a>.2 宏定义</h2><h3 id="11-2-1-无参数的宏定义-宏常量"><a href="#11-2-1-无参数的宏定义-宏常量" class="headerlink" title="11.2.1 无参数的宏定义(宏常量)"></a>11.2.1 无参数的宏定义(宏常量)</h3><p>如果在程序中大量使用到了100这个值，那么为了方便管理，我们可以将其定义为：</p><p>const int num &#x3D; 100; 但是如果我们使用num定义一个数组，在不支持c99标准的编译器上是不支持的，因为num不是一个编译器常量，如果想得到了一个编译器常量，那么可以使用：</p><p>#define num 100</p><p>在编译预处理时，将程序中在该语句以后出现的所有的num都用100代替。这种方法使用户能以一个简单的名字代替一个长的字符串，在预编译时将宏名替换成字符串的过程称为“宏展开”。宏定义，只在宏定义的文件中起作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">double</span> r = <span class="number">10.0</span>;    </span><br><span class="line">    <span class="type">double</span> s = PI * r * r;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = %lf\n&quot;</span>, s);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>说明：</p><p>\1)   宏名一般用大写，以便于与变量区别；</p><p>\2)   宏定义可以是常数、表达式等；</p><p>\3)   宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错；</p><p>\4)   宏定义不是C语言，不在行末加分号；</p><p>\5)   宏名有效范围为从定义到本源文件结束；</p><p>\6)   可以用#undef命令终止宏定义的作用域；</p><p>\7)   在宏定义中，可以引用已定义的宏名；</p><h3 id="11-2-2-带参数的宏定义-宏函数"><a href="#11-2-2-带参数的宏定义-宏函数" class="headerlink" title="11.2.2 带参数的宏定义(宏函数)"></a>11.2.2 带参数的宏定义(宏函数)</h3><p>在项目中，经常把一些短小而又频繁使用的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。</p><p>宏通过使用参数，可以创建外形和作用都与函数类似地类函数宏(function-like macro). 宏的参数也用圆括号括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SUM(x,y) (( x )+( y ))  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;        </span><br><span class="line">    <span class="comment">//仅仅只是做文本替换 下例替换为 </span></span><br><span class="line">    <span class="comment">//int  ret = ((10)+(20));不进行计算    </span></span><br><span class="line">    <span class="type">int</span> ret = SUM(<span class="number">10</span>, <span class="number">20</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>,ret);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>注意:</p><p>\1)   宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格；</p><p>\2)   用括号括住每一个参数，并括住宏的整体定义。</p><p>\3)   用大写字母表示宏的函数名。</p><p>\4)   如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。</p><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041348462.jpg" alt="clip_image002-16400155394191"></p><h2 id="一些特殊的预定宏"><a href="#一些特殊的预定宏" class="headerlink" title="一些特殊的预定宏"></a>一些特殊的预定宏</h2><p>C编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __FILE__    宏所在文件的源文件名   </span></span><br><span class="line"><span class="comment">// __LINE__    宏所在行的行号  </span></span><br><span class="line"><span class="comment">// __DATE__    代码编译的日期  </span></span><br><span class="line"><span class="comment">// __TIME__    代码编译的时间     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>  </span><br><span class="line">&#123;    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __FILE__);    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, __LINE__);    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __DATE__);    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __TIME__);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="windows下静态库创建和使用"><a href="#windows下静态库创建和使用" class="headerlink" title="windows下静态库创建和使用"></a>windows下静态库创建和使用</h2><h3 id="静态库的创建"><a href="#静态库的创建" class="headerlink" title="静态库的创建"></a>静态库的创建</h3><p>1.创建一个新项目，在已安装的模板中选择“常规”，在右边的类型下选择“空项目”，在名称和解决方案名称中输入staticlib。点击确定。</p><p>2.在解决方案资源管理器的头文件中添加,mylib.h文件，在源文件添加mylib.c文件（即实现文件）。</p><p>3.在mylib.h文件中添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_H  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_H     </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">myadd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure><p>4.在mylib.c文件中添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;test.h&quot;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">myadd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>5.配置项目属性。因为这是一个静态链接库，所以应在项目属性的“配置属性”下选择“常规”，在其下的配置类型中选择“静态库（.lib）。</p><p>6.编译生成新的解决方案，在Debug文件夹下会得到mylib.lib (对象文件库），将该.lib文件和相应头文件给用户，用户就可以使用该库里的函数了。</p><h3 id="12-2-2-静态库的使用"><a href="#12-2-2-静态库的使用" class="headerlink" title="12.2.2 静态库的使用"></a>12.2.2 静态库的使用</h3><p><strong>方法一：配置项目属性</strong></p><p>  A、添加工程的头文件目录：工程—属性—配置属性—c&#x2F;c++—常规—附加包含目录：加上头文件存放目录。  B、添加文件引用的lib静态库路径：工程—属性—配置属性—链接器—常规—附加库目录：加上lib文件存放目录。  C 然后添加工程引用的lib文件名：工程—属性—配置属性—链接器—输入—附加依赖项：加上lib文件名。  </p><p><strong>方法二：使用编译语句</strong></p><p>  #pragma  comment(lib,”.&#x2F;mylib.lib”)  </p><p><strong>方法三：添加工程中</strong></p><p>  就像你添加.h和.c文件一样,把lib文件添加到工程文件列表中去.  切换到”解决方案视图”,—&gt;选中要添加lib的工程–&gt;点击右键–&gt;”添加”–&gt;”现有项”–&gt;选择lib文件–&gt;确定.  </p><h3 id="12-2-3-静态库优缺点"><a href="#12-2-3-静态库优缺点" class="headerlink" title="12.2.3 静态库优缺点"></a>12.2.3 静态库优缺点</h3><ul><li><p>静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；</p></li><li><p>程序在运行时与函数库再无瓜葛，移植方便。  </p></li><li><p>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</p></li></ul><h2 id="windows下动态库创建和使用"><a href="#windows下动态库创建和使用" class="headerlink" title="windows下动态库创建和使用"></a>windows下动态库创建和使用</h2><p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。</p><h3 id="12-3-1-动态库的创建"><a href="#12-3-1-动态库的创建" class="headerlink" title="12.3.1 动态库的创建"></a>12.3.1 动态库的创建</h3><ol><li>创建一个新项目，在已安装的模板中选择“常规”，在右边的类型下选择“空项目”，在名称和解决方案名称中输入mydll。点击确定。</li><li>在解决方案资源管理器的头文件中添加mydll.h文件，在源文件添加mydll.c文件（即实现文件）。</li><li>在test.h文件中添加如下代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_H  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_H     </span></span><br><span class="line">__declspec(dllexport) <span class="type">int</span> <span class="title function_">myminus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure><p>​    4.在test.c文件中添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;test.h&quot;</span>  </span></span><br><span class="line">__declspec(dllexport) <span class="type">int</span> <span class="title function_">myminus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">return</span> a - b;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="5"><li>配置项目属性。因为这是一个动态链接库，所以应在项目属性的“配置属性”下选择“常规”，在其下的配置类型中选择“动态库（.dll）</li><li>编译生成新的解决方案，在Debug文件夹下会得到mydll.dll (对象文件库），将该.dll文件、.lib文件和相应头文件给用户，用户就可以使用该库里的函数了。</li></ol><p><strong>疑问一：</strong></p><p>__declspec(dllexport)是什么意思？  </p><p>动态链接库中定义有两种函数：导出函数(export function)和内部函数(internal function)。 导出函数可以被其它模块调用，内部函数在定义它们的DLL程序内部使用。    </p><p> <strong>疑问二：</strong></p><p>动态库的lib文件和静态库的lib文件的区别？ </p><p>在使用动态库的时候，往往提供两个文件：一个引入库（.lib）文件（也称“导入库文件”）和一个DLL（.dll）文件。虽然引入库的后缀名也是“lib”，但是，动态库的引入库文件和静态库文件有着本质的区别，对一个DLL文件来说，其引入库文件（.lib）包含该DLL导出的函数和变量的符号名，而.dll文件包含该DLL实际的函数和数据。在使用动态库的情况下，在编译链接可执行文件时，只需要链接该DLL的引入库文件，该DLL中的函数代码和数据并不复制到可执行文件，直到可执行程序运行时，才去加载所需的DLL，将该DLL映射到进程的地址空间中，然后访问DLL中导出的函数。  </p><h3 id="12-3-2-动态库的使用"><a href="#12-3-2-动态库的使用" class="headerlink" title="12.3.2 动态库的使用"></a>12.3.2 动态库的使用</h3><p><strong>方法一：隐式调用</strong></p><p>​     创建主程序TestDll，将mydll.h、mydll.dll和mydll.lib复制到源代码目录下。  (P.S：头文件Func.h并不是必需的，只是C++中使用外部函数时，需要先进行声明)  在程序中指定链接引用链接库 : #pragma comment(lib,”.&#x2F;mydll.lib”)  </p><p><strong>方法二：显式调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE  hDll; //声明一个dll实例文件句柄    </span><br><span class="line">hDll  = LoadLibrary(&quot;mydll.dll&quot;); //导入动态链接库    </span><br><span class="line">MYFUNC  minus_test; //创建函数指针    </span><br><span class="line">//获取导入函数的函数指针    </span><br><span class="line">minus_test = (MYFUNC)GetProcAddress(hDll, &quot;myminus&quot;);  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言基础</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/windows%E5%BC%80%E5%8F%91/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/windows%E5%BC%80%E5%8F%91/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p>编译命令格式：</p><p>gcc [-option1] … <filename></p><p>g++ [-option1] … <filename></p><p>l 命令、选项和源文件之间使用空格分隔</p><p>l 一行命令中可以有零个、一个或多个选项</p><p>l 文件名可以包含文件的绝对路径，也可以使用相对路径</p><p>l 如果命令中不包含输出可执行文件的文件名，可执行文件的文件名会自动生成一个默认名，Linux平台为a.out，Windows平台为a.exe</p><p> gcc、g++编译常用选项说明：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-o file</td><td>指定生成的输出文件名为file</td></tr><tr><td>-E</td><td>只进行预处理</td></tr><tr><td>-S(大写)</td><td>只进行预处理和编译</td></tr><tr><td>-c(小写)</td><td>只进行预处理、编译和汇编</td></tr></tbody></table><p><strong>#include&lt; &gt; 与 #include “”的区别：</strong></p><p>l &lt; &gt; 表示系统直接按系统指定的目录检索</p><p>l “” 表示系统先在 “” 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索</p><p><strong>注意：</strong></p><p>所有的#开头的行，都代表预编译指令，预编译指令行结尾是没有分号的</p><p>所有的可执行语句必须是在代码块里面</p><h3 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h3><p>#include &lt;stdlib.h&gt;</p><p>int <em>system</em>(const char *command);</p><p>功能：在已经运行的程序中执行另外一个外部程序</p><p>参数：外部可执行程序名字</p><p>返回值：</p><p>成功：0</p><p>失败：任意数字</p><p> 例如：system(“ls”)</p><h2 id="C代码编译成可执行程序经过4步："><a href="#C代码编译成可执行程序经过4步：" class="headerlink" title="C代码编译成可执行程序经过4步："></a>C代码编译成可执行程序经过4步：</h2><p>1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法</p><p>2）编译：检查语法，将预处理后文件编译生成汇编文件</p><p>3）汇编：将汇编文件生成目标文件(二进制文件)</p><p>4）链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p><h2 id="gcc编译过程"><a href="#gcc编译过程" class="headerlink" title="gcc编译过程"></a>gcc编译过程</h2><h3 id="分步编译"><a href="#分步编译" class="headerlink" title="分步编译"></a>分步编译</h3><p>预处理：gcc -E hello.c -o hello.i</p><p>编 译：gcc -S hello.i -o hello.s</p><p>汇 编：gcc -c hello.s -o hello.o</p><p>链 接：gcc  hello.o -o hello</p><table><thead><tr><th><strong>选项</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-E</td><td>只进行预处理</td></tr><tr><td>-S(大写)</td><td>只进行预处理和编译</td></tr><tr><td>-c(小写)</td><td>只进行预处理、编译和汇编</td></tr><tr><td>-o file</td><td>指定生成的输出文件名为 file</td></tr></tbody></table><table><thead><tr><th><strong>文件后缀</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>.c</td><td>C 语言文件</td></tr><tr><td>.i</td><td>预处理后的 C 语言文件</td></tr><tr><td>.s</td><td>编译后的汇编文件</td></tr><tr><td>.o</td><td>编译后的目标文件</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041348712.jpg" alt="clip_image002"></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041348225.jpg" alt="clip_image002-16397464813171"></p><h3 id="声明和定义区别"><a href="#声明和定义区别" class="headerlink" title="声明和定义区别"></a>声明和定义区别</h3><p>声明变量不需要建立存储空间，如：extern int a;</p><p>定义变量需要建立存储空间，如：int b;</p><h3 id="整型变量的定义和输出"><a href="#整型变量的定义和输出" class="headerlink" title="整型变量的定义和输出"></a>整型变量的定义和输出</h3><table><thead><tr><th><strong>打印格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%d</td><td>输出一个<strong>有符号</strong>的10进制int类型</td></tr><tr><td>%o(字母o)</td><td>输出8进制的int类型</td></tr><tr><td>%x</td><td>输出16进制的int类型，字母以小写输出</td></tr><tr><td>%X</td><td>输出16进制的int类型，字母以大写输出</td></tr><tr><td>%u</td><td>输出一个10进制的无符号数</td></tr></tbody></table><table><thead><tr><th><strong>整型常量</strong></th><th><strong>所需类型</strong></th></tr></thead><tbody><tr><td>10</td><td>代表int类型</td></tr><tr><td>10l, 10L</td><td>代表long类型</td></tr><tr><td>10ll, 10LL</td><td>代表long long类型</td></tr><tr><td>10u, 10U</td><td>代表unsigned int类型</td></tr><tr><td>10ul, 10UL</td><td>代表unsigned long类型</td></tr><tr><td>10ull, 10ULL</td><td>代表unsigned long long类型</td></tr></tbody></table><table><thead><tr><th><strong>打印格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%hd</td><td>输出short类型</td></tr><tr><td>%d</td><td>输出int类型</td></tr><tr><td>%ld</td><td>输出long类型</td></tr><tr><td>%lld</td><td>输出long long类型</td></tr><tr><td>%hu</td><td>输出unsigned short类型</td></tr><tr><td>%u</td><td>输出unsigned int类型</td></tr><tr><td>%lu</td><td>输出unsigned long类型</td></tr><tr><td>%llu</td><td>输出unsigned long long类型</td></tr></tbody></table><h3 id="有符号和无符号整型取值范围"><a href="#有符号和无符号整型取值范围" class="headerlink" title="有符号和无符号整型取值范围"></a>有符号和无符号整型取值范围</h3><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td>short</td><td>2字节</td><td>-32768 到 32767 (-215  ~ 215-1)</td></tr><tr><td>int</td><td>4字节</td><td>-2147483648 到  2147483647 (-231 ~ 231-1)</td></tr><tr><td>long</td><td>4字节</td><td>-2147483648 到  2147483647 (-231 ~ 231-1)</td></tr><tr><td>unsigned short</td><td>2字节</td><td>0 到 65535 (0 ~ 216-1)</td></tr><tr><td>unsigned int</td><td>4字节</td><td>0 到 4294967295 (0  ~ 232-1)</td></tr><tr><td>unsigned long</td><td>4字节</td><td>0 到 4294967295 (0  ~ 232-1)</td></tr></tbody></table><p>转义字符</p><table><thead><tr><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII****码值（十进制）</strong></th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT)  （跳到下一个TAB位置）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\</td><td>代表一个反斜线字符”&quot;</td><td>092</td></tr><tr><td>&#39;</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>&quot;</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符，d范围0~7</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td><td>3位16进制</td></tr></tbody></table><h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><table><thead><tr><th><strong>限定符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>extern</td><td>声明一个变量，extern声明的变量没有建立存储空间。  extern int a;&#x2F;&#x2F;变量在定义的时候创建存储空间</td></tr><tr><td>const</td><td>定义一个常量，常量的值不能修改。  const int a &#x3D; 10;</td></tr><tr><td>Volatile</td><td>防止编译器优化代码</td></tr><tr><td>register</td><td>定义寄存器变量，提高效率。register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效，如果没有空闲寄存器，那么register无效。</td></tr></tbody></table><h2 id="printf函数和putchar函数"><a href="#printf函数和putchar函数" class="headerlink" title="printf函数和putchar函数"></a>printf函数和putchar函数</h2><p>printf是输出一个字符串，putchar输出一个字符。 </p><p>printf格式字符：</p><table><thead><tr><th><strong>打印格式</strong></th><th><strong>对应数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%d</td><td>int</td><td>接受整数值并将它表示为有符号的十进制整数</td></tr><tr><td>%hd</td><td>short int</td><td>短整数</td></tr><tr><td>%hu</td><td>unsigned short</td><td>无符号短整数</td></tr><tr><td>%o</td><td>unsigned int</td><td>无符号8进制整数</td></tr><tr><td>%u</td><td>unsigned int</td><td>无符号10进制整数</td></tr><tr><td>%x,%X</td><td>unsigned int</td><td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF</td></tr><tr><td>%f</td><td>float</td><td>单精度浮点数</td></tr><tr><td>%lf</td><td>double</td><td>双精度浮点数</td></tr><tr><td>%e,%E</td><td>double</td><td>科学计数法表示的数，此处”e”的大小写代表在输出时用的”e”的大小写</td></tr><tr><td>%c</td><td>char</td><td>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td></tr><tr><td>%s</td><td>char *</td><td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td></tr><tr><td>%p</td><td>void *</td><td>以16进制形式输出指针</td></tr><tr><td>%%</td><td>%</td><td>输出一个百分号</td></tr></tbody></table><p>printf附加格式：</p><table><thead><tr><th><strong>字符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>l(字母l)</td><td>附加在d,u,x,o前面，表示长整数</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>m(代表一个整数)</td><td>数据最小宽度</td></tr><tr><td>0(数字0)</td><td>将输出的前面补上0直到占满指定列宽为止不可以搭配使用-</td></tr><tr><td>m.n(代表一个整数)</td><td>m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度，用于说明输出的实型数的小数位数。对数值型的来说，未指定n时，隐含的精度为n&#x3D;6位。</td></tr></tbody></table><h2 id="scanf函数与getchar函数"><a href="#scanf函数与getchar函数" class="headerlink" title="scanf函数与getchar函数"></a>scanf函数与getchar函数</h2><ul><li><p>getchar是从标准输入设备读取一个char。</p></li><li><p>scanf通过%转义的方式可以得到用户通过标准输入设备输入的数据。</p></li></ul><h2 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h2><p>#include &lt;stdio.h&gt;</p><p>char  *gets(char *s);</p><p>功能：从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾为止。</p><p>参数：</p><p>​    s：字符串首地址</p><p>返回值：</p><p>​    成功：读入的字符串</p><p>​    失败：NULL</p><p><strong>gets(str)与scanf(“%s”,str)的区别：</strong></p><ul><li><p>gets(str)允许输入的字符串含有空格</p></li><li><p>scanf(“%s”,str)不允许含有空格</p></li></ul><h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h2><p>#include &lt;stdio.h&gt;</p><p>char  *fgets(char  *s,int size,FILE  *stream);</p><p>功能：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 ‘\0’ 作为字符串结束。</p><p>参数：</p><p>​    s：字符串</p><p>​    size：指定最大读取字符串的长度（size - 1）</p><p>​    stream：文件指针，如果读键盘输入的字符串，固定写为stdin</p><p>返回值：</p><p>​    成功：成功读取的字符串</p><p>​    读到文件尾或出错： <em>NULL</em></p><p>fgets()在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。通过scanf和gets输入一个字符串的时候，不包含结尾的“\n”，但通过fgets结尾多了“\n”。fgets()函数是安全的，不存在缓冲区溢出的问题。</p><h2 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h2><p>#include &lt;stdio.h&gt;</p><p>int  puts(const char *s);</p><p>功能：标准设备输出s字符串，**在输出完成后自动输出一个’\n’**。</p><p>参数：</p><p>​    s：字符串首地址</p><p>返回值：</p><p>​    成功：非负数</p><p>​    失败：-1</p><h2 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h2><p>#include &lt;stdio.h&gt;</p><p>int fputs(const char *str,FILE *stream);</p><p>功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 ‘\0’  不写入文件。 </p><p>参数：</p><p>​    str：字符串</p><p>​    stream：文件指针，如果把字符串输出到屏幕，固定写为stdout</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p><p> fputs()是puts()的文件操作版本，但fputs()不会自动输出一个’\n’。</p><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h2><p>#include &lt;string.h&gt;</p><p>size_t  strlen(const char *s);</p><p>功能：计算指定指定字符串s的长度，不包含字符串结束符‘\0’</p><p>参数：</p><p>s：字符串首地址</p><p>返回值：字符串s的长度，size_t为unsigned int类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *t)</span>;</span><br><span class="line"></span><br><span class="line">功能：获取当前系统时间</span><br><span class="line"></span><br><span class="line">参数：常设置为<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">返回值：当前系统时间, <span class="type">time_t</span>相当于<span class="type">long</span>类型，单位为毫秒</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br><span class="line"></span><br><span class="line">功能：用来设置rand()产生随机数时的随机种子</span><br><span class="line"></span><br><span class="line">参数：如果每次seed相等，rand()产生随机数相等</span><br><span class="line"></span><br><span class="line">返回值：无</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">功能：返回一个随机数值</span><br><span class="line"></span><br><span class="line">参数：无</span><br><span class="line"></span><br><span class="line">返回值：随机数</span><br></pre></td></tr></table></figure><h5 id="为了避免同一个文件被include多次，C-x2F-C-中有两种方式，一种是-ifndef-方式，一种是-pragma-once-方式。"><a href="#为了避免同一个文件被include多次，C-x2F-C-中有两种方式，一种是-ifndef-方式，一种是-pragma-once-方式。" class="headerlink" title="为了避免同一个文件被include多次，C&#x2F;C++中有两种方式，一种是 #ifndef 方式，一种是 #pragma once 方式。"></a><strong>为了避免同一个文件被include多次，C&#x2F;C++中有两种方式，一种是 #ifndef 方式，一种是 #pragma once 方式。</strong></h5><ul><li>方法一：</li></ul><p>#ifndef  SOMEFILE.H</p><p>#define SOMEFILE.H</p><p>&#x2F;&#x2F; 声明语句</p><p> #endif </p><ul><li>方法二：</li></ul><p>#pragma once </p><p>&#x2F;&#x2F; 声明语句</p><h2 id="万能指针void"><a href="#万能指针void" class="headerlink" title="万能指针void *"></a>万能指针void *</h2><p>void *指针可以指向任意变量的内存空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">p = (<span class="type">void</span> *)&amp;a; <span class="comment">//指向变量时，最好转换为void *</span></span><br><span class="line"><span class="comment">//使用指针变量指向的内存时，转换为int *</span></span><br><span class="line">*( (<span class="type">int</span> *)p ) = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><h2 id="const修饰的指针变量"><a href="#const修饰的指针变量" class="headerlink" title="const修饰的指针变量"></a>const修饰的指针变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="comment">//修饰*，指针指向内存区域不能修改，指针指向可以变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; <span class="comment">//等价于int const *p1 = &amp;a;</span></span><br><span class="line"><span class="comment">//*p1 = 111; //err</span></span><br><span class="line">p1 = &amp;b; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//修饰p1，指针指向不能变，指针指向的内存可以修改</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //err</span></span><br><span class="line">*p2 = <span class="number">222</span>; <span class="comment">//ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* b=&amp;a;<span class="comment">//*b=&#x27;b&#x27;</span></span><br><span class="line"><span class="type">char</span>** c=&amp;b;<span class="comment">//*c=&amp;a</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041349134.png" alt="image-20211218235604584"></p><h2 id="strstr-p-”abcd”"><a href="#strstr-p-”abcd”" class="headerlink" title="strstr(p,”abcd”)"></a>strstr(p,”abcd”)</h2><p>从p指定的内存地址中查找子字符串”abcd”，找到返回第一个字符的位置，没找到返回NULL</p><h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h2><p>#include &lt;string.h&gt;</p><p>char *strcpy(char *dest,const char *src);</p><p>功能：把src所指向的字符串覆盖复制到dest所指向的空间中，’\0’也会拷贝过去</p><p>参数：</p><p>​    dest：目的字符串首地址</p><p>​    src：源字符首地址</p><p>返回值：</p><p>​    成功：返回dest字符串的首地址</p><p>​    失败：NULL</p><p>注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。</p><h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy()"></a>strncpy()</h2><p>#include &lt;string.h&gt;</p><p>char *strncpy(char *dest,const char *src,size_t n);</p><p>功能：把src指向字符串的前n个字符复制到dest所指向的空间中，复制完不会在dest所指向的空间中自动添加’\0’。</p><p>参数：</p><p>​    dest：目的字符串首地址</p><p>​    src：源字符首地址</p><p>​    n：指定需要拷贝字符串个数</p><p>返回值：</p><p>​    成功：返回dest字符串的首地址</p><p>​    失败：NULL</p><h2 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h2><p>#include &lt;string.h&gt;</p><p>char  *strcat(char *dest, const char *src);</p><p>功能：将src字符串连接到dest的尾部，‘\0’也会追加过去</p><p>参数：</p><p>​    dest：目的字符串首地址</p><p>​    src：源字符首地址</p><p>返回值：</p><p>​    成功：返回dest字符串的首地址</p><p>​    失败：NULL</p><h2 id="strncat"><a href="#strncat" class="headerlink" title="strncat()"></a>strncat()</h2><p>#include &lt;string.h&gt;</p><p>char *strncat(char *dest,const char *src,size_t n);</p><p>功能：将src字符串前n个字符连接到dest的尾部，‘\0’也会追加过去，若复制的最后一个不是’\0’，则复制完全部后，自动在dest加个’\0’</p><p>参数：</p><p>​    dest：目的字符串首地址</p><p>​    src：源字符首地址</p><p>​    n：指定需要追加字符串个数</p><p>返回值：</p><p>​    成功：返回dest字符串的首地址</p><p>​    失败：NULL</p><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h2><p>#include &lt;string.h&gt;</p><p>int strcmp(const  char *s1,const char *s2);</p><p>功能：比较 s1 和 s2 的大小，比较的是字符ASCII码大小。</p><p>参数：</p><p>​    s1：字符串1首地址</p><p>​    s2：字符串2首地址</p><p>返回值：</p><p>​    相等：0</p><p>​    大于：&gt;0 在不同操作系统strcmp结果会不同  返回ASCII差值</p><p>​    小于：&lt;0</p><h2 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp()"></a>strncmp()</h2><p>#include &lt;string.h&gt;</p><p>int strncmp(const char *s1,const char *s2,size_t n);</p><p>功能：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小。</p><p>参数：</p><p>​    s1：字符串1首地址</p><p>​    s2：字符串2首地址</p><p>​    n：指定比较字符串的数量</p><p>返回值：</p><p>​    相等：0</p><p>​    大于： &gt; 0</p><p>​    小于： &lt; 0</p><p>​    </p><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf()"></a>sprintf()</h2><p>#include &lt;stdio.h&gt;</p><p>int sprintf(char *str,const char *format, …);</p><p>功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 ‘\0’ 为止。</p><p>参数：</p><p>​    str：字符串首地址</p><p>​    format：字符串格式，用法和printf()一样</p><p>返回值：</p><p>​    成功：实际格式化的字符个数</p><p>​    失败： - 1</p><p><strong>用法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> dst[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">char</span> src[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, src = %s&quot;</span>, a, src);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> len = <span class="built_in">sprintf</span>(dst, <span class="string">&quot;a = %d, src = %s&quot;</span>, a, src);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dst = \&quot; %s\&quot;\n&quot;</span>, dst);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf()"></a>sscanf()</h2><p>#include &lt;stdio.h&gt;</p><p>int sscanf(const char *str, const char *format, …);</p><p>功能：从str指定的字符串读取数据，并根据参数format字符串来提取数据。</p><p>参数：</p><p>​    str：指定的字符串首地址</p><p>​    format：字符串格式，用法和scanf()一样</p><p>返回值：</p><p>​    成功：参数数目，成功转换的值的个数</p><p>​    失败： - 1</p><p> 比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    char src[] = &quot;a=10, b=20&quot;;</span><br><span class="line"></span><br><span class="line">​   int a;</span><br><span class="line"></span><br><span class="line">​   int b;</span><br><span class="line"></span><br><span class="line">​   sscanf(src, &quot;a=%d, b=%d&quot;, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">​   printf(&quot;a:%d, b:%d\n&quot;, a, b);</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="strchr"><a href="#strchr" class="headerlink" title="strchr()"></a>strchr()</h2><p>#include &lt;string.h&gt;</p><p>char *strchr(const char *s, int c);</p><p><strong>功能</strong>：在字符串s中查找字母c出现的位置</p><p><strong>参数</strong>：</p><p>​    s：字符串首地址</p><p>​    c：匹配字母(字符)</p><p><strong>返回值</strong>：</p><p>​    成功：返回第一次出现的c地址</p><p>​    失败：NULL</p><p>​    char src[] &#x3D; “ddda123abcd”;</p><p>​    char *p &#x3D; <em>strchr</em>(src, ‘a’);</p><p>​    <em>printf</em>(“p &#x3D; %s\n”, p);</p><h2 id="strstr"><a href="#strstr" class="headerlink" title="strstr()"></a>strstr()</h2><p>#include &lt;string.h&gt;</p><p>char *strstr(const char *str,const char *substr);</p><p>功能：在字符串haystack中查找字符串needle出现的位置</p><p>参数：</p><p>​    str：源字符串首地址</p><p>​    substr：待匹配字符串</p><p>返回值：</p><p>​    成功：返回第一次出现的substr地址</p><p>​    失败：NULL</p><h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok()"></a>strtok()</h2><p>#include &lt;string.h&gt;</p><p>char *strtok(char *str,const char *delim);</p><p>功能：来将字符串分割成一个个片段。当strtok()在参数str的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\0 字符，当连续出现多个时只替换第一个为\0。</p><p>参数：</p><p>​    str：指向欲分割的字符串</p><p>​    delim：为欲分割字符串中包含的所有字符中的一个</p><p>返回值：</p><p>​    成功：分割后字符串首地址</p><p>​    失败：NULL</p><ul><li><p>在第一次调用时：strtok()必需给予参数str字符串</p></li><li><p>往后的调用则将参数str设置成NULL，每次调用成功则返回指向被分割出片段的指针</p></li></ul><p> 比如：</p><p>​    char a[100] &#x3D; “adc*fvcv*ebcy*hghbdfg*casdert”;</p><p>​    char *s &#x3D; <em>strtok</em>(a, “*“);&#x2F;&#x2F;将”*“分割的子串取出</p><p>​    while (s !&#x3D; <em>NULL</em>)</p><p>​    {</p><p>​       <em>printf</em>(“%s\n”, s);</p><p>​       s &#x3D; <em>strtok</em>(<em>NULL</em>, “*”);</p><p>​    }</p><h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi()"></a>atoi()</h2><p>#include &lt;stdlib.h&gt;</p><p>int atoi(const char *nptr);</p><p>功能：atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(‘\0’)才结束转换，并将结果返回。将char数组中的数字转化为整形后返回。</p><p>参数：</p><p>​    nptr：待转换的字符串</p><p>返回值：成功转换后整数</p><p>类似的函数有：</p><ul><li><p>atof()：把一个小数形式的字符串转化为一个浮点数。</p></li><li><p>atol()：将一个字符串转化为long类型</p></li></ul><p> 比如：</p><p>​    char str1[] &#x3D; “-10”;</p><p>​    int num1 &#x3D; <em>atoi</em>(str1);</p><p>​    <em>printf</em>(“num1 &#x3D; %d\n”, num1);</p><p>​    char str2[] &#x3D; “0.123”;</p><p>​    double num2 &#x3D; <em>atof</em>(str2);</p><p>​    <em>printf</em>(“num2 &#x3D; %lf\n”, num2);</p><p>所有的函数默认都是全局的（全局意味着一个文件中定义的函数，能被另一个文件使用），意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。</p><p>总结</p><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td></tr><tr><td>全局变量</td><td>整个程序</td><td>整个程序运行期</td></tr></tbody></table><h1 id="内存操作函数"><a href="#内存操作函数" class="headerlink" title="内存操作函数"></a>内存操作函数</h1><h2 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h2><p>#include &lt;string.h&gt;</p><p>void *memset(void *s,int c,size_t n);</p><p>功能：将s的内存区域的前n个字节以参数c填入</p><p>参数：</p><p>​    s：需要操作内存s的首地址</p><p>​    c：填充的字符，c虽然参数为int，但必须是unsigned char , 范围为0~255</p><p>​    n：指定需要设置的大小</p><p>返回值：s的首地址</p><p>​    int a[10];</p><p>​    <em>memset</em>(a, 0, sizeof(a));</p><p>​    <em>memset</em>(a, 97, sizeof(a));</p><p>​    int i &#x3D; 0;</p><p>​    for (i &#x3D; 0; i &lt; 10; i++)</p><p>​    {</p><p>​       <em>printf</em>(“%c\n”, a[i]);</p><p>​    }</p><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h2><p>#include &lt;string.h&gt;</p><p>void *memcpy(void *dest,const void *src,size_t n);</p><p>功能：拷贝src所指的内存内容的前n个字节到dest所指的内存地址上。</p><p>参数：</p><p>​    dest：目的内存首地址</p><p>​    src：源内存首地址，注意：dest和src所指的内存空间不可重叠，可能会导致程序报错</p><p>​    n：需要拷贝的字节数</p><p>返回值：dest的首地址</p><p>​    int a[10] &#x3D; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p><p>​    int b[10];</p><p>​    </p><p>​    <em>memcpy</em>(b, a, sizeof(a));</p><p>​    int i &#x3D; 0;</p><p>​    for (i &#x3D; 0; i &lt; 10; i++)</p><p>​    {</p><p>​       <em>printf</em>(“%d, “, b[i]);</p><p>​    }</p><p>​    <em>printf</em>(“\n”);</p><p>​    &#x2F;&#x2F;memcpy(&amp;a[3], a, 5 * sizeof(int)); &#x2F;&#x2F;err, 内存重叠</p><h2 id="memmove"><a href="#memmove" class="headerlink" title="memmove()"></a>memmove()</h2><p>memmove()功能用法和memcpy()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比memcpy()低些。</p><h2 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp()"></a>memcmp()</h2><p>#include &lt;string.h&gt;</p><p>int memcmp(const void *s1,const void *s2,size_t n);</p><p>功能：比较s1和s2所指向内存区域的前n个字节</p><p>参数：</p><p>​    s1：内存首地址1</p><p>​    s2：内存首地址2</p><p>​    n：需比较的前n个字节</p><p>返回值：</p><p>​    相等：&#x3D;0</p><p>​    大于：&gt;0</p><p>​    小于：&lt;0</p><p>​    int a[10] &#x3D; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p><p>​    int b[10] &#x3D; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</p><p>​    int flag &#x3D; <em>memcmp</em>(a, b, sizeof(a));</p><p>​    <em>printf</em>(“flag &#x3D; %d\n”, flag);</p><h1 id="堆区内存分配和释放"><a href="#堆区内存分配和释放" class="headerlink" title="堆区内存分配和释放"></a>堆区内存分配和释放</h1><h2 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1)malloc()"></a>1)malloc()</h2><p>#include &lt;stdlib.h&gt;</p><p>void *malloc(size_t size);</p><p>功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。</p><p>参数：</p><p>​    size：需要分配内存大小(单位：字节)</p><p>返回值：</p><p>成功：分配空间的起始地址</p><p>失败：NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count, *<span class="built_in">array</span>, n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要申请数组的个数:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;申请空间失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="comment">//将申请到空间清0</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line"> <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; n; count++) <span class="comment">/*给数组赋值*/</span></span><br><span class="line"><span class="built_in">array</span>[count] = count;</span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; n; count++) <span class="comment">/*打印数组元素*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>, <span class="built_in">array</span>[count]);</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-free"><a href="#2-free" class="headerlink" title="2)free()"></a>2)free()</h2><p>#include &lt;stdlib.h&gt;</p><p>void free(void *ptr);</p><p>功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。</p><p>参数：</p><p>ptr：需要释放空间的首地址，被释放区应是由malloc函数所分配的区域。</p><p>返回值：无</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041349045.jpg" alt="clip_image002-16398959995502"></p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型。</p><ul><li><p>与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值</p></li><li><p>#define发生在预处理，typedef发生在编译阶段</p></li></ul><h2 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h2><p>任何文件使用之前必须打开：</p><p>#include &lt;stdio.h&gt;</p><p><strong>FILE</strong> *** fopen(<strong><strong>const</strong> <strong>char</strong> *** filename,</strong> <strong>const</strong> <strong>char</strong> *** mode);**</p><p>功能：打开文件</p><p>参数：</p><p>​    filename：需要打开的文件名，根据需要加上路径</p><p>​    mode：打开文件的模式设置</p><p>返回值：</p><p>​    成功：文件指针</p><p>​    失败：NULL</p><p>第一个参数的几种形式:</p><p>​    <em>FILE</em> *fp_passwd &#x3D; <em>NULL</em>;</p><p>​    &#x2F;&#x2F;相对路径：</p><p>​    &#x2F;&#x2F;打开当前目录passdw文件：源文件(源程序)所在目录</p><p>​    <em>FILE</em> *fp_passwd &#x3D; <em>fopen</em>(“passwd.txt”, “r”);</p><p>​    </p><p>​    &#x2F;&#x2F;打开当前目录(test)下passwd.txt文件</p><p>​    fp_passwd &#x3D; <em>fopen</em>(“. &#x2F; test &#x2F; passwd.txt”, “r”);</p><p>​    </p><p>​    &#x2F;&#x2F;打开当前目录上一级目录（相对当前目录）passwd.txt文件</p><p>​    fp_passwd &#x3D; <em>fopen</em>(“.. &#x2F; passwd.txt”, “r”);</p><p>​       </p><p>​    &#x2F;&#x2F;绝对路径：</p><p>​    &#x2F;&#x2F;打开C盘test目录下一个叫passwd.txt文件</p><p>​    fp_passwd &#x3D; <em>fopen</em>(“c:&#x2F;test&#x2F;passwd.txt”,”r”);</p><p>第二个参数的几种形式(打开文件的方式)：</p><table><thead><tr><th><strong>打开模式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>r或rb</td><td>以只读方式打开一个文本文件（不创建文件，若文件不存在则报错）</td></tr><tr><td>w或wb</td><td>以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a或ab</td><td>以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件</td></tr><tr><td>r+或rb+</td><td>以可读、可写的方式打开文件(不创建新文件)</td></tr><tr><td>w+或wb+</td><td>以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a+或ab+</td><td>以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建文件</td></tr></tbody></table><p> 注意：</p><ul><li>b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的</li><li>Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾</li><li>在Windows平台下，以“文本”方式打开文件，不加b：<ul><li>当读取文件的时候，系统会将所有的 “\r\n” 转换成 “\n”</li><li>当写入文件的时候，系统会将 “\n” 转换成 “\r\n” 写入 </li><li>以”二进制”方式打开文件，则读写都不会进行这样的转换</li></ul></li><li>在Unix&#x2F;Linux平台下，“文本”与“二进制”模式没有区别，”\r\n” 作为两个字符原样输入输出</li></ul><p>int main(void)</p><p>{</p><p>​    FILE *fp &#x3D; NULL;</p><p>​    &#x2F;&#x2F; “\“这样的路径形式，只能在windows使用</p><p>​    &#x2F;&#x2F; “&#x2F;“这样的路径形式，windows和linux平台下都可用，建议使用这种</p><p>​    &#x2F;&#x2F; 路径可以是相对路径，也可是绝对路径</p><p>​    fp &#x3D; fopen(“..&#x2F;test”, “w”);</p><p>​    &#x2F;&#x2F;fp &#x3D; fopen(“..\test”, “w”);</p><p>​    if (fp &#x3D;&#x3D; NULL) &#x2F;&#x2F;返回空，说明打开失败</p><p>​    {</p><p>​       &#x2F;&#x2F;perror()是标准出错打印函数，能打印调用库函数出错原因</p><p>​       perror(“open”);</p><p>​       return -1;</p><p>​    }</p><p>​    return 0;</p><p>}</p><h2 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h2><p>任何文件在使用后应该关闭：</p><ul><li>打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存</li><li>一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用fopen打开文件会失败</li><li>如果没有明确的调用fclose关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭。</li></ul><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>fclose</strong>(<strong>FILE</strong> *** stream);**</p><p>功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。</p><p>参数：</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p><h2 id="按照字符读写文件fgetc、fputc"><a href="#按照字符读写文件fgetc、fputc" class="headerlink" title="按照字符读写文件fgetc、fputc"></a>按照字符读写文件fgetc、fputc</h2><h4 id="1）写文件"><a href="#1）写文件" class="headerlink" title="1）写文件"></a>1）写文件</h4><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>fputc</strong>(<strong>int</strong> <strong>ch,</strong> <strong>FILE</strong> *** stream);**</p><p>功能：将ch转换为unsigned char后写入stream指定的文件中</p><p>参数：</p><p>​    ch：需要写入文件的字符</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：成功写入文件的字符</p><p>​    失败：返回-1</p><p>char buf[] &#x3D; “this is a test for fputc”;</p><p>int i &#x3D; 0;</p><p>int n &#x3D; strlen(buf);</p><p>for (i &#x3D; 0; i &lt; n; i++)</p><p>{</p><p>​    &#x2F;&#x2F;往文件fp写入字符buf[i]</p><p>​    int ch &#x3D; fputc(buf[i], fp);</p><p>​    printf(“ch &#x3D; %c\n”, ch);</p><p>}</p><h4 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h4><p>在C语言中，<strong>EOF表示文件结束符(end of file)。</strong>在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。</p><p>#define <em>EOF</em>   (-1)</p><p>当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。</p><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>feof(</strong> <strong>FILE</strong> *** stream);**</p><p>功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。</p><p>参数：</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    非0值：已经到文件结尾</p><p>​    0：没有到文件结尾</p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>fgetc(</strong> <strong>FILE</strong> *** stream);**</p><p>功能：从stream指定的文件中读取一个字符</p><p>参数：</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：返回读取到的字符</p><p>​    失败：-1</p><p>char ch;</p><p>#if 0</p><p>while ((ch &#x3D; fgetc(fp)) !&#x3D; EOF)</p><p>{</p><p>​    printf(“%c”, ch);</p><p>}</p><p>printf(“\n”);</p><p>#endif</p><p>while (!feof(fp)) &#x2F;&#x2F;文件没有结束，则执行循环</p><p>{</p><p>​    ch &#x3D; fgetc(fp);</p><p>​    printf(“%c”, ch);</p><p>}</p><p>printf(“\n”);</p><h2 id="按照行读写文件fgets、fputs"><a href="#按照行读写文件fgets、fputs" class="headerlink" title="按照行读写文件fgets、fputs"></a>按照行读写文件fgets、fputs</h2><h4 id="1）写文件-1"><a href="#1）写文件-1" class="headerlink" title="1）写文件"></a>1）写文件</h4><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>fputs(</strong> <strong>const</strong> <strong>char</strong> *** str,** <strong>FILE</strong> *** stream);**</p><p>功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 ‘\0’  不写入文件。 </p><p>参数：</p><p>​    str：字符串</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p><p>char *buf[] &#x3D; { “123456\n”, “bbbbbbbbbb\n”, “ccccccccccc\n” };</p><p>int i &#x3D; 0;</p><p>int n &#x3D; 3;</p><p>for (i &#x3D; 0; i &lt; n; i++)</p><p>{</p><p>​    int len &#x3D; fputs(buf[i], fp);</p><p>​    printf(“len &#x3D; %d\n”, len);</p><p>}</p><h4 id="2）读文件"><a href="#2）读文件" class="headerlink" title="2）读文件"></a>2）读文件</h4><p>#include &lt;stdio.h&gt;</p><p><strong>char</strong> *** fgets(<strong><strong>char</strong> *** str,</strong> <strong>int</strong> <strong>size,</strong> <strong>FILE</strong> *** stream);**</p><p>功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 ‘\0’ 作为字符串结束。</p><p>参数：</p><p>​    str：字符串</p><p>​    size：指定最大读取字符串的长度（size - 1）</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：成功读取的字符串</p><p>​    读到文件尾或出错： NULL</p><p>char buf[100] &#x3D; 0;</p><p>while (!feof(fp)) &#x2F;&#x2F;文件没有结束</p><p>{</p><p>​    memset(buf, 0, sizeof(buf));</p><p>​    char *p &#x3D; fgets(buf, sizeof(buf), fp);</p><p>​    if (p !&#x3D; NULL)</p><p>​    {</p><p>​       printf(“buf &#x3D; %s”, buf);</p><p>​    }</p><p>}</p><h2 id="按照格式化文件fprintf、fscanf"><a href="#按照格式化文件fprintf、fscanf" class="headerlink" title="按照格式化文件fprintf、fscanf"></a>按照格式化文件fprintf、fscanf</h2><h4 id="1）写文件-2"><a href="#1）写文件-2" class="headerlink" title="1）写文件"></a>1）写文件</h4><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>fprintf(</strong> <strong>FILE</strong> *** stream,** <strong>const</strong> <strong>char</strong> *** format, …);**</p><p>功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 ‘\0’ 为止。</p><p>参数：</p><p>​    stream：已经打开的文件</p><p>​    format：字符串格式，用法和printf()一样</p><p>返回值：</p><p>​    成功：实际写入文件的字符个数</p><p>​    失败：-1</p><p>fprintf(fp, “%d %d %d\n”, 1, 2, 3);</p><h4 id="2）读文件-1"><a href="#2）读文件-1" class="headerlink" title="2）读文件"></a>2）读文件</h4><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>fscanf(</strong> <strong>FILE</strong> *** stream,** <strong>const</strong> <strong>char</strong> *** format, …);**</p><p>功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</p><p>参数：</p><p>​    stream：已经打开的文件</p><p>​    format：字符串格式，用法和scanf()一样</p><p>返回值：</p><p>​    成功：参数数目，成功转换的值的个数</p><p>​    失败： - 1</p><p>int a &#x3D; 0;</p><p>int b &#x3D; 0;</p><p>int c &#x3D; 0;</p><p>fscanf(fp, “%d %d %d\n”, &amp;a, &amp;b, &amp;c);</p><p>printf(“a &#x3D; %d, b &#x3D; %d, c &#x3D; %d\n”, a, b, c);</p><h2 id="按照块读写文件fread、fwrite"><a href="#按照块读写文件fread、fwrite" class="headerlink" title="按照块读写文件fread、fwrite"></a>按照块读写文件fread、fwrite</h2><h4 id="1）写文件-3"><a href="#1）写文件-3" class="headerlink" title="1）写文件"></a>1）写文件</h4><p>#include &lt;stdio.h&gt;</p><p><strong>size_t</strong> <strong>fwrite(</strong> <strong>const</strong> <strong>void</strong> *<strong>ptr,</strong> <strong>size_t</strong> <strong>size,</strong> <strong>size_t</strong> <strong>nmemb,</strong> <strong>FILE</strong> *<strong>stream);</strong></p><p>功能：以数据块的方式给文件写入内容</p><p>参数：</p><p>​    ptr：准备写入文件数据的地址</p><p>​    size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小</p><p>​    nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</p><p>​    stream：已经打开的文件指针</p><p>返回值：</p><p>​    成功：实际成功写入文件数据的块数目，此值和 nmemb 相等</p><p>​    失败：0</p><p>typedef struct Stu</p><p>{</p><p>​    char name[50];</p><p>​    int id;</p><p>}Stu;</p><p>Stu s[3];</p><p>int i &#x3D; 0;</p><p>for (i &#x3D; 0; i &lt; 3; i++)</p><p>{</p><p>​    sprintf(s[i].name, “stu%d%d%d”, i, i, i);</p><p>​    s[i].id &#x3D; i + 1;</p><p>}</p><p>int ret &#x3D; fwrite(s, sizeof(Stu), 3, fp);</p><p>printf(“ret &#x3D; %d\n”, ret);</p><h4 id="2）读文件-2"><a href="#2）读文件-2" class="headerlink" title="2）读文件"></a>2）读文件</h4><p>#include &lt;stdio.h&gt;</p><p><strong>size_t</strong> <strong>fread(</strong> <strong>void</strong> *<strong>ptr,</strong> <strong>size_t</strong> <strong>size,</strong> <strong>size_t</strong> <strong>nmemb,</strong> <strong>FILE</strong> *<strong>stream);</strong></p><p>功能：以数据块的方式从文件中读取内容</p><p>参数：</p><p>​    ptr：存放读取出来数据的内存空间</p><p>​    size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小</p><p>​    nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb</p><p>​    stream：已经打开的文件指针</p><p>返回值：</p><pre><code> 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。  失败：0</code></pre><p>typedef struct Stu</p><p>{</p><p>​    char name[50];</p><p>​    int id;</p><p>}Stu;</p><p>Stu s[3];</p><p>int ret &#x3D; fread(s, sizeof(Stu), 3, fp);</p><p>printf(“ret &#x3D; %d\n”, ret);</p><p>int i &#x3D; 0;</p><p>for (i &#x3D; 0; i &lt; 3; i++)</p><p>{</p><p>​    printf(“s &#x3D; %s, %d\n”, s[i].name, s[i].id);</p><p>}</p><h2 id="文件的随机读写"><a href="#文件的随机读写" class="headerlink" title="文件的随机读写"></a>文件的随机读写</h2><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>fseek(</strong> <strong>FILE</strong> *<strong>stream,</strong> <strong>long</strong> <strong>offset,</strong> <strong>int</strong> <strong>whence);</strong></p><p>功能：移动文件流（文件光标）的读写位置。</p><p>参数：</p><p>​    stream：已经打开的文件指针</p><p>​    offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</p><p>​    whence：其取值如下：</p><p>​       SEEK_SET：从文件开头移动offset个字节</p><p>​       SEEK_CUR：从当前位置移动offset个字节</p><p>​       SEEK_END：从文件末尾移动offset个字节</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p><p>#include &lt;stdio.h&gt;</p><p><strong>long</strong> <strong>ftell(</strong> <strong>FILE</strong> *<strong>stream);</strong></p><p>功能：获取文件流（文件光标）的读写位置。</p><p>参数：</p><p>​    stream：已经打开的文件指针</p><p>返回值：</p><p>​    成功：当前文件流（文件光标）的读写位置</p><p>​    失败：-1</p><p>#include &lt;stdio.h&gt;</p><p><strong>void</strong> <strong>rewind(</strong> <strong>FILE</strong> *<strong>stream);</strong></p><p>功能：把文件流（文件光标）的读写位置移动到文件开头。</p><p>参数：</p><p>​    stream：已经打开的文件指针</p><p>返回值：</p><p>​    无返回值</p><p>typedef struct Stu</p><p>{</p><p>​    char name[50];</p><p>​    int id;</p><p>}Stu;</p><p>&#x2F;&#x2F;假如已经往文件写入3个结构体</p><p>&#x2F;&#x2F;fwrite(s, sizeof(Stu), 3, fp);</p><p>Stu s[3];</p><p>Stu tmp; </p><p>int ret &#x3D; 0;</p><p>&#x2F;&#x2F;文件光标读写位置从开头往右移动2个结构体的位置</p><p>fseek(fp, 2 * sizeof(Stu), SEEK_SET);</p><p>&#x2F;&#x2F;读第3个结构体</p><p>ret &#x3D; fread(&amp;tmp, sizeof(Stu), 1, fp);</p><p>if (ret &#x3D;&#x3D; 1)</p><p>{</p><p>​    printf(“[tmp]%s, %d\n”, tmp.name, tmp.id);</p><p>}</p><p>&#x2F;&#x2F;把文件光标移动到文件开头</p><p>&#x2F;&#x2F;fseek(fp, 0, SEEK_SET);</p><p>rewind(fp);</p><p>ret &#x3D; fread(s, sizeof(Stu), 3, fp);</p><p>printf(“ret &#x3D; %d\n”, ret);</p><p>int i &#x3D; 0;</p><p>for (i &#x3D; 0; i &lt; 3; i++)</p><p>{</p><p>​    printf(“s &#x3D;&#x3D;&#x3D; %s, %d\n”, s[i].name, s[i].id);</p><p>}</p><h2 id="获取文件状态"><a href="#获取文件状态" class="headerlink" title="获取文件状态"></a>获取文件状态</h2><p>#include &lt;sys&#x2F;types.h&gt;</p><p>#include &lt;sys&#x2F;stat.h&gt;</p><p><strong>int</strong> <strong>stat</strong>(<strong>const</strong> <strong>char</strong>  *<strong>path,</strong> <strong>struct</strong> <strong>stat  *buf</strong> <strong>);</strong></p><p>功能：获取文件状态信息</p><p>参数：</p><p>​    path：文件名</p><p>​    buf：保存文件信息的结构体</p><p>返回值：</p><p>​    成功：0</p><p>​    失败-1</p><p>struct stat {</p><p>​    <em>dev_t</em>     <em>st_dev</em>;     &#x2F;&#x2F;文件的设备编号</p><p>​    <em>ino_t</em>     <em>st_ino</em>;      &#x2F;&#x2F;节点</p><p>​    mode_t    <em>st_mode</em>;  &#x2F;&#x2F;文件的类型和存取的权限</p><p>​    nlink_t    <em>st_nlink</em>;   &#x2F;&#x2F;连到该文件的硬连接数目，刚建立的文件值为1</p><p>​    uid_t     <em>st_uid</em>;     &#x2F;&#x2F;用户ID</p><p>​    gid_t     <em>st_gid</em>;     &#x2F;&#x2F;组ID</p><p>​    <em>dev_t</em>     <em>st_rdev</em>;   &#x2F;&#x2F;(设备类型)若此文件为设备文件，则为其设备编号</p><p>​    <em>off_t</em>     <em>st_size</em>;    &#x2F;&#x2F;文件字节数(文件大小)</p><p>​    unsigned long st_blksize;  &#x2F;&#x2F;块大小(文件系统的I&#x2F;O 缓冲区大小)</p><p>​    unsigned long st_blocks;  &#x2F;&#x2F;块数</p><p>​    <em>time_t</em>    <em>st_atime</em>;   &#x2F;&#x2F;最后一次访问时间</p><p>​    <em>time_t</em>    <em>st_mtime</em>;  &#x2F;&#x2F;最后一次修改时间</p><p>​    <em>time_t</em>    <em>st_ctime</em>;   &#x2F;&#x2F;最后一次改变时间(指属性)</p><p>};</p><h2 id="删除文件、重命名文件名"><a href="#删除文件、重命名文件名" class="headerlink" title="删除文件、重命名文件名"></a>删除文件、重命名文件名</h2><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>remove</strong>(<strong>const</strong> <strong>char</strong> <em><strong>pathname</strong></em><em>);</em>*</p><p>功能：删除文件</p><p>参数：</p><p>​    pathname：文件名</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>rename</strong>(<strong>const</strong> <strong>char</strong> <em><strong>oldpath</strong></em><em>,</em>* <strong>const</strong> <strong>char</strong> <em><strong>newpath</strong></em><em>);</em>*</p><p>功能：把oldpath的文件名改为newpath</p><p>参数：</p><p>​    oldpath：旧文件名</p><p>​    newpath：新文件名</p><p>返回值：</p><p>​    成功：0</p><p>​    失败： - 1</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041349281.jpg" alt="clip_image002-16398997597833"></p><p>更新缓冲区</p><p>#include &lt;stdio.h&gt;</p><p><strong>int</strong> <strong>fflush</strong>(**FILE *** <strong>stream);</strong></p><p>功能：更新缓冲区，让缓冲区的数据立马写到文件中。</p><p>参数：</p><p>stream：文件指针</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密与解密基础</title>
      <link href="/2022/02/28/%E9%80%86%E5%90%91/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/28/%E9%80%86%E5%90%91/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="ANSI和Unicode"><a href="#ANSI和Unicode" class="headerlink" title="ANSI和Unicode"></a>ANSI和Unicode</h2><p>传统的ASCII是一个7位的编码标准，取值范围从00h~7Fh</p><p>不同的计算机厂商对ASCII进行了扩充，增加了128个附加字符，它们的值在127以上的部分是不统一的</p><p>取值范围为00h~0FFh。例如：<strong>ANSI</strong>、Symbol、OEM等字符集，其中ANSI是系统预设的标准文字存储格式</p><p>Unicode也是ASCII字符编码的一个扩展，它在Windows中用2字节对其进行编码，因此也被称为宽字符集，取值范围为0~65535</p><p>所有字符都是16位的，其中的7位ASCII码被扩充为16位</p><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p>Windows NT&#x2F;2000&#x2F;XP&#x2F;7与Windows9x 的工作方式不同：</p><ul><li>Windows NT&#x2F;2000&#x2F;XP&#x2F;7中，Win16函数调用通过一个<strong>转换层</strong>转换为Win32函数调用，然后被操作系统处理</li><li>Windows9x，Win32函数调用通过转换层转换为Win16函数调用，然后被操作系统处理</li></ul><p>Windows主要部分只需要在3个动态链接库中实现，它们分别代表Windows的3个子系统：</p><ul><li>Kernel（由KERNEL32.DLL实现）：操作系统核心功能服务，包括进程与线程控制、内存管理、文件访问等</li><li>User（由USER32.DLL实现）：负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等</li><li>GDI（由GDI32.DLL实现）：图形设备接口，允许程序在屏幕和打印机上显示文本和图形</li></ul><p>NT系统是使用Unicode标准字符集重新开发的，其系统核心完全是用Unicode函数工作的</p><p>在NT架构下，Win32 API能接受Unicode和ASCII两种字符集，而其内核只能使用Unicode字符集</p><p>在Win32API函数中，函数末尾带有”A”表示ANSI（比如：MessageBoxA），带有”W”表示Widechars（即Unicode，比如MessageBoxW），每个以字符串为参数的Win32函数在操作系统中都有这两个方式的版本。</p><p>WOW(Windows-on-Windows 64-bit)是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上。</p><p>当启动一个32位应用程序时：</p><ol><li>WOW64会建立32位ntdll.dll所要求的的启动环境</li><li>将CPU模式切换到32位</li><li>开始执行32位加载器</li></ol><p>当调用一个32位的动态链接库时：</p><ol><li>会重定向到此链接库的64位版本</li><li>WOW64切换到原生的64位模式</li><li>捕获相关参数</li><li>发出原生64位系统调用</li><li>当系统调用返回后，将结果转换为32位</li><li>CPU切换到32位模式</li></ol><p>调式符号文件（存储了变量、类型、函数名、源代码行等）<br>符号格式（符号表）：</p><ul><li>SYM格式：现在只作为Windows9x的调试符使用</li><li>COFF格式：逐渐抛弃</li><li>CodeView格式</li><li>PDB格式：具有唯一的特征签名，与对应的二进制文件同名</li><li>DBG格式</li><li>MAP格式</li></ul><h2 id="WinDBG"><a href="#WinDBG" class="headerlink" title="WinDBG"></a>WinDBG</h2><p>WinDBG对符号的一般表示方法为“模块名!符号名”，比如：kernel32!OpenProcess</p><p>从符号文件目录或符号服务器加载符号：</p><ol><li>ld 模块名!符号名</li><li>运行lm命令</li></ol><h3 id="符号检索"><a href="#符号检索" class="headerlink" title="符号检索"></a>符号检索</h3><p>x [Options] Module!Symbol</p><p>符号名可以使用”*”,”?”,”[]”,”#”,”+”等特殊字符进行模糊匹配</p><p>例如：x kernel!*Process*</p><table><thead><tr><th>命令</th><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>t</td><td>F8</td><td>追踪执行，遇到call指令时跟进</td></tr><tr><td>p</td><td>F10</td><td>单步执行，遇到call执行时路过，不跟进</td></tr><tr><td><strong>g</strong></td><td>F5</td><td>运行程序</td></tr><tr><td>pa 地址</td><td></td><td>单步到指定地址，不进入call指令</td></tr><tr><td>ta 地址</td><td></td><td>追踪到指定地址，进入call指令</td></tr><tr><td>pc [count]</td><td></td><td>单步执行到下一个call指令调用</td></tr><tr><td>tc  [count]</td><td></td><td>追踪执行到下一个call指令调用，遇到call指令时跟进</td></tr><tr><td>tb [count]</td><td></td><td>追踪执行到下一条分支指令，遇到call指令时跟进，只适用于内核调试</td></tr><tr><td>pt</td><td></td><td>单步执行到下一条call返回指令</td></tr><tr><td>tt</td><td></td><td>追踪执行到下一条call返回指令，遇到call指令时跟进</td></tr><tr><td>ph</td><td></td><td>单步执行到下一条分支指令</td></tr><tr><td>th</td><td></td><td>追踪执行到下一条分支指令，遇到call指令时跟进</td></tr><tr><td>wt</td><td></td><td>自动追踪函数执行过程</td></tr><tr><td>lm</td><td></td><td>查看使用的库</td></tr><tr><td>ld [模块名]</td><td></td><td>查看是否加载了某个模块</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>伪寄存器$ra代表当前函数的返回地址，pa  @$ra走出当前函数<br>count参数用于指定遇到call指令的个数，默认为1</p><h3 id="下断点命令"><a href="#下断点命令" class="headerlink" title="下断点命令"></a>下断点命令</h3><p><strong>软件断点（需要修改相应的代码，它不能调试Flash和ROM中的只读代码）：</strong></p><ol><li>bp [ID] [Options] [Address [Passes]] [“CommandString”] <ul><li>ID：指定断点ID，可缺省。内核调试限32个断点，用户模式不限</li><li>Options：可缺省<ul><li>&#x2F;1：中断后自动删除该断点，即一次性断点</li><li>&#x2F;c：指定最大调用深度，大于这个深度则断点不工作</li><li>&#x2F;C：指定最小调用深度，小于这个深度则断点不工作</li></ul></li><li>Address：地址或符号，例如MessageBoxW</li><li>Passes：忽略中断的次数，可缺省</li><li>CommandString：用于指定一组命令。当断点中断时，WinDbg自动执行这组命令，用双引号将命令包围起来，多个命令用分号分隔</li><li>bp所设断点和地址关联的，如果设断点的地址的指令改变，则断点不会移动，还是关联到原来的地址</li></ul></li><li>bu<ul><li>用于对某个符号下断点，例如：bu kernel32!GetVersion</li><li>bu是所设断点和符号关联的，如果符号的地址改变了，断点会保持与原符号的关联</li></ul></li><li>bm<ul><li>支持设置含有通配符的断点，可以一次设置一个或多个断点。</li><li>例如：bm msvcr80d!print*</li></ul></li></ol><p><strong>硬件断点：</strong></p><ol><li>ba [ID] Access Size [Options] [Address [Passes] ] [“CommandString”]<ul><li>ID：指定断点ID，可缺省。</li><li>Access：指定触发断点的访问方式。<ul><li>e：在读取或执行<strong>指令</strong>时触发断点</li><li>r：在读取<strong>数据</strong>时触发断点</li><li>w：在写入<strong>数据</strong>时触发断点</li><li>i：在执行输入&#x2F;输入访问时触发断点</li></ul></li><li>Size：访问的长度。1,2,4字节</li><li>Options：可缺省<ul><li>&#x2F;1：中断后自动删除该断点，即一次性断点</li><li>&#x2F;c：指定最大调用深度，大于这个深度则断点不工作</li><li>&#x2F;C：指定最小调用深度，小于这个深度则断点不工作</li></ul></li><li>Address：断点的<strong>地址</strong>。地址值按Size的值进行内存对齐</li><li>Passes：忽略中断的次数，可缺省</li><li>CommandString：用于指定一组命令。当断点中断时，WinDbg自动执行这组命令，用双引号将命令包围起来，多个命令用分号分隔</li></ul></li></ol><p><strong>条件断点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bp|bu|bm|ba _Address &quot;j (Condition) &#x27;OptionalCommands&#x27;; &#x27;gc&#x27; &quot;</span><br><span class="line">bp|bu|bm|ba _Address &quot;.if (Condition) &#123;OptionalCommands&#125; .else &#123;gc&#125; &quot;</span><br></pre></td></tr></table></figure><p>gc指令表示继续执行</p><p>poi(esp+4):表示取esp+4这个地址的值；dwo(esp+8):用于从(esp+8)地址中取8字节</p><ol><li><strong>bl命令列出当前的断点</strong></li><li><strong>bc命令用来删除断点，支持通配符</strong></li><li><strong>bd命令用来禁止断点，支持通配符</strong></li><li><strong>be命令用来启用断点，支持通配符</strong></li><li><strong>br命令用来改变断点编号</strong></li></ol><h2 id="栈窗口"><a href="#栈窗口" class="headerlink" title="栈窗口"></a>栈窗口</h2><p><strong>k指令查看函数调用情况</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041346760.png" alt="image-20211231164712969"></p><ul><li>第一行（即ChildEBP所在行的下一行）是当前中断所在的函数</li><li>第二行是调用第一行函数的上一级函数，以此类推</li><li>ChildEBP是栈帧的基地址，RetAddr是本函数的返回地址（也就是调用这个函数的call指令的下一条地址）</li><li>第三列是函数名以及执行位置</li></ul><p><strong>kb指令来查看调用参数，kb num，表示显示上面num个</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041347656.png" alt="image-20211231165529822"></p><ol><li>中间三列表示子函数的参数</li><li>不管子函数参数多少个，用kb指令只会显示3个，第一个为ebp+8h，第二个为ebp+Ch，第三个为ebp+10h，如果有第四个，则执行命令dd ebp+14h（双字节查看内存）即可查看</li></ol><ul><li><strong>kp命令可以把参数和参数值以函数原型的形式显示出来，包括参数类型、名字、取值（必须在符号完成的情况下）</strong></li><li><strong>kv命令可以在kb命令的基础上增加帧指针省略信息（Frame Pointer Omissio，FPO）和调用约定的显示</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203041347507.png" alt="image-20211231171143979"></li></ul></li><li><strong>kd命令用来查看栈，列出栈中的数据</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP</title>
      <link href="/2022/02/28/spring/SpringAOP/"/>
      <url>/2022/02/28/spring/SpringAOP/</url>
      
        <content type="html"><![CDATA[<h3 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h3><ul><li><p>AOP(Aspect Oriented Programing)面向切面编程，一种编程<strong>范式</strong>，隶属于软工范畴，指导开发者如何组织程序结构</p></li><li><p>AOP弥补了OOP的不足，基于OOP基础之上进行横向开发</p><ul><li><p>OOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型</p></li><li><p>AOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分）</p></li></ul></li><li><p>“AOP联盟”</p></li></ul><h3 id="AOP作用"><a href="#AOP作用" class="headerlink" title="AOP作用"></a>AOP作用</h3><ul><li><p>伴随着AOP时代的降临，可以从各个行业的标准化、规范化开始入手，一步一步将所有共性功能逐一开发完毕，最终以功能组合来完成个别业务模块乃至整体业务系统的开发</p></li><li><p>目标：将软件开发由手工制作走向半自动化&#x2F;全自动化阶段，实现“插拔式组件体系结构”搭建</p></li></ul><h3 id="AOP优势"><a href="#AOP优势" class="headerlink" title="AOP优势"></a>AOP优势</h3><ul><li><p>提高代码的可重用性</p></li><li><p>业务代码编码更简洁</p></li><li><p>业务代码维护更高效</p></li><li><p>业务功能扩展更便捷</p></li></ul><h3 id="AOP相关名词"><a href="#AOP相关名词" class="headerlink" title="AOP相关名词"></a>AOP相关名词</h3><ul><li>Joinpoint(连接点)：就是方法</li><li>Pointcut(切入点)：就是挖掉共性功能的方法</li><li>Advice(通知)：就是共性功能，最终以一个方法的形式呈现</li><li>Aspect(切面)：就是共性功能与挖的位置的对应关系</li><li>Target(目标对象)：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>Weaving(织入)：就是将挖掉的功能回填的动态过程</li><li>Proxy(代理)：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现</li><li>Introduction(引入&#x2F;引介) ：就是对原始对象无中生有的添加成员变量或成员方法</li></ul><h3 id="AOP开发方式"><a href="#AOP开发方式" class="headerlink" title="AOP开发方式"></a>AOP开发方式</h3><ul><li>XML方式</li><li>XML+注解方式</li><li>注解方式</li></ul><p>第一步，导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，业务层抽取通用代码</p><p>第三步，将通知加入spring容器</p><p>第四步，在spring核心配置文件中引入aop</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051708246.png" alt="1591282320624"></p><p>第五步，在配置文件中配置aop的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--aop配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*())&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        &lt;!—通知与切入点之间的关系--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="AOP配置（XML）"><a href="#AOP配置（XML）" class="headerlink" title="AOP配置（XML）"></a>AOP配置（XML）</h2><h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a><strong>AspectJ</strong></h3><ul><li><p>Aspect（切面）用于描述切入点与通知间的关系，是AOP编程中的一个概念</p></li><li><p>AspectJ是基于java语言对Aspect的实现</p></li></ul><h3 id="AOP配置"><a href="#AOP配置" class="headerlink" title="AOP配置"></a>AOP配置</h3><h4 id="aop-config"><a href="#aop-config" class="headerlink" title="aop:config"></a>aop:config</h4><ul><li><p>名称：aop:config</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：beans标签</p></li><li><p>作用：设置AOP</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：一个beans标签中可以配置多个aop:config标签</p></li></ul><h4 id="aop-aspect"><a href="#aop-aspect" class="headerlink" title="aop:aspect"></a>aop:aspect</h4><ul><li><p>名称：aop:aspect</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：aop:config标签</p></li><li><p>作用：设置具体的AOP通知对应的切入点</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：</p><p>一个aop:config标签中可以配置多个aop:aspect标签</p></li><li><p>基本属性：</p><ul><li>ref ：通知所在的bean的id</li></ul></li></ul><h4 id="aop-pointcut"><a href="#aop-pointcut" class="headerlink" title="aop:pointcut"></a>aop:pointcut</h4><ul><li><p>名称：aop:pointcut</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：aop:config标签、aop:aspect标签</p></li><li><p>作用：设置切入点</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcutId&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcutId&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：</p><p>一个aop:config标签中可以配置多个aop:pointcut标签，且该标签可以配置在aop:aspect标签内</p></li><li><p>基本属性：</p><ul><li><p>id ：识别切入点的名称</p></li><li><p>expression ：切入点表达式</p></li></ul></li></ul><h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a><strong>切入点</strong></h3><ul><li><p>切入点描述的是某个方法</p></li><li><p>切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式</p></li></ul><h3 id="切入点表达式的组成"><a href="#切入点表达式的组成" class="headerlink" title="切入点表达式的组成"></a><strong>切入点表达式的组成</strong></h3><ul><li><p>切入点描述的是某个方法</p></li><li><p>切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键字（访问修饰符  返回值  包名.类名.方法名（参数）异常名）</span><br></pre></td></tr></table></figure></li></ul><p>​    关键字：描述表达式的匹配模式（参看关键字列表）</p><p>​    访问修饰符：方法的访问控制权限修饰符</p><p>​    类名：方法所在的类（此处可以配置接口名称）</p><p>​    异常：方法定义中指定抛出的异常</p><ul><li><p>范例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution（public User com.itheima.service.UserService.findById（int））</span><br></pre></td></tr></table></figure></li></ul><h4 id="切入点表达式——关键字"><a href="#切入点表达式——关键字" class="headerlink" title="切入点表达式——关键字"></a>切入点表达式——关键字</h4><ul><li><p>execution ：匹配执行指定方法</p></li><li><p>args ：匹配带有指定参数类型的方法</p></li><li><p>within ：…… </p></li><li><p>this ：…… </p></li><li><p>target ：…… </p></li><li><p>@within ：…… </p></li><li><p>@target ：…… </p></li><li><p>@args ：…… </p></li><li><p>@annotation ：…… </p></li><li><p>bean ：……</p></li><li><p>reference pointcut ：……</p></li></ul><h4 id="切入点表达式——通配符"><a href="#切入点表达式——通配符" class="headerlink" title="切入点表达式——通配符"></a>切入点表达式——<strong>通配符</strong></h4><ul><li><p>*：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution（public * com.itheima.*.UserService.find*（*））</span><br></pre></td></tr></table></figure></li></ul><p>​    匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p><ul><li><p>.. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution（public User com..UserService.findById（..））</span><br></pre></td></tr></table></figure></li></ul><p>​    匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p><ul><li><p>+：专用于匹配子类类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure></li></ul><h4 id="切入点表达式——逻辑运算符"><a href="#切入点表达式——逻辑运算符" class="headerlink" title="切入点表达式——逻辑运算符"></a>切入点表达式——逻辑运算符</h4><ul><li><p>&amp;&amp; ：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配</p></li><li><p>|| ：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配</p></li><li><p>! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配</p></li></ul><h4 id="切入点表达式——范例"><a href="#切入点表达式——范例" class="headerlink" title="切入点表达式——范例"></a>切入点表达式——范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">execution(* *(..))</span><br><span class="line">execution(* *..*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> * *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..*.*(..)) </span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.service.User*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.service.*Service.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.service.UserService.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.itheima.service.UserService.find*(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.itheima.service.UserService.*Id(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.itheima.service.UserService.findById(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.itheima.service.UserService.findById(<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.itheima.service.UserService.findById(<span class="type">int</span>,<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.itheima.service.UserService.findById(<span class="type">int</span>,*))</span><br><span class="line">execution(<span class="keyword">public</span> User com.itheima.service.UserService.findById(*,<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.itheima.service.UserService.findById())</span><br><span class="line">execution(List com.itheima.service.*Service+.findAll(..))</span><br></pre></td></tr></table></figure><h3 id="切入点的三种配置方式"><a href="#切入点的三种配置方式" class="headerlink" title="切入点的三种配置方式"></a><strong>切入点的三种配置方式</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置公共切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置局部切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用公共切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用局部切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--直接配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="切入点配置经验"><a href="#切入点配置经验" class="headerlink" title="切入点配置经验"></a><strong>切入点配置经验</strong></h3><ul><li><p>企业开发命名规范严格遵循规范文档进行</p></li><li><p>先为方法配置局部切入点</p></li><li><p>再抽取类中公共切入点</p></li><li><p>最后抽取全局切入点</p></li><li><p>代码走查过程中检测切入点是否存在越界性包含</p></li><li><p>代码走查过程中检测切入点是否存在非包含性进驻</p></li><li><p>设定AOP执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配</p></li><li><p>设定完毕的切入点如果发生调整务必进行回归测试</p></li></ul><p>（以上规则适用于XML配置格式）</p><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a><strong>通知类型</strong></h3><p>AOP的通知类型共5种</p><ul><li><p>前置通知：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行</p><p>应用：数据校验</p></li><li><p>后置通知：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知</p><p>应用：现场清理</p></li><li><p>返回后通知：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行</p><p>应用：返回值相关数据处理</p></li><li><p>抛出异常后通知：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行</p><p>应用：对原始方法中出现的异常信息进行处理</p></li><li><p>环绕通知：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行</p><p>应用：十分强大，可以做任何事情</p></li></ul><h4 id="aop-before"><a href="#aop-before" class="headerlink" title="aop:before"></a>aop:before</h4><ul><li><p>名称：aop:before</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：aop:aspect标签</p></li><li><p>作用：设置前置通知</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：一个aop:aspect标签中可以配置多个aop:before标签</p></li><li><p>基本属性：</p><ul><li><p>method ：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul></li></ul><h4 id="aop-after"><a href="#aop-after" class="headerlink" title="aop:after"></a>aop:after</h4><ul><li><p>名称：aop:after</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：aop:aspect标签</p></li><li><p>作用：设置后置通知</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：一个aop:aspect标签中可以配置多个aop:after标签</p></li><li><p>基本属性：</p><ul><li><p>method ：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul></li></ul><h4 id="aop-after-returning"><a href="#aop-after-returning" class="headerlink" title="aop:after-returning"></a>aop:after-returning</h4><ul><li><p>名称：aop:after-returning</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：aop:aspect标签</p></li><li><p>作用：设置返回后通知</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：一个aop:aspect标签中可以配置多个aop:after-returning标签</p></li><li><p>基本属性：</p><ul><li><p>method ：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul></li></ul><h4 id="aop-after-throwing"><a href="#aop-after-throwing" class="headerlink" title="aop:after-throwing"></a>aop:after-throwing</h4><ul><li><p>名称：aop:after-throwing</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：aop:aspect标签</p></li><li><p>作用：设置抛出异常后通知</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：一个aop:aspect标签中可以配置多个aop:after-throwing标签</p></li><li><p>基本属性：</p><ul><li><p>method ：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul></li></ul><h4 id="aop-around"><a href="#aop-around" class="headerlink" title="aop:around"></a>aop:around</h4><ul><li><p>名称：aop:around</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：aop:aspect标签</p></li><li><p>作用：设置环绕通知</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：一个aop:aspect标签中可以配置多个aop:around标签</p></li><li><p>基本属性：</p><ul><li><p>method ：在通知类中设置当前通知类别对应的方法</p></li><li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p></li><li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p></li></ul></li></ul><p>环绕通知的开发方式</p><ul><li><p>环绕通知是在原始方法的前后添加功能，在环绕通知中，存在对原始方法的显式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知方法相关说明：</p><ul><li><p>方法须设定Object类型的返回值，否则会拦截原始方法的返回。如果原始方法返回值类型为void，通知方    也可以设定返回值类型为void，最终返回null</p></li><li><p>方法需在第一个参数位置设定ProceedingJoinPoint对象，通过该对象调用proceed()方法，实现对原始方法的调用。如省略该参数，原始方法将无法执行</p></li><li><p>使用proceed()方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出Throwable对象，封装原始方法中可能出现的异常信息</p></li></ul></li></ul><h3 id="通知顺序（了解）"><a href="#通知顺序（了解）" class="headerlink" title="通知顺序（了解）"></a><strong>通知顺序（了解）</strong></h3><p>当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准</p><h3 id="通知获取数据"><a href="#通知获取数据" class="headerlink" title="通知获取数据"></a><strong>通知获取数据</strong></h3><ul><li><p>参数</p></li><li><p>返回值</p></li><li><p>异常</p></li></ul><h4 id="通知获取参数数据"><a href="#通知获取参数数据" class="headerlink" title="通知获取参数数据"></a><strong>通知获取参数数据</strong></h4><p>第一种情况：</p><ul><li><p>设定通知方法第一个参数为JoinPoint，通过该对象调用getArgs()方法，获取原始方法运行的参数数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    Object[] args = jp.getArgs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有的通知均可以获取参数</p></li></ul><p>第二种情况：</p><ul><li><p>设定切入点表达式为通知方法传递参数（锁定通知变量名）</p></li><li><p>原始方法</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051710452.png" alt="1591284387913"></p><p>第三种情况</p><ul><li><p>设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序）</p></li><li><p>原始方法</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051736753.png" alt="1591284429541"></p><h4 id="通知获取返回值数据"><a href="#通知获取返回值数据" class="headerlink" title="通知获取返回值数据"></a><strong>通知获取返回值数据</strong></h4><p>第一种：返回值变量名</p><ul><li><p>设定返回值变量名</p></li><li><p>原始方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt3&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt3&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;ret&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object ret)</span> &#123;</span><br><span class="line">    System.out.println(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>适用于返回后通知（after-returning）</p></li></ul><p>第二种：</p><ul><li><p>在通知类的方法中调用原始方法获取返回值</p></li><li><p>原始方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP配置l</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>适用于环绕通知（around）</p></li></ul><h4 id="通知获取异常数据"><a href="#通知获取异常数据" class="headerlink" title="通知获取异常数据"></a><strong>通知获取异常数据</strong></h4><p>第一种：通知类的方法中调用原始方法捕获异常</p><ul><li><p>在通知类的方法中调用原始方法捕获异常</p></li><li><p>原始方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt4&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt4&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//对此处调用进行try……catch……捕获异常，或抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>适用于环绕通知（around）</p></li></ul><p>第二种：</p><ul><li><p>设定异常对象变量名</p></li><li><p>原始方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AOP配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt4&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt4&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">    System.out.println(t.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>适用于返回后通知（after-throwing）</p></li></ul><h2 id="AOP配置（注解）"><a href="#AOP配置（注解）" class="headerlink" title="AOP配置（注解）"></a>AOP配置（注解）</h2><h3 id="AOP配置-1"><a href="#AOP配置-1" class="headerlink" title="AOP配置"></a>AOP配置</h3><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051736709.png" alt="1591285050618"></p><h3 id="注解开发AOP制作步骤"><a href="#注解开发AOP制作步骤" class="headerlink" title="注解开发AOP制作步骤"></a>注解开发AOP制作步骤</h3><p>在XML格式基础上</p><ul><li><p>导入坐标（伴随spring-context坐标导入已经依赖导入完成）</p></li><li><p>开启AOP注解支持</p></li><li><p>配置切面@Aspect</p></li><li><p>定义专用的切入点方法，并配置切入点@Pointcut</p></li><li><p>为通知方法配置通知类型及对应切入点@Before</p></li></ul><h3 id="注解开发AOP注意事项"><a href="#注解开发AOP注意事项" class="headerlink" title="注解开发AOP注意事项"></a>注解开发AOP注意事项</h3><p>1.切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法</p><p>2.引用切入点时必须使用方法调用名称，方法后面的（）不能省略</p><p>3.切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用</p><p>4.可以在通知类型注解后添加参数，实现XML配置中的属性，例如after-returning后的returning属性</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051736548.png" alt="1591285152119"></p><h3 id="AOP注解详解"><a href="#AOP注解详解" class="headerlink" title="AOP注解详解"></a>AOP注解详解</h3><h4 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h4><ul><li><p>名称：@Aspect</p></li><li><p>类型：<strong>注解</strong></p></li><li><p>位置：类定义上方</p></li><li><p>作用：设置当前类为切面类</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAdvice</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：一个beans标签中可以配置多个aop:config标签</p></li></ul><h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a>@Pointcut</h4><ul><li><p>名称：@Pointcut</p></li><li><p>类型：<strong>注解</strong></p></li><li><p>位置：方法定义上方</p></li><li><p>作用：使用当前方法名作为切入点引用名称</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* *(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）</p></li></ul><h4 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h4><ul><li><p>名称：@Before</p></li><li><p>类型：<strong>注解</strong></p></li><li><p>位置：方法定义上方</p></li><li><p>作用：标注当前方法作为前置通知</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊参数：</p><ul><li>无</li></ul></li></ul><h4 id="After"><a href="#After" class="headerlink" title="@After"></a>@After</h4><ul><li><p>名称：@After</p></li><li><p>类型：<strong>注解</strong></p></li><li><p>位置：方法定义上方</p></li><li><p>作用：标注当前方法作为后置通知</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊参数：</p><ul><li>无</li></ul></li></ul><h4 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="@AfterReturning"></a>@AfterReturning</h4><ul><li><p>名称：@AfterReturning</p></li><li><p>类型：<strong>注解</strong></p></li><li><p>位置：方法定义上方</p></li><li><p>作用：标注当前方法作为返回后通知</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value=&quot;pt()&quot;,returning = &quot;ret&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object ret)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊参数：</p><ul><li>returning ：设定使用通知方法参数接收返回值的变量名</li></ul></li></ul><h4 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="@AfterThrowing"></a>@AfterThrowing</h4><ul><li><p>名称：@AfterThrowing</p></li><li><p>类型：<strong>注解</strong></p></li><li><p>位置：方法定义上方</p></li><li><p>作用：标注当前方法作为异常后通知</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value=&quot;pt()&quot;,throwing = &quot;t&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊参数：</p><ul><li>throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名</li></ul></li></ul><h4 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h4><ul><li><p>名称：@Around</p></li><li><p>类型：<strong>注解</strong></p></li><li><p>位置：方法定义上方</p></li><li><p>作用：标注当前方法作为环绕通知</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊参数：</p><ul><li>无</li></ul></li></ul><h3 id="AOP注解开发通知执行顺序控制（了解）"><a href="#AOP注解开发通知执行顺序控制（了解）" class="headerlink" title="AOP注解开发通知执行顺序控制（了解）"></a>AOP注解开发通知执行顺序控制（了解）</h3><p>1.AOP使用XML配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念的概念，参照通知所配置的方法名字符串对应的编码值顺序，可以简单理解为字母排序</p><ul><li><p>同一个通知类中，相同通知类型以方法名排序为准</p></li><li><p>不同通知类中，以类名排序为准</p></li><li><p>使用@Order注解通过变更bean的加载顺序改变通知的加载顺序</p></li></ul><p>2.企业开发经验</p><ul><li><p>通知方法名由3部分组成，分别是前缀、顺序编码、功能描述</p></li><li><p>前缀为固定字符串，例如baidu、itheima等，无实际意义</p></li><li><p>顺序编码为6位以内的整数，通常3位即可，不足位补0</p></li><li><p>功能描述为该方法对应的实际通知功能，例如exception、strLenCheck</p><ul><li><p>制通知执行顺序使用顺序编码控制，使用时做一定空间预留</p></li><li><p>003使用，006使用，预留001、002、004、005、007、008</p></li><li><p>使用时从中段开始使用，方便后期做前置追加或后置追加</p></li><li><p>最终顺序以运行顺序为准，以测试结果为准，不以设定规则为准</p></li></ul></li></ul><h3 id="AOP注解驱动"><a href="#AOP注解驱动" class="headerlink" title="AOP注解驱动"></a>AOP注解驱动</h3><ul><li><p>名称：@EnableAspectJAutoProxy</p></li><li><p>类型：<strong>注解</strong></p></li><li><p><strong>位置：Spring注解配置类定义上方</strong></p></li><li><p>作用：设置当前类开启AOP注解驱动的支持，加载AOP注解</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a><strong>案例介绍</strong></h3><p>对项目进行业务层接口执行监控，测量业务层接口的执行效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a><strong>案例分析</strong></h3><ul><li><p>测量接口执行效率：接口方法执行前后获取执行时间，求出执行时长</p><ul><li>System.currentTimeMillis( )</li></ul></li><li><p>对项目进行监控：项目中所有接口方法，AOP思想，执行期动态织入代码</p><ul><li><p>环绕通知</p></li><li><p>proceed()方法执行前后获取系统时间</p></li></ul></li></ul><h3 id="案例制作步骤"><a href="#案例制作步骤" class="headerlink" title="案例制作步骤"></a><strong>案例制作步骤</strong></h3><ul><li><p>定义切入点（务必要绑定到接口上，而不是接口实现类上）</p></li><li><p>制作AOP环绕通知，完成测量功能</p></li><li><p>注解配置AOP</p></li><li><p>开启注解驱动支持</p></li></ul><h3 id="案例制作核心代码"><a href="#案例制作核心代码" class="headerlink" title="案例制作核心代码"></a><strong>案例制作核心代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunTimeMonitorAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//拦截所有的业务层接口中查询操作的执行</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.find*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">runtimeMonitor</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//获取执行签名信息</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getSignature();</span><br><span class="line">        <span class="comment">//通过签名获取执行类型（接口名）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">targetClass</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">        <span class="comment">//通过签名获取执行操作名称（方法名）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">targetMethod</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        <span class="comment">//获取操作前系统时间beginTime</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(pjp.getArgs());</span><br><span class="line">        <span class="comment">//获取操作后系统时间endTime</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(targetClass+<span class="string">&quot; 中 &quot;</span>+targetMethod+<span class="string">&quot; 运行时长 &quot;</span>+(endTime-beginTime)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例后续思考与设计"><a href="#案例后续思考与设计" class="headerlink" title="案例后续思考与设计"></a><strong>案例后续思考与设计</strong></h3><ul><li><p>测量真实性</p><ul><li><p>开发测量是隔离性反复执行某个操作，是理想情况，上线测量差异过大</p></li><li><p>上线测量服务器性能略低于单机开发测量</p></li><li><p>上线测量基于缓存的性能查询要优于数据库查询测量</p></li><li><p>上线测量接口的性能与最终对外提供的服务性能差异过大</p></li><li><p>当外部条件发生变化（硬件），需要进行回归测试，例如数据库迁移</p></li></ul></li><li><p>测量结果展示</p><ul><li><p>测量结果无需每一个都展示，需要设定检测阈值</p></li><li><p>阈值设定要根据业务进行区分，一个复杂的查询与简单的查询差异化很大</p></li><li><p>阈值设定需要做独立的配置文件或通过图形工具配置（工具级别的开发）</p></li><li><p>配合图形界面展示测量结果</p></li></ul></li></ul><h2 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h2><ul><li><p>静态代理</p></li><li><p>动态代理——Proxy</p></li><li><p>动态代理——CGLIB</p></li><li><p>织入形式</p></li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a><strong>静态代理</strong></h3><p>装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051711887.png" alt="1591287238806"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceDecorator</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//原始调用</span></span><br><span class="line">        userService.save();</span><br><span class="line">        <span class="comment">//增强功能（后置）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;刮大白&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理——JDK-Proxy"><a href="#动态代理——JDK-Proxy" class="headerlink" title="动态代理——JDK Proxy"></a>动态代理——JDK Proxy</h3><p>JDKProxy动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceJDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">createUserServiceJDKProxy</span><span class="params">(<span class="keyword">final</span> UserService userService)</span>&#123;</span><br><span class="line">        <span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userService.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//获取被代理对象实现的接口</span></span><br><span class="line">        Class[] classes = userService.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">//对原始方法执行进行拦截并增强</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">//前置增强内容</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                <span class="comment">//后置增强内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;刮大白2&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//使用原始被代理对象创建新的代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(classLoader,classes,ih);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-动态代理——CGLIB"><a href="#6-3-动态代理——CGLIB" class="headerlink" title="6.3)动态代理——CGLIB"></a>6.3)动态代理——CGLIB</h3><ul><li><p>CGLIB(Code Generation Library)，Code生成类库</p></li><li><p>CGLIB动态代理不限定是否具有接口，可以对任意操作进行增强</p></li><li><p>CGLIB动态代理无需要原始被代理对象，动态创建出新的代理对象</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051711890.png" alt="1591287441096"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImplCglibProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserServiceImpl <span class="title function_">createUserServiceCglibProxy</span><span class="params">(Class clazz)</span>&#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码）</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置Enhancer对象的父类是指定类型UserServerImpl</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method m, Object[] a, MethodProxy mp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> mp.invokeSuper(o, a);</span><br><span class="line">                <span class="keyword">if</span>(m.getName().equals(<span class="string">&quot;save&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;刮大白&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//设置回调方法</span></span><br><span class="line">        enhancer.setCallback(cb);</span><br><span class="line">        <span class="comment">//使用Enhancer对象创建对应的对象</span></span><br><span class="line">        <span class="keyword">return</span> (UserServiceImpl)enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-代理模式的选择"><a href="#6-4-代理模式的选择" class="headerlink" title="6.4)代理模式的选择"></a><strong>6.4)代理模式的选择</strong></h3><p>Spirng可以通过配置的形式控制使用的代理形式，默认使用jdkproxy，通过配置可以修改为使用cglib</p><ul><li><p>XML配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XMP配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>XML注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注解驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解驱动</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-5-织入时机"><a href="#6-5-织入时机" class="headerlink" title="6.5)织入时机"></a><strong>6.5)织入时机</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051711897.png" alt="1591287839941"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务</title>
      <link href="/2022/02/28/spring/Spring%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/02/28/spring/Spring%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-事务"><a href="#spring-事务" class="headerlink" title="spring 事务"></a>spring 事务</h1><h2 id="1-事务回顾"><a href="#1-事务回顾" class="headerlink" title="1)事务回顾"></a>1)事务回顾</h2><h3 id="1-1-什么是事务？"><a href="#1-1-什么是事务？" class="headerlink" title="1.1)什么是事务？"></a>1.1)什么是事务？</h3><p>事务指数据库中多个操作合并在一起形成的操作序列</p><h3 id="1-2-事务的作用"><a href="#1-2-事务的作用" class="headerlink" title="1.2)事务的作用"></a>1.2)事务的作用</h3><p>1.当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（<strong>A</strong>），保障数据库即使在异常状态下仍能保持数据一致性（<strong>C</strong>）（要么操作前状态，要么操作后状态）。</p><p>2.当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（<strong>I</strong>）。</p><ul><li><p>事务特征（ACID）</p><ul><li><p>原子性（Atomicity）指事务是一个不可分割的整体，其中的操作要么全执行或全不执行</p></li><li><p>一致性（Consistency）事务前后数据的完整性必须保持一致</p></li><li><p>隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离</p></li><li><p>持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p></li></ul></li></ul><h3 id="1-3-事务的隔离级"><a href="#1-3-事务的隔离级" class="headerlink" title="1.3)事务的隔离级"></a>1.3)事务的隔离级</h3><ul><li><p>脏读：允许读取未提交的信息</p><ul><li>原因：Read uncommitted</li></ul><p>解决方案： （表级读锁）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051739428.png" alt="1591321851725"></p><ul><li>不可重复读：读取过程中单个数据发生了变化<ul><li>解决方案： Repeatable read （行级写锁）</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051740555.png"></p><ul><li>幻读：读取过程中数据条目发生了变化<ul><li>解决方案： Serializable（表级写锁）</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051740285.png" alt="1591321959641"></p><h2 id="2-事务管理"><a href="#2-事务管理" class="headerlink" title="2)事务管理"></a>2)事务管理</h2><h3 id="2-1-Spring事务核心对象"><a href="#2-1-Spring事务核心对象" class="headerlink" title="2.1)Spring事务核心对象"></a>2.1)<strong>Spring</strong>事务核心对象</h3><ul><li><p>J2EE开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理</p></li><li><p>Spring为业务层提供了整套的事务解决方案</p><ul><li><p>PlatformTransactionManager</p></li><li><p>TransactionDefinition</p></li><li><p>TransactionStatus</p></li></ul></li></ul><h3 id="2-2-PlatformTransactionManager"><a href="#2-2-PlatformTransactionManager" class="headerlink" title="2.2)PlatformTransactionManager"></a><strong>2.2)PlatformTransactionManager</strong></h3><ul><li><p>平台事务管理器实现类</p><ul><li><p>DataSourceTransactionManager  适用于Spring JDBC或MyBatis</p></li><li><p>HibernateTransactionManager  适用于Hibernate3.0及以上版本</p></li><li><p>JpaTransactionManager  适用于JPA</p></li><li><p>JdoTransactionManager  适用于JDO</p></li><li><p>JtaTransactionManager  适用于JTA</p></li></ul></li><li><p>JPA（Java Persistence API）Java EE 标准之一，为POJO提供持久化标准规范，并规范了持久化开发的统一API，符合JPA规范的开发可以在不同的JPA框架下运行</p></li><li><p>JDO(Java Data Object )是Java对象持久化规范，用于存取某种数据库中的对象，并提供标准化API。与JDBC相比，JDBC仅针对关系数据库进行操作，JDO可以扩展到关系数据库、文件、XML、对象数据库（ODBMS）等，可移植性更强</p></li><li><p>JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与JDBC相比，JDBC事务则被限定在一个单一的数据库连接，而一个JTA事务可以有多个参与者，比如JDBC连接、JDO 都可以参与到一个JTA事务中</p></li></ul><p>此接口定义了事务的基本操作</p><ul><li><p>获取事务 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span></span><br></pre></td></tr></table></figure></li><li><p>提交事务 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> </span><br></pre></td></tr></table></figure></li><li><p>回滚事务 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-TransactionDefinition"><a href="#2-3-TransactionDefinition" class="headerlink" title="2.3)TransactionDefinition"></a><strong>2.3)TransactionDefinition</strong></h3><p>此接口定义了事务的基本信息</p><ul><li><p>获取事务定义名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getName</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取事务的读写属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取事务隔离级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获事务超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取事务传播行为特征</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-TransactionStatus"><a href="#2-4-TransactionStatus" class="headerlink" title="2.4)TransactionStatus"></a><strong>2.4)TransactionStatus</strong></h3><p>此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051739838.png" alt="1591322466820"></p><h3 id="2-5-事务控制方式"><a href="#2-5-事务控制方式" class="headerlink" title="2.5)事务控制方式"></a><strong>2.5)事务控制方式</strong></h3><ul><li><p>编程式</p></li><li><p>声明式（XML）</p></li><li><p>声明式（注解）</p></li></ul><h3 id="2-6-案例说明"><a href="#2-6-案例说明" class="headerlink" title="2.6)案例说明"></a><strong>2.6)案例说明</strong></h3><h4 id="2-6-1-案例说明"><a href="#2-6-1-案例说明" class="headerlink" title="2.6.1)案例说明"></a>2.6.1)案例说明</h4><p>银行转账业务说明</p><p>银行转账操作中，涉及从A账户到B账户的资金转移操作。数据层仅提供单条数据的基础操作，未设计多账户间的业务操作。</p><h4 id="2-6-2-案例环境（基于Spring、Mybatis整合）"><a href="#2-6-2-案例环境（基于Spring、Mybatis整合）" class="headerlink" title="2.6.2)案例环境（基于Spring、Mybatis整合）"></a>2.6.2)案例环境（基于Spring、Mybatis整合）</h4><ul><li>业务层接口提供转账操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 转账操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> outName     出账用户名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> inName      入账用户名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> money       转账金额</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>;</span><br></pre></td></tr></table></figure><ul><li>业务层实现提供转账操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">    accountDao.inMoney(outName,money);                                                       accountDao.outMoney(inName,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据层提供对应的入账与出账操作</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;inMoney&quot;</span>&gt;</span></span><br><span class="line">update account set money = money + #&#123;money&#125; where name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;outMoney&quot;</span>&gt;</span></span><br><span class="line">update account set money = money - #&#123;money&#125; where name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-6-3-编程式事务"><a href="#2-6-3-编程式事务" class="headerlink" title="2.6.3)编程式事务"></a><strong>2.6.3)编程式事务</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dstm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    <span class="comment">//为事务管理器设置与数据层相同的数据源</span></span><br><span class="line">    dstm.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//创建事务定义对象</span></span><br><span class="line">    <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    <span class="comment">//创建事务状态对象，用于控制事务执行</span></span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span> dstm.getTransaction(td);</span><br><span class="line">    accountDao.inMoney(outName,money);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;    <span class="comment">//模拟业务层事务过程中出现错误</span></span><br><span class="line">    accountDao.outMoney(inName,money);</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    dstm.commit(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-使用AOP控制事务"><a href="#2-7-使用AOP控制事务" class="headerlink" title="2.7)使用AOP控制事务"></a>2.7)使用AOP控制事务</h3><p>将业务层的事务处理功能抽取出来制作成AOP通知，利用环绕通知运行期动态织入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">tx</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dstm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    dstm.setDataSource(dataSource);</span><br><span class="line">    <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span> dstm.getTransaction(td);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(pjp.getArgs());</span><br><span class="line">    dstm.commit(ts);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置AOP通知类，并注入dataSource</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.TxAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用环绕通知将通知类织入到原始业务对象执行过程中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..transfer(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;tx&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-8声明式事务（XML）"><a href="#2-8声明式事务（XML）" class="headerlink" title="2.8声明式事务（XML）"></a><strong>2.8声明式事务（XML）</strong></h3><p><strong>AOP</strong>配置事务是否具有特例性？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">tx</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dstm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    dstm.setDataSource(dataSource);</span><br><span class="line">    <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span> dstm.getTransaction(td);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(pjp.getArgs());</span><br><span class="line">    dstm.commit(ts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.TxAdvice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用tx命名空间配置事务专属通知类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用aop:advisor在AOP配置中引用事务专属通知类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-8-1-aop-advice与aop-advisor区别"><a href="#2-8-1-aop-advice与aop-advisor区别" class="headerlink" title="2.8.1)aop:advice与aop:advisor区别"></a>2.8.1)<strong>aop:advice与aop:advisor区别</strong></h4><ul><li><p>aop:advice配置的通知类可以是普通java对象，不实现接口，也不使用继承关系</p></li><li><p>aop:advisor配置的通知类必须实现通知接口</p><ul><li><p>MethodBeforeAdvice</p></li><li><p>AfterReturningAdvice</p></li><li><p>ThrowsAdvice</p></li><li><p>……</p></li></ul></li></ul><h4 id="2-8-2-tx配置—-tx-advice"><a href="#2-8-2-tx配置—-tx-advice" class="headerlink" title="2.8.2)tx配置—-tx:advice"></a>2.8.2)tx配置—-tx:advice</h4><ul><li><p>名称：tx:advice</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：beans标签</p></li><li><p>作用：专用于声明事务通知</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基本属性：</p><ul><li><p>id ：用于配置aop时指定通知器的id</p></li><li><p>transaction-manager ：指定事务管理器bean</p></li></ul></li></ul><h4 id="2-8-3-tx配置—-tx-attributes"><a href="#2-8-3-tx配置—-tx-attributes" class="headerlink" title="2.8.3)tx配置—-tx:attributes"></a>2.8.3)tx配置—-tx:attributes</h4><ul><li><p>名称：tx:attributes</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：tx:advice标签</p></li><li><p>作用：定义通知属性</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基本属性：</p><ul><li>无</li></ul></li></ul><h4 id="2-8-4-tx配置—-tx-method"><a href="#2-8-4-tx配置—-tx-method" class="headerlink" title="2.8.4)tx配置—-tx:method"></a>2.8.4)tx配置—-tx:method</h4><ul><li><p>名称：tx:method</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：tx:attribute标签</p></li><li><p>作用：设置具体的事务属性</p></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>说明：</p><p>通常事务属性会配置多个，包含1个读写的全事务属性，1个只读的查询类事务属性</p></li></ul><p><strong>tx:method属性</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051734132.png" alt="1591367291135"></p><h3 id="2-9-事务传播行为"><a href="#2-9-事务传播行为" class="headerlink" title="2.9)事务传播行为"></a><strong>2.9)事务传播行为</strong></h3><ul><li><p>事务管理员</p></li><li><p>事务协调员</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051734137.png" alt="1591367347482"></p><ul><li>事务传播行为描述的是事务协调员对事务管理员所携带事务的处理态度</li></ul><h3 id="2-10-事务传播行为"><a href="#2-10-事务传播行为" class="headerlink" title="2.10)事务传播行为"></a><strong>2.10)事务传播行为</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051734992.png" alt="1591367375088"></p><h3 id="2-11-事务传播应用"><a href="#2-11-事务传播应用" class="headerlink" title="2.11)事务传播应用"></a><strong>2.11)事务传播应用</strong></h3><ul><li><p>场景A：生成订单业务</p><ul><li><p>子业务S1：记录日志到数据库表X</p></li><li><p>子业务S2：保存订单数据到数据库表Y</p></li><li><p>子业务S3：……</p></li><li><p>如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？</p></li><li><p>（S1需要新事务）</p></li></ul></li><li><p>场景B：生成订单业务</p><ul><li><p>背景1：订单号生成依赖数据库中一个专门用于控制订单号编号生成的表M获取</p></li><li><p>背景2：每次获取完订单号，表M中记录的编号自增1</p></li><li><p>子业务S1：从表M中获取订单编号</p></li><li><p>子业务S2：保存订单数据，订单编号来自于表M</p></li><li><p>子业务S3：……</p></li><li><p>如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？</p></li><li><p>（S1需要新事务）</p></li></ul></li></ul><h3 id="2-12-声明式事务（注解）"><a href="#2-12-声明式事务（注解）" class="headerlink" title="2.12)声明式事务（注解）"></a><strong>2.12)声明式事务（注解）</strong></h3><h4 id="2-12-1-Transactional"><a href="#2-12-1-Transactional" class="headerlink" title="2.12.1)@Transactional"></a>2.12.1)@Transactional</h4><ul><li><p>名称：@Transactional</p></li><li><p>类型：<strong>方法注解，类注解，接口注解</strong></p></li><li><p>位置：方法定义上方，类定义上方，接口定义上方</p></li><li><p>作用：设置当前类&#x2F;接口中所有方法或具体方法开启事务，并指定相关事务属性</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">    readOnly = false,</span></span><br><span class="line"><span class="meta">    timeout = -1,</span></span><br><span class="line"><span class="meta">    isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">    rollbackFor = &#123;ArithmeticException.class, IOException.class&#125;,</span></span><br><span class="line"><span class="meta">    noRollbackFor = &#123;&#125;,</span></span><br><span class="line"><span class="meta">    propagation = Propagation.REQUIRES_NEW</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-12-2-tx-annotation-driven"><a href="#2-12-2-tx-annotation-driven" class="headerlink" title="2.12.2)tx:annotation-driven"></a>2.12.2)tx:annotation-driven</h4><ul><li><p>名称：tx:annotation-driven</p></li><li><p>类型：<strong>标签</strong></p></li><li><p>归属：beans标签</p></li><li><p>作用：开启事务注解驱动，并指定对应的事务管理器</p></li><li><p>范例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-13-声明式事务（纯注解驱动）"><a href="#2-13-声明式事务（纯注解驱动）" class="headerlink" title="2.13)声明式事务（纯注解驱动）"></a><strong>2.13)声明式事务（纯注解驱动）</strong></h3><ul><li><p>名称：@EnableTransactionManagement</p></li><li><p>类型：<strong>类注解</strong></p></li><li><p>位置：Spring注解配置类上方</p></li><li><p>作用：开启注解驱动，等同XML格式中的注解驱动</p></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">getTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-模板对象"><a href="#3-模板对象" class="headerlink" title="3)模板对象"></a>3)模板对象</h2><h3 id="3-1-Spring模块对象"><a href="#3-1-Spring模块对象" class="headerlink" title="3.1)Spring模块对象"></a>3.1)Spring模块对象</h3><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051746253.png" alt="1591368087398"></p><ul><li><p>TransactionTemplate</p></li><li><p>JdbcTemplate</p></li><li><p>RedisTemplate</p></li><li><p>RabbitTemplate</p></li><li><p>JmsTemplate</p></li><li><p>HibernateTemplate</p></li><li><p>RestTemplate</p></li></ul><h3 id="3-2-JdbcTemplate（了解）"><a href="#3-2-JdbcTemplate（了解）" class="headerlink" title="3.2)JdbcTemplate（了解）"></a>3.2)JdbcTemplate（了解）</h3><p>提供标准的sql语句操作API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into account(name,money)values(?,?)&quot;</span>;</span><br><span class="line">    jdbcTemplate.update(sql,account.getName(),account.getMoney());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-NamedParameterJdbcTemplate-了解）"><a href="#3-3-NamedParameterJdbcTemplate-了解）" class="headerlink" title="3.3)NamedParameterJdbcTemplate(了解）"></a>3.3)NamedParameterJdbcTemplate(了解）</h3><p>提供标准的具名sql语句操作API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into account(name,money)values(:name,:money)&quot;</span>;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">pm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    pm.put(<span class="string">&quot;name&quot;</span>,account.getName());</span><br><span class="line">    pm.put(<span class="string">&quot;money&quot;</span>,account.getMoney());</span><br><span class="line">    jdbcTemplate.update(sql,pm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-RedisTemplate"><a href="#3-4-RedisTemplate" class="headerlink" title="3.4)RedisTemplate"></a><strong>3.4)RedisTemplate</strong></h3><p>RedisTemplate对象结构</p><p><img src="/../../../../BaiduNetdiskDownload/17-Spring/day04/%E8%AE%B2%E4%B9%89/assets/1591368270508.png" alt="1591368270508"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeMoney</span><span class="params">(Integer id, Double money)</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;account:id:&quot;</span>+id,money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Double <span class="title function_">findMondyById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">money</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;account:id:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Double</span>(money.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-事务底层原理解析"><a href="#4-事务底层原理解析" class="headerlink" title="4)事务底层原理解析"></a>4)事务底层原理解析</h2><h3 id="4-1-策略模式应用"><a href="#4-1-策略模式应用" class="headerlink" title="4.1)策略模式应用"></a><strong>4.1)策略模式应用</strong></h3><p>策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051734152.png" alt="1591368340720"></p><p>策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。</p><p><img src="https://cdn.jsdelivr.net/gh/lixuyong2014/picture/img/202203051748526.png" alt="1591368370924"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
